#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\core\\dhcp.c"




 





























































 

#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/opt.h"




 































 






 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\network\\include\\lwipopts.h"





















 




#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"





 









#line 22 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"

#line 150 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"

#line 1 "F:\\IAR\\arm\\inc\\c\\stdio.h"
 
 




  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"















 

#line 103 "F:\\IAR\\arm\\inc\\c\\ycheck.h"









#line 11 "F:\\IAR\\arm\\inc\\c\\stdio.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\yvals.h"
 
 





  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 12 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 









  


                 




















 


   
#line 59 "F:\\IAR\\arm\\inc\\c\\yvals.h"





#line 70 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 
#line 1 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"



























 





  #pragma system_include


 
#line 1 "F:\\IAR\\arm\\INC\\c\\DLib_Config_Normal.h"
 
 





  #pragma system_include


 

#line 40 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"
   
#line 47 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"

 
#line 1 "F:\\IAR\\arm\\inc\\c\\DLib_Product.h"




   #pragma system_include







 




 


 



 



 


 




 
#line 45 "F:\\IAR\\arm\\inc\\c\\DLib_Product.h"

 


 


 






 




 


 


 
#line 99 "F:\\IAR\\arm\\inc\\c\\DLib_Product.h"







#line 51 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"











 












 
























 













 























































































































 






 














 
























 


















 
















 








 















 

#line 351 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"













 













 












 














 












 












 












 












 

















 

















 






















 















 








 














 

#line 566 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"












 












 












 












 












 












 












 












 












 










 







 












 







 








 



















































 
















 




#line 812 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"





 

#line 826 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"


   
#line 836 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"

#line 844 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"
  







 









 








 







 






 

#line 899 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"




 







 






 















 

   
#line 943 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"









 

  #pragma language = save 
  #pragma language = extended





  #pragma language = restore










 








 







 
#line 997 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"





 







#line 73 "F:\\IAR\\arm\\inc\\c\\yvals.h"











                 




















 
#line 147 "F:\\IAR\\arm\\inc\\c\\yvals.h"





                 


 




 
 
#line 170 "F:\\IAR\\arm\\inc\\c\\yvals.h"

 




 






 






 
#line 233 "F:\\IAR\\arm\\inc\\c\\yvals.h"











                 
#line 292 "F:\\IAR\\arm\\inc\\c\\yvals.h"









#line 308 "F:\\IAR\\arm\\inc\\c\\yvals.h"








#line 1 "F:\\IAR\\arm\\inc\\c\\xencoding_limits.h"
 
 





  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 12 "F:\\IAR\\arm\\inc\\c\\xencoding_limits.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\yvals.h"
 
 

#line 711 "F:\\IAR\\arm\\inc\\c\\yvals.h"




 
#line 13 "F:\\IAR\\arm\\inc\\c\\xencoding_limits.h"

                                 


#line 24 "F:\\IAR\\arm\\inc\\c\\xencoding_limits.h"




#line 42 "F:\\IAR\\arm\\inc\\c\\xencoding_limits.h"

                                 














#line 317 "F:\\IAR\\arm\\inc\\c\\yvals.h"



                 

                 
#line 335 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 
#line 360 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 
                 




#line 382 "F:\\IAR\\arm\\inc\\c\\yvals.h"


                 

                                 







  #pragma language=save
  #pragma language=extended
  typedef long long _Longlong;
  typedef unsigned long long _ULonglong;
  #pragma language=restore
#line 405 "F:\\IAR\\arm\\inc\\c\\yvals.h"






  typedef unsigned short int _Wchart;
  typedef unsigned short int _Wintt;


#line 424 "F:\\IAR\\arm\\inc\\c\\yvals.h"

#line 432 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 


typedef signed int  _Ptrdifft;
typedef unsigned int     _Sizet;

 


                 







 
  typedef struct __va_list
  {
    char  *_Ap;
  } __va_list;

  typedef __va_list __Va_list;





__intrinsic __nounwind void __iar_Atexit(void (*)(void));



  typedef struct
  {        
    unsigned int _Wchar;
    unsigned int _State;
  } _Mbstatet;
#line 481 "F:\\IAR\\arm\\inc\\c\\yvals.h"










typedef struct
{        

  _Longlong _Off;     



  _Mbstatet _Wstate;
} _Fpost;







                 

#line 1 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"













 





  #pragma system_include






 






















































































 

 



#line 157 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"

  
 

   





  


#line 176 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"





#line 187 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"





  #pragma language=save 
  #pragma language=extended
  __intrinsic __nounwind void __iar_dlib_perthread_initialize(void  *);
  __intrinsic __nounwind void  *__iar_dlib_perthread_allocate(void);
  __intrinsic __nounwind void __iar_dlib_perthread_destroy(void);
  __intrinsic __nounwind void __iar_dlib_perthread_deallocate(void  *);









  #pragma segment = "__DLIB_PERTHREAD" 
  #pragma segment = "__DLIB_PERTHREAD_init" 


























#line 242 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"

   
  void  *__iar_dlib_perthread_access(void  *);
  #pragma language=restore



























     
  









   






  





  
  typedef void *__iar_Rmtx;
  

  
  __intrinsic __nounwind void __iar_system_Mtxinit(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_system_Mtxdst(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_system_Mtxlock(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_system_Mtxunlock(__iar_Rmtx *m);

  __intrinsic __nounwind void __iar_file_Mtxinit(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_file_Mtxdst(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_file_Mtxlock(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_file_Mtxunlock(__iar_Rmtx *m);

  
 
  __intrinsic __nounwind void __iar_clearlocks(void);


#line 323 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"

  





  

#line 341 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"

  typedef unsigned _Once_t;



  













#line 510 "F:\\IAR\\arm\\inc\\c\\yvals.h"

#line 520 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 
#line 528 "F:\\IAR\\arm\\inc\\c\\yvals.h"


                 

  
  
    
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock_Locale(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock_Malloc(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock_Stream(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock_Debug(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock_StaticGuard(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock(unsigned int);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock_Locale(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock_Malloc(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock_Stream(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock_Debug(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock_StaticGuard(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock(unsigned int);

  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Initdynamicfilelock(__iar_Rmtx *);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Dstdynamicfilelock(__iar_Rmtx *);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Lockdynamicfilelock(__iar_Rmtx *);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlockdynamicfilelock(__iar_Rmtx *);
  
  
#line 568 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 
#line 576 "F:\\IAR\\arm\\inc\\c\\yvals.h"

#line 694 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 





#line 709 "F:\\IAR\\arm\\inc\\c\\yvals.h"






 
#line 12 "F:\\IAR\\arm\\inc\\c\\stdio.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\ysizet.h"
 
 





  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 12 "F:\\IAR\\arm\\inc\\c\\ysizet.h"



                 




typedef _Sizet size_t;




typedef unsigned int __data_size_t;











#line 13 "F:\\IAR\\arm\\inc\\c\\stdio.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\ystdio.h"
 
 




  #pragma system_include







#line 58 "F:\\IAR\\arm\\inc\\c\\ystdio.h"
  

 

__intrinsic __nounwind int remove(const char *);
__intrinsic __nounwind int rename(const char *, const char *);














 
#line 14 "F:\\IAR\\arm\\inc\\c\\stdio.h"



 
#pragma rtmodel="__dlib_file_descriptor","0"

                 








#line 66 "F:\\IAR\\arm\\inc\\c\\stdio.h"

#line 88 "F:\\IAR\\arm\\inc\\c\\stdio.h"

#line 99 "F:\\IAR\\arm\\inc\\c\\stdio.h"










                 
typedef _Fpost fpos_t;

                 
#pragma language=save
#pragma language=extended

#line 125 "F:\\IAR\\arm\\inc\\c\\stdio.h"

#line 177 "F:\\IAR\\arm\\inc\\c\\stdio.h"


              
_Pragma("function_effects = no_read(1), always_returns")    __intrinsic __nounwind char * __gets(char *, int);
_Pragma("function_effects = no_read(1), always_returns")    __intrinsic __nounwind char * gets(char *);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind void perror(const char *);
_Pragma("function_effects = no_write(1), always_returns")    _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int printf(const char *, ...);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind int puts(const char *);
_Pragma("function_effects = no_write(1), always_returns")    _Pragma("__scanf_args") _Pragma("library_default_requirements _Scanf = unknown")  __intrinsic __nounwind int scanf(const char *, ...);
_Pragma("function_effects = no_read(1), no_write(2), always_returns") _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int sprintf(char *, 
                                                 const char *, ...);
_Pragma("function_effects = no_write(1,2), always_returns") _Pragma("__scanf_args") _Pragma("library_default_requirements _Scanf = unknown")  __intrinsic __nounwind int sscanf(const char *, 
                                                const char *, ...);
             __intrinsic __nounwind char * tmpnam(char *);
              
             __intrinsic __nounwind int __ungetchar(int);
_Pragma("function_effects = no_write(1), always_returns")    _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int vprintf(const char *,
                                                 __Va_list);

  _Pragma("function_effects = no_write(1), always_returns")    _Pragma("__scanf_args") _Pragma("library_default_requirements _Scanf = unknown")  __intrinsic __nounwind int vscanf(const char *, 
                                                  __Va_list);
  _Pragma("function_effects = no_write(1,2), always_returns") _Pragma("__scanf_args") _Pragma("library_default_requirements _Scanf = unknown")  __intrinsic __nounwind int vsscanf(const char *, 
                                                   const char *, 
                                                   __Va_list);

_Pragma("function_effects = no_read(1), no_write(2), always_returns")  _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int vsprintf(char *, 
                                                   const char *,
                                                   __Va_list);
               
_Pragma("function_effects = no_write(1), always_returns")      __intrinsic __nounwind size_t __write_array(const void *, size_t, size_t);

  _Pragma("function_effects = no_read(1), no_write(3), always_returns") _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int snprintf(char *, size_t, 
                                                    const char *, ...);
  _Pragma("function_effects = no_read(1), no_write(3), always_returns") _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int vsnprintf(char *, size_t,
                                                     const char *, 
                                                     __Va_list);


              __intrinsic __nounwind int getchar(void);
              __intrinsic __nounwind int putchar(int);



#pragma language=restore

#line 238 "F:\\IAR\\arm\\inc\\c\\stdio.h"




#line 292 "F:\\IAR\\arm\\inc\\c\\stdio.h"




 
#line 162 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\stdlib.h"
 
 





  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 12 "F:\\IAR\\arm\\inc\\c\\stdlib.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\ysizet.h"
 
 

#line 30 "F:\\IAR\\arm\\inc\\c\\ysizet.h"







#line 14 "F:\\IAR\\arm\\inc\\c\\stdlib.h"


 
#pragma rtmodel="__dlib_full_locale_support",   "0"





extern int __aeabi_MB_CUR_MAX(void);


#line 34 "F:\\IAR\\arm\\inc\\c\\stdlib.h"





                 













                 


  typedef _Wchart wchar_t;


typedef struct
{        
  int quot;
  int rem;
} div_t;

typedef struct
{        
  long quot;
  long rem;
} ldiv_t;



    #pragma language=save
    #pragma language=extended
    typedef struct
    {      
      _Longlong quot;
      _Longlong rem;
    } lldiv_t;
    #pragma language=restore



                 
  
__intrinsic __nounwind int atexit(void (*)(void));

  __intrinsic __noreturn __nounwind void _Exit(int) ;

__intrinsic __noreturn __nounwind void exit(int) ;
__intrinsic __nounwind char * getenv(const char *);
__intrinsic __nounwind int system(const char *);



             __intrinsic __noreturn __nounwind void abort(void) ;
_Pragma("function_effects = no_state, always_returns")     __intrinsic __nounwind int abs(int);
             __intrinsic __nounwind void * calloc(size_t, size_t);
_Pragma("function_effects = no_state, always_returns")     __intrinsic __nounwind div_t div(int, int);
             __intrinsic __nounwind void free(void *);
_Pragma("function_effects = no_state, always_returns")     __intrinsic __nounwind long labs(long);
_Pragma("function_effects = no_state, always_returns")     __intrinsic __nounwind ldiv_t ldiv(long, long);


    #pragma language=save
    #pragma language=extended
    _Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long llabs(long long);
    _Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind lldiv_t lldiv(long long, long long);
    #pragma language=restore


             __intrinsic __nounwind void * malloc(size_t);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind int mblen(const char *, size_t);
_Pragma("function_effects = no_read(1), no_write(2), always_returns") __intrinsic __nounwind size_t mbstowcs(wchar_t *, 
                                          const char *, size_t);
_Pragma("function_effects = no_read(1), no_write(2), always_returns") __intrinsic __nounwind int mbtowc(wchar_t *, const char *, 
                                     size_t);
             __intrinsic __nounwind int rand(void);
             __intrinsic __nounwind void srand(unsigned int);
             __intrinsic __nounwind void * realloc(void *, size_t);
_Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long strtol(const char *, 
                                      char **, int);
_Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind unsigned long strtoul(const char *, char **, int);
_Pragma("function_effects = no_read(1), no_write(2), always_returns") __intrinsic __nounwind size_t wcstombs(char *, 
                                          const wchar_t *, size_t);
_Pragma("function_effects = no_read(1), always_returns")    __intrinsic __nounwind int wctomb(char *, wchar_t);


    #pragma language=save
    #pragma language=extended
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long long strtoll(const char *, char **, int);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind unsigned long long strtoull(const char *, 
                                                          char **, int);
    #pragma language=restore





#line 188 "F:\\IAR\\arm\\inc\\c\\stdlib.h"



    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind unsigned long __iar_Stoul(const char *, char **, 
                                                        int);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind float         __iar_Stof(const char *, char **, long);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind double        __iar_Stod(const char *, char **, long);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long double   __iar_Stold(const char *, char **, 
                                                          long);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long          __iar_Stolx(const char *, char **, int, 
                                                        int *);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind unsigned long __iar_Stoulx(const char *, char **,
                                                         int, int *);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind float         __iar_Stofx(const char *, char **, 
                                                        long, int *);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind double        __iar_Stodx(const char *, char **, 
                                                        long, int *);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long double   __iar_Stoldx(const char *, char **, 
                                                         long, int *);

      #pragma language=save
      #pragma language=extended
      _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind _Longlong   __iar_Stoll(const char *, char **, 
                                                        int);
      _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind _ULonglong   __iar_Stoull(const char *, char **, 
                                                          int);
      _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind _Longlong    __iar_Stollx(const char *, char **, 
                                                          int, int *);
      _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind _ULonglong   __iar_Stoullx(const char *, char **, 
                                                           int, int *);
      #pragma language=restore








typedef int _Cmpfun(const void *, const void *);

_Pragma("function_effects = no_write(1,2), always_returns") __intrinsic void * bsearch(const void *, 
                                                   const void *, size_t,
                                                   size_t, _Cmpfun *);
             __intrinsic void qsort(void *, size_t, size_t, 
                                               _Cmpfun *);
             __intrinsic void __qsortbbl(void *, size_t, size_t, 
                                                    _Cmpfun *);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind double atof(const char *);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind int atoi(const char *);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind long atol(const char *);


    #pragma language=save
    #pragma language=extended
    _Pragma("function_effects = no_write(1), always_returns") __intrinsic __nounwind long long atoll(const char *);
    #pragma language=restore

  _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind float strtof(const char *, 
                                         char **);
  _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long double strtold(const char *, char **);

_Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind double strtod(const char *, 
                                        char **);
                                        

                                        
               __intrinsic __nounwind size_t __iar_Mbcurmax(void);

  _Pragma("function_effects = no_state, always_returns")     __intrinsic __nounwind int __iar_DLib_library_version(void);

  


#line 276 "F:\\IAR\\arm\\inc\\c\\stdlib.h"



  
  typedef void _Atexfun(void);
  
#line 304 "F:\\IAR\\arm\\inc\\c\\stdlib.h"


                 
    #pragma inline=no_body
    double atof(const char *_S)
    {       
      return (__iar_Stod(_S, 0, 0));
    }

    #pragma inline=no_body
    int atoi(const char *_S)
    {       
      return ((int)__iar_Stoul(_S, 0, 10));
    }

    #pragma inline=no_body
    long atol(const char *_S)
    {       
      return ((long)__iar_Stoul(_S, 0, 10));
    }



        #pragma language=save
        #pragma language=extended
        #pragma inline=no_body
        long long atoll(const char *_S)
        {       



            return ((long long)__iar_Stoull(_S, 0, 10));

        }
        #pragma language=restore



    #pragma inline=no_body
    double strtod(const char * _S, char ** _Endptr)
    {       
      return (__iar_Stod(_S, _Endptr, 0));
    }


      #pragma inline=no_body
      float strtof(const char * _S, char ** _Endptr)
      {       
        return (__iar_Stof(_S, _Endptr, 0));
      }

      #pragma inline=no_body
      long double strtold(const char * _S, char ** _Endptr)
      {       
        return (__iar_Stold(_S, _Endptr, 0));
      }


    #pragma inline=no_body
    long strtol(const char * _S, char ** _Endptr, 
                int _Base)
    {       
      return (__iar_Stolx(_S, _Endptr, _Base, 0));
    }

    #pragma inline=no_body
    unsigned long strtoul(const char * _S, char ** _Endptr, 
                          int _Base)
    {       
      return (__iar_Stoul(_S, _Endptr, _Base));
    }



        #pragma language=save
        #pragma language=extended
        #pragma inline=no_body
        long long strtoll(const char * _S, char ** _Endptr,
                          int _Base)
        {       



            return (__iar_Stoll(_S, _Endptr, _Base));

        }

        #pragma inline=no_body
        unsigned long long strtoull(const char * _S, 
                                    char ** _Endptr, int _Base)
        {       



            return (__iar_Stoull(_S, _Endptr, _Base));

        }
        #pragma language=restore





  #pragma inline=no_body
  int abs(int i)
  {       
    return (i < 0 ? -i : i);
  }

  #pragma inline=no_body
  long labs(long i)
  {       
    return (i < 0 ? -i : i);
  }



      #pragma language=save
      #pragma language=extended
      #pragma inline=no_body
      long long llabs(long long i)
      {       
        return (i < 0 ? -i : i);
      }
      #pragma language=restore



#line 465 "F:\\IAR\\arm\\inc\\c\\stdlib.h"




#line 494 "F:\\IAR\\arm\\inc\\c\\stdlib.h"




 
#line 163 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\string.h"
 
 




  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 11 "F:\\IAR\\arm\\inc\\c\\string.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\ysizet.h"
 
 

#line 30 "F:\\IAR\\arm\\inc\\c\\ysizet.h"







#line 13 "F:\\IAR\\arm\\inc\\c\\string.h"

#line 1 "F:\\IAR\\arm\\inc\\c\\DLib_Product_string.h"








 





  #pragma system_include




  
  

  





 


  




 



#line 47 "F:\\IAR\\arm\\inc\\c\\DLib_Product_string.h"



  


 


  #pragma inline=forced_no_body
  __intrinsic __nounwind void * memcpy(void * _D, const void * _S, size_t _N)
  {
    __aeabi_memcpy(_D, _S, _N);
    return _D;
  }


  #pragma inline=forced_no_body
  __intrinsic __nounwind void * memmove(void * _D, const void * _S, size_t _N)
  {
    __aeabi_memmove(_D, _S, _N);
    return _D;
  }


  #pragma inline=forced_no_body
  __intrinsic __nounwind void * memset(void * _D, int _C, size_t _N)
  {
    __aeabi_memset(_D, _N, _C);
    return _D;
  }

  
  



#line 16 "F:\\IAR\\arm\\inc\\c\\string.h"



                 




                 

_Pragma("function_effects = no_state, no_write(1,2), always_returns")   __intrinsic __nounwind int        memcmp(const void *, const void *,
                                                size_t);
_Pragma("function_effects = no_state, no_read(1), no_write(2), returns 1, always_returns") __intrinsic __nounwind void *     memcpy(void *, 
                                                const void *, size_t);
_Pragma("function_effects = no_state, no_read(1), no_write(2), returns 1, always_returns") __intrinsic __nounwind void *     memmove(void *, const void *, size_t);
_Pragma("function_effects = no_state, no_read(1), returns 1, always_returns")    __intrinsic __nounwind void *     memset(void *, int, size_t);
_Pragma("function_effects = no_state, no_write(2), returns 1, always_returns")    __intrinsic __nounwind char *     strcat(char *, 
                                                const char *);
_Pragma("function_effects = no_state, no_write(1,2), always_returns")   __intrinsic __nounwind int        strcmp(const char *, const char *);
_Pragma("function_effects = no_write(1,2), always_returns")     __intrinsic __nounwind int        strcoll(const char *, const char *);
_Pragma("function_effects = no_state, no_read(1), no_write(2), returns 1, always_returns") __intrinsic __nounwind char *     strcpy(char *, 
                                                const char *);
_Pragma("function_effects = no_state, no_write(1,2), always_returns")   __intrinsic __nounwind size_t     strcspn(const char *, const char *);
                 __intrinsic __nounwind char *     strerror(int);
_Pragma("function_effects = no_state, no_write(1), always_returns")      __intrinsic __nounwind size_t     strlen(const char *);
_Pragma("function_effects = no_state, no_write(2), returns 1, always_returns")    __intrinsic __nounwind char *     strncat(char *, 
                                                 const char *, size_t);
_Pragma("function_effects = no_state, no_write(1,2), always_returns")   __intrinsic __nounwind int        strncmp(const char *, const char *, 
                                                 size_t);
_Pragma("function_effects = no_state, no_read(1), no_write(2), returns 1, always_returns") __intrinsic __nounwind char *     strncpy(char *, 
                                                 const char *, size_t);
_Pragma("function_effects = no_state, no_write(1,2), always_returns")   __intrinsic __nounwind size_t     strspn(const char *, const char *);
_Pragma("function_effects = no_write(2), always_returns")        __intrinsic __nounwind char *     strtok(char *, 
                                                const char *);
_Pragma("function_effects = no_write(2), always_returns")        __intrinsic __nounwind size_t     strxfrm(char *, 
                                                 const char *, size_t);


  _Pragma("function_effects = no_write(1), always_returns")      __intrinsic __nounwind char *   strdup(const char *);
  _Pragma("function_effects = no_write(1,2), always_returns")   __intrinsic __nounwind int      strcasecmp(const char *, const char *);
  _Pragma("function_effects = no_write(1,2), always_returns")   __intrinsic __nounwind int      strncasecmp(const char *, const char *, 
                                                   size_t);
  _Pragma("function_effects = no_state, no_write(2), always_returns")    __intrinsic __nounwind char *   strtok_r(char *, const char *, char **);
  _Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind size_t   strnlen(char const *, size_t);




#line 81 "F:\\IAR\\arm\\inc\\c\\string.h"
  _Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind void *memchr(const void *_S, int _C, size_t _N);
  _Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind char *strchr(const char *_S, int _C);
  _Pragma("function_effects = no_state, no_write(1,2), always_returns") __intrinsic __nounwind char *strpbrk(const char *_S, const char *_P);
  _Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind char *strrchr(const char *_S, int _C);
  _Pragma("function_effects = no_state, no_write(1,2), always_returns") __intrinsic __nounwind char *strstr(const char *_S, const char *_P);




                 


                 

_Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind void *__iar_Memchr(const void *, int, size_t);
_Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind char *__iar_Strchr(const char *, int);
               __intrinsic __nounwind char *__iar_Strerror(int, char *);
_Pragma("function_effects = no_state, no_write(1,2), always_returns") __intrinsic __nounwind char *__iar_Strpbrk(const char *, const char *);
_Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind char *__iar_Strrchr(const char *, int);
_Pragma("function_effects = no_state, no_write(1,2), always_returns") __intrinsic __nounwind char *__iar_Strstr(const char *, const char *);


                 
#line 168 "F:\\IAR\\arm\\inc\\c\\string.h"
                 
    #pragma inline
    void *memchr(const void *_S, int _C, size_t _N)
    {
      return (__iar_Memchr(_S, _C, _N));
    }

    #pragma inline
    char *strchr(const char *_S, int _C)
    {
      return (__iar_Strchr(_S, _C));
    }

    #pragma inline
    char *strpbrk(const char *_S, const char *_P)
    {
      return (__iar_Strpbrk(_S, _P));
    }

    #pragma inline
    char *strrchr(const char *_S, int _C)
    {
      return (__iar_Strrchr(_S, _C));
    }

    #pragma inline
    char *strstr(const char *_S, const char *_P)
    {
      return (__iar_Strstr(_S, _P));
    }


  #pragma inline
  char *strerror(int _Err)
  {
    return (__iar_Strerror(_Err, 0));
  }

#line 451 "F:\\IAR\\arm\\inc\\c\\string.h"






#line 479 "F:\\IAR\\arm\\inc\\c\\string.h"




 
#line 164 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
	#include <stdarg.h>  
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"







 




#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"


 




 



 








 
#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 42 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 52 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 62 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 





 





 





 





 





 





 





 





 





 





 




 





 







 





 






 





 




 




 




 







 




 




 




 






 




 




 




 




 








 
#line 14 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"


















 




#line 1 "F:\\IAR\\arm\\inc\\c\\stdint.h"
 
 




  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 11 "F:\\IAR\\arm\\inc\\c\\stdint.h"



 

  typedef signed char   int8_t;
  typedef unsigned char uint8_t;



  typedef signed short int   int16_t;
  typedef unsigned short int uint16_t;



  typedef signed int   int32_t;
  typedef unsigned int uint32_t;



  #pragma language=save
  #pragma language=extended
  typedef signed long long int   int64_t;
  typedef unsigned long long int uint64_t;
  #pragma language=restore



 
typedef signed char   int_least8_t;
typedef unsigned char uint_least8_t;

typedef signed short int   int_least16_t;
typedef unsigned short int uint_least16_t;

typedef signed int   int_least32_t;
typedef unsigned int uint_least32_t;

 

  #pragma language=save
  #pragma language=extended
  typedef signed long long int int_least64_t;
  #pragma language=restore


  #pragma language=save
  #pragma language=extended
  typedef unsigned long long int uint_least64_t;
  #pragma language=restore




 
typedef signed int   int_fast8_t;
typedef unsigned int uint_fast8_t;

typedef signed int   int_fast16_t;
typedef unsigned int uint_fast16_t;

typedef signed int   int_fast32_t;
typedef unsigned int uint_fast32_t;


  #pragma language=save
  #pragma language=extended
  typedef signed long long int int_fast64_t;
  #pragma language=restore


  #pragma language=save
  #pragma language=extended
  typedef unsigned long long int uint_fast64_t;
  #pragma language=restore


 
#pragma language=save
#pragma language=extended
typedef signed long long int   intmax_t;
typedef unsigned long long int uintmax_t;
#pragma language=restore


 
typedef signed long int   intptr_t;
typedef unsigned long int uintptr_t;

 



typedef int __data_intptr_t; typedef unsigned int __data_uintptr_t;


 






























































































 

































#line 258 "F:\\IAR\\arm\\inc\\c\\stdint.h"




 
#line 25 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"






















		













typedef unsigned int	        uint;
typedef	signed int		        sint;


typedef signed long long        __int64_t;
typedef unsigned long long      __uint64_t;


#line 77 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"





typedef unsigned char           BOOL;


typedef unsigned char           bool;








typedef struct { volatile int counter; } atomic_t;

typedef enum _RTK_STATUS_ {
    _EXIT_SUCCESS = 0,
    _EXIT_FAILURE = 1
}RTK_STATUS, *PRTK_STATUS;

#line 107 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"


typedef void * PVOID;


typedef     uint32_t dma_addr_t;

typedef     void (*proc_t)(void*);

typedef     unsigned int __kernel_size_t;
typedef     int __kernel_ssize_t;

typedef 	__kernel_size_t	SIZE_T;	
typedef	    __kernel_ssize_t	SSIZE_T;

























#line 178 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"







#line 201 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"











 




#line 228 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"

#line 241 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"







 




















































#line 307 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"






#line 319 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"





#line 331 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"

		


		


	


	
#line 348 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"
	
#line 355 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"

#line 363 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"
			









#line 379 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"

#line 386 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"

#line 394 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"








#line 411 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"




typedef unsigned char	BOOLEAN,*PBOOLEAN,boolean;







 








								
								
								
								
								

								
								
#line 449 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"












#line 480 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"







typedef struct _RAM_START_FUNCTION_ {
    void (*RamStartFun) (void);
	void (*RamWakeupFun) (void);
}RAM_START_FUNCTION, *PRAM_START_FUNCTION;

typedef struct _RAM_FUNCTION_START_TABLE_ {
	void (*RamStartFun) (void);
	void (*RamWakeupFun) (void);
	void (*RamPatchFun0) (void);
	void (*RamPatchFun1) (void);
	void (*RamPatchFun2) (void);
	void (*FlashStartFun) (void);
}RAM_FUNCTION_START_TABLE, *PRAM_FUNCTION_START_TABLE;

#line 15 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"

#line 1 "F:\\IAR\\arm\\inc\\c\\stddef.h"
 
 




  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 11 "F:\\IAR\\arm\\inc\\c\\stddef.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\ysizet.h"
 
 

#line 30 "F:\\IAR\\arm\\inc\\c\\ysizet.h"







#line 13 "F:\\IAR\\arm\\inc\\c\\stddef.h"



                 








                 




  typedef _Ptrdifft ptrdiff_t;









#line 49 "F:\\IAR\\arm\\inc\\c\\stddef.h"





 
#line 17 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\app\\monitor\\include\\rtl_trace.h"















 







 




 



 

 
typedef enum {
	MODULE_OS		= 0,   
	MODULE_BOOT		= 1,   
	MODULE_GDMA	= 2,   
	MODULE_GPIO		= 3,   
	MODULE_TIMER	= 4,   
	MODULE_I2C		= 5,   
	MODULE_I2S		= 6,   
	MODULE_PWM		= 7,   
	MODULE_SDIO		= 8,   
	MODULE_SPI		= 9,   
	MODULE_FLASH	= 10,  
	MODULE_UART		= 11,  
	MODULE_USOC		= 12,  
	MODULE_IPSEC	= 13,  
	MODULE_ADC		= 14,  
	MODULE_EFUSE	= 15,  
	MODULE_MONIT	= 16,  
	MODULE_MISC		= 17,  

	MODULE_NUMs            
} MODULE_DEFINE;

 
typedef enum {
	LEVEL_ERROR	= 0,  
	LEVEL_WARN	= 1,  
	LEVEL_INFO		= 2,  
	LEVEL_TRACE	= 3,  
	LEVEL_NUMs		= 4   
} LEVEL_DEFINE;


 



 

 
 
extern uint32_t ConfigDebug[];
 


















 
void LOG_MASK_MODULE(uint32_t module, uint32_t level, uint32_t new_status);
void LOG_MASK(uint32_t config[]);
void LOG_PRINTF(uint32_t module, uint32_t level, uint32_t line, const char*fmt, ...);



 
#line 120 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\app\\monitor\\include\\rtl_trace.h"



 



 



 


 
#line 18 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"

extern uint32_t ConfigDebugClose;
extern uint32_t ConfigDebugErr;
extern uint32_t ConfigDebugInfo;
extern uint32_t ConfigDebugWarn;

extern uint32_t CfgSysDebugErr;
extern uint32_t CfgSysDebugInfo;
extern uint32_t CfgSysDebugWarn;










#line 57 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"

extern  uint32_t DiagPrintf(const char *fmt, ...);
uint32_t DiagSPrintf(uint8_t *buf, const char *fmt, ...);
int prvDiagPrintf(const char *fmt, ...);
int prvDiagSPrintf(char *buf, const char *fmt, ...);






























#line 100 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"








































#line 153 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"

#line 161 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"

typedef enum {
	DBG_CFG_ERR=0,
	DBG_CFG_WARN=1,
	DBG_CFG_INFO=2
} DBG_CFG_TYPE;

typedef struct {
	uint8_t cmd_name[16];
	uint32_t	cmd_type;
} DBG_CFG_CMD;

typedef enum _CONSOLE_OP_STAGE_ {
	ROM_STAGE = 0,
	RAM_STAGE = 1
}CONSOLE_OP_STAGE;

#line 166 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\strproc.h"







 




#line 1 "F:\\IAR\\arm\\inc\\c\\stddef.h"
 
 
#line 39 "F:\\IAR\\arm\\inc\\c\\stddef.h"

#line 49 "F:\\IAR\\arm\\inc\\c\\stddef.h"





 
#line 14 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\strproc.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\va_list.h"







 




#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"


 




 



 








 
#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 42 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 52 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 62 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 





 





 





 





 





 





 





 





 





 





 




 





 







 





 






 





 




 




 




 







 




 




 




 






 




 




 




 




 








 
#line 14 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\va_list.h"


#line 36 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\va_list.h"

#line 15 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\strproc.h"

#line 24 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\strproc.h"

extern  SIZE_T _strlen(const char *s);
extern  int _strcmp(const char *cs, const char *ct);
extern  char *_strncpy(char *dest, const char *src, size_t count);
extern  char *_strcpy(char *dest, const char *src);
extern  size_t _strlen(const char *s);
extern  size_t _strnlen(const char *s, size_t count);
extern  int _strncmp(const char *cs, const char *ct, size_t count);
extern  int _sscanf(const char *buf, const char *fmt, ...);
extern  char *_strsep(char **s, const char *ct);
extern  char *skip_spaces(const char *str);
extern  int skip_atoi(const char **s);
extern  int _vsscanf(const char *buf, const char *fmt, va_list args);
extern  unsigned long long simple_strtoull(const char *cp, char **endp, unsigned int base);
extern  long simple_strtol(const char *cp, char **endp, unsigned int base);
extern  long long simple_strtoll(const char *cp, char **endp, unsigned int base);
extern  unsigned long simple_strtoul(const char *cp, char **endp, unsigned int base);
extern  const char *_parse_integer_fixup_radix(const char *s, unsigned int *base);
extern  unsigned int _parse_integer(const char *s, unsigned int base, unsigned long long *p);
extern  uint64_t div_u64(uint64_t dividend, uint32_t divisor);
extern  int64_t div_s64(int64_t dividend, int32_t divisor);
extern  uint64_t div_u64_rem(uint64_t dividend, uint32_t divisor, uint32_t *remainder);
extern  int64_t div_s64_rem(int64_t dividend, int32_t divisor, int32_t *remainder);
extern  char *_strpbrk(const char *cs, const char *ct);
extern  char *_strchr(const char *s, int c);


extern  void
prvStrCpy(
      uint8_t  *pDES,
      const uint8_t  *pSRC
);

extern  uint32_t
prvStrLen(
      const   uint8_t  *pSRC
);

extern   uint8_t
prvStrCmp(
      const   uint8_t  *string1,
      const   uint8_t  *string2
);

extern  uint8_t*
StrUpr(
      uint8_t  *string
);

extern  int prvAtoi(
	 const char * s
);

extern   char * prvStrStr(
	 const char * str1, 
	 const char * str2
);

extern  char* prvStrtok(
	 char *str, 
	 const char* delim
);





 
static inline char _tolower(const char c)
{
    return c | 0x20;
}

 
static inline int isodigit(const char c)
{
    return c >= '0' && c <= '7';
}
#line 108 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\strproc.h"

#line 167 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\memproc.h"







 






 
extern  void *_memset( void *s, int c, SIZE_T n );
extern  void *_memcpy( void *s1, const void *s2, SIZE_T n );
extern  int _memcmp( const void *av, const void *bv, SIZE_T len );



#line 168 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\std_lib\\include\\rtl_lib.h"




 
 








extern int __rtl_errno;


void init_rom_libgloss_ram_map(void);






extern int rtl_printf( const char* fmt, ...);
extern int rtl_vprintf(const char *fmt, va_list ap);
extern int rtl_sprintf(char* str, const char* fmt, ...);
extern int rtl_snprintf(char* str, size_t size, const char* fmt, ...);
extern int rtl_vsnprintf(char *str, size_t size, const char *fmt, va_list ap);





extern void * rtl_memchr(const void * src_void , int c , size_t length);
extern int rtl_memcmp(const void * m1 , const void * m2 , size_t n);
extern void * rtl_memcpy(void * dst0 , const void * src0 , size_t len0);
extern void * rtl_memmove( void * dst_void , const void * src_void , size_t length);
extern void * rtl_memset(void * m , int c , size_t n);
extern char * rtl_strcat(char * s1 , const char * s2);
extern char * rtl_strchr(const char *s1 , int i);
extern int rtl_strcmp(const char *s1 ,	const char *s2);
extern char* rtl_strcpy(char *dst0 , const char *src0);
extern size_t rtl_strlen(const char *str);
extern char * rtl_strncat(char * s1 , const char * s2 , size_t n);
extern int rtl_strncmp(const char *s1 , const char *s2 , size_t n);
extern char * rtl_strncpy(char * dst0 , const char * src0 , size_t count);
extern char * rtl_strstr(const char *searchee , const char *lookfor);
extern char * rtl_strsep(char **source_ptr , const char *delim);
extern char * rtl_strtok(char * s , const char * delim);






extern double rtl_fabs(double);
extern float rtl_fabsf(float a);
extern float rtl_cos_f32(float a);
extern float rtl_sin_f32(float a);

extern float rtl_fadd(float a, float b);
extern float rtl_fsub(float a, float b);
extern float rtl_fmul(float a, float b);
extern float rtl_fdiv(float a, float b);

extern int rtl_fcmplt(float a, float b);
extern int rtl_fcmpgt(float a, float b);








extern double rtl_ftod(float f);

extern double rtl_ddiv(double a, double b);






typedef union
{
  float value;
  uint32_t 	word;
} ieee_float_shape_type;

 

#line 100 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\std_lib\\include\\rtl_lib.h"

 

#line 109 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\std_lib\\include\\rtl_lib.h"

static inline
float rtl_nanf(void)
{
	float x;

	do { ieee_float_shape_type sf_u; sf_u . word = (0x7fc00000); (x) = sf_u . value; } while (0);
	return x;
}






extern int rtl_sscanf_patch_test(void);
extern int rtl_lib_test( uint16_t argc,  uint8_t *argv[]);
extern int rtl_math_test( uint16_t argc,  uint8_t *argv[]);
extern int rtl_string_test( uint16_t argc,  uint8_t *argv[]);
















#line 171 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\std_lib\\libc\\rom\\string\\rom_libc_string.h"




 





#line 27 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\std_lib\\libc\\rom\\string\\rom_libc_string.h"





extern  void * __rtl_memchr_v1_00(const void * src_void , int c , size_t length);
extern  int __rtl_memcmp_v1_00(const void * m1 , const void * m2 , size_t n);
extern  void * __rtl_memcpy_v1_00(void *  dst0 , const void *  src0 , size_t len0);
extern  void * __rtl_memmove_v1_00( void * dst_void , const void * src_void , size_t length);
extern  void * __rtl_memset_v1_00(void * m , int c , size_t n);
extern  char * __rtl_strcat_v1_00(char * s1 , const char * s2);
extern  char * __rtl_strchr_v1_00(const char *s1 , int i);
extern  int __rtl_strcmp_v1_00(const char *s1 ,	const char *s2);
extern  char* __rtl_strcpy_v1_00(char *dst0 , const char *src0);
extern  size_t __rtl_strlen_v1_00(const char *str);
extern  char * __rtl_strncat_v1_00(char * s1 , const char * s2 , size_t n);
extern  int __rtl_strncmp_v1_00(const char *s1 , const char *s2 , size_t n);
extern  char * __rtl_strncpy_v1_00(char * dst0 , const char * src0 , size_t count);
extern  char * __rtl_strstr_v1_00(const char *searchee , const char *lookfor);
extern  char * __rtl_strsep_v1_00(register char **source_ptr , register const char *delim);
extern  char * __rtl_strtok_v1_00(register char * s , register const char * delim);

#line 172 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"


#line 196 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
	
#line 218 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
	
#line 227 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
	



	
#line 240 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
	
	
	






extern void *pvPortMalloc( size_t xWantedSize );
extern void vPortFree( void *pv );
#line 259 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"


#line 28 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\network\\include\\lwipopts.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"




 




#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"


 




 



 








 
#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"



 
#line 42 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"



 
#line 52 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"



 
#line 62 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"



 





 





 





 





 





 





 





 





 





 





 




 





 







 





 






 





 




 




 




 







 




 




 




 






 




 




 




 




 








 
#line 11 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"
 




 
#line 27 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"

 




 
#line 41 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"



 


 



 










 







#line 83 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"

 
#line 96 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"

 
#line 106 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"

 


 


 





 







 



 
#line 143 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"



 







 



 

#line 174 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"
 

 


 


 


 


 

   
 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 
#line 255 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"

 
#line 270 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"

 


#line 286 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"

 
#line 302 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"











 





 





















 

 


 
#line 358 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"

 
#line 379 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"

 






 





 

 
#line 403 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"






 


	 
 


 


 


 


 
















#line 450 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"

#line 29 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\network\\include\\lwipopts.h"

    




 



 










 






 


 



 
#line 72 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\network\\include\\lwipopts.h"



 


 


 


 


 


 



 
 






 






 



 




 


 


 



 



 



 


 


 


 



 


 


 


 




 



 


#line 187 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\network\\include\\lwipopts.h"

#line 217 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\network\\include\\lwipopts.h"

 








 





 




#line 252 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\network\\include\\lwipopts.h"
   

   

   

   

   

   








 


 






 


 






 








 

#line 310 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\network\\include\\lwipopts.h"

 






 
#line 46 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/opt.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/debug.h"






























 



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/arch.h"






























 











#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/cc.h"






























 



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch\\cpu.h"






























 





#line 36 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/cc.h"

typedef unsigned   char    u8_t;
typedef signed     char    s8_t;
typedef unsigned   short   u16_t;
typedef signed     short   s16_t;
typedef unsigned   int    u32_t;
typedef signed     long    s32_t;
typedef u32_t mem_ptr_t;
typedef int sys_prot_t;

#line 53 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/cc.h"

 
#line 68 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/cc.h"







#line 98 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/cc.h"



#line 44 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/arch.h"

 




 




























#line 136 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/arch.h"



#line 203 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/arch.h"





extern int errno;








#line 36 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/debug.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/opt.h"




 































 
#line 37 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/debug.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\stdio.h"
 
 
#line 241 "F:\\IAR\\arm\\inc\\c\\stdio.h"

#line 292 "F:\\IAR\\arm\\inc\\c\\stdio.h"




 
#line 38 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/debug.h"





 
#line 50 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/debug.h"

 

 


 

 

 

 


#line 71 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/debug.h"

 








 


#line 96 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/debug.h"







#line 47 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/opt.h"





 





 







 







 







 







 








 




 








 








 







 








 












 







 









 







 









 





















 








 




 







 








 







 







 







 







 










 









 









 









 







 







 








 








 






 







 








 








 







 







 







 






 








 


 






 










 













 











 






 








 






 









 




 








 








 








 








 









 










 







 






 








 







 










 








 








 



 






 






 






 








 


 






 








 


 






 








 


 







 










 








 



 








 







 








 








 







 








 







 








 


 








 



 




 




 




 




 




 













 





 








 


 






 






 






 








 


 






 







 






 






 







 










 











 








 







 








 








 







 







 






 








 

















 






 







 










 










 




 








 








 



 






 







 







 







 










 







 







 
















 












 








 


 








 


 








 


 








 








 








 






 








 








 






 








 








 






 








 








 








 








 








 








 








 



 







 






 






 








 


 







 








 








 







 







 






 






 






 








 








 


 




#line 1603 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/opt.h"

#line 1616 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/opt.h"







 


 






 






 




#line 1782 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/opt.h"





 


 



 


 



 


 






 



 


 



 


 






 







 








 

 











 







 





 




 







 






 






 






 






 






 






 






 






 






 






 






 






 






 






 






 






 






 






 






 







 






 






 






 






 






 






 






 






 






 






 






 






 






 






 




#line 70 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\core\\dhcp.c"



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/stats.h"






























 





#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/mem.h"






























 









#line 68 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/mem.h"



 




typedef u16_t mem_size_t;



#line 87 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/mem.h"
 
void  mem_init(void);
void *mem_trim(void *mem, mem_size_t size);

void *mem_malloc(mem_size_t size);
void *mem_calloc(mem_size_t count, mem_size_t size);
void  mem_free(void *mem);





 







 






 








#line 38 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/stats.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/memp.h"






























 










 
typedef enum {
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/memp_std.h"










 


 







 









 

MEMP_RAW_PCB,



MEMP_UDP_PCB,



MEMP_TCP_PCB,
MEMP_TCP_PCB_LISTEN,
MEMP_TCP_SEG,



MEMP_REASSDATA,


MEMP_FRAG_PBUF,



MEMP_NETBUF,
MEMP_NETCONN,



MEMP_TCPIP_MSG_API,

MEMP_TCPIP_MSG_INPKT,








MEMP_IGMP_GROUP,



MEMP_SYS_TIMEOUT,


#line 85 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/memp_std.h"
MEMP_NETDB,
#line 93 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/memp_std.h"








 
MEMP_PBUF,
MEMP_PBUF_POOL,





 







 
#line 46 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/memp.h"
  MEMP_MAX
} memp_t;

#line 77 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/memp.h"





#line 91 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/memp.h"

#line 99 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/memp.h"

void  memp_init(void);





void *memp_malloc(memp_t type);

void  memp_free(memp_t type, void *mem);







#line 39 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/stats.h"





#line 166 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/stats.h"

#line 174 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/stats.h"

#line 182 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/stats.h"

#line 190 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/stats.h"

#line 198 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/stats.h"

#line 206 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/stats.h"

#line 214 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/stats.h"

#line 222 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/stats.h"

#line 230 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/stats.h"

#line 244 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/stats.h"

#line 258 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/stats.h"

#line 270 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/stats.h"

 
#line 287 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/stats.h"





#line 74 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\core\\dhcp.c"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/udp.h"






























 







#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/pbuf.h"






























 




#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/err.h"






























 











 



typedef s8_t err_t;


 

#line 62 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/err.h"














extern const char *lwip_strerr(err_t err);








#line 38 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/pbuf.h"






 





typedef enum {
  PBUF_TRANSPORT,
  PBUF_IP,
  PBUF_LINK,
  PBUF_RAW
} pbuf_layer;

typedef enum {
  PBUF_RAM,  
  PBUF_ROM,  
  PBUF_REF,  
  PBUF_POOL  
} pbuf_type;


 


 

 

 

 

 


struct pbuf {
   
  struct pbuf *next;

   
  void *payload;

  





 
  u16_t tot_len;

   
  u16_t len;

   
  u8_t   type;

   
  u8_t flags;

  



 
  u16_t ref;
};


 
typedef void (*pbuf_free_custom_fn)(struct pbuf *p);

 
struct pbuf_custom {
   
  struct pbuf pbuf;
   
  pbuf_free_custom_fn custom_free_function;
};



 
#line 142 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/pbuf.h"

 


struct pbuf *pbuf_alloc(pbuf_layer l, u16_t length, pbuf_type type);

struct pbuf *pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type,
                                 struct pbuf_custom *p, void *payload_mem,
                                 u16_t payload_mem_len);

void pbuf_realloc(struct pbuf *p, u16_t size); 
u8_t pbuf_header(struct pbuf *p, s16_t header_size);
void pbuf_ref(struct pbuf *p);
u8_t pbuf_free(struct pbuf *p);
u8_t pbuf_clen(struct pbuf *p);  
void pbuf_cat(struct pbuf *head, struct pbuf *tail);
void pbuf_chain(struct pbuf *head, struct pbuf *tail);
struct pbuf *pbuf_dechain(struct pbuf *p);
err_t pbuf_copy(struct pbuf *p_to, struct pbuf *p_from);
u16_t pbuf_copy_partial(struct pbuf *p, void *dataptr, u16_t len, u16_t offset);
err_t pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len);
struct pbuf *pbuf_coalesce(struct pbuf *p, pbuf_layer layer);





u8_t pbuf_get_at(struct pbuf* p, u16_t offset);
u16_t pbuf_memcmp(struct pbuf* p, u16_t offset, const void* s2, u16_t n);
u16_t pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset);
u16_t pbuf_strstr(struct pbuf* p, const char* substr);





#line 40 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/udp.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/netif.h"






























 









#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/ip_addr.h"






























 



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/def.h"






























 



 














 











 

#line 76 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/def.h"







#line 99 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/def.h"
u16_t lwip_htons(u16_t x);
u16_t lwip_ntohs(u16_t x);
u32_t lwip_htonl(u32_t x);
u32_t lwip_ntohl(u32_t x);




 
#line 115 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/def.h"









#line 37 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/ip_addr.h"






 
struct ip_addr {
  u32_t addr;
};


 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/bpstruct.h"






























 


#pragma pack(1)


#line 52 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/ip_addr.h"


struct ip_addr_packed {
  u32_t addr;
} ;

#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/epstruct.h"






























 


#pragma pack()




#line 60 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/ip_addr.h"



 
typedef struct ip_addr ip_addr_t;
typedef struct ip_addr_packed ip_addr_p_t;




 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/bpstruct.h"






























 


#pragma pack(1)


#line 73 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/ip_addr.h"


struct ip_addr2 {
  u16_t addrw[2];
} ;

#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/epstruct.h"






























 


#pragma pack()




#line 81 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/ip_addr.h"


 
struct netif;

extern const ip_addr_t ip_addr_any;
extern const ip_addr_t ip_addr_broadcast;



 



 

 

 

 





 





























#line 145 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/ip_addr.h"

 
#line 153 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/ip_addr.h"



 




 

 



 

 

 


 



 

 


 









 









u8_t ip4_addr_isbroadcast(u32_t addr, const struct netif *netif);


u8_t ip4_addr_netmask_valid(u32_t netmask);





#line 218 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/ip_addr.h"

 





 





 


u32_t ipaddr_addr(const char *cp);
int ipaddr_aton(const char *cp, ip_addr_t *addr);
 
char *ipaddr_ntoa(const ip_addr_t *addr);
char *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen);





#line 42 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/netif.h"




struct dhcp;


struct autoip;







 


 







 


 


 


 





 



 



 


 









 
typedef err_t (*netif_init_fn)(struct netif *netif);





 
typedef err_t (*netif_input_fn)(struct pbuf *p, struct netif *inp);







 
typedef err_t (*netif_output_fn)(struct netif *netif, struct pbuf *p,
       ip_addr_t *ipaddr);





 
typedef err_t (*netif_linkoutput_fn)(struct netif *netif, struct pbuf *p);
 
typedef void (*netif_status_callback_fn)(struct netif *netif);
 
typedef err_t (*netif_igmp_mac_filter_fn)(struct netif *netif,
       ip_addr_t *group, u8_t action);



 
struct netif {
   
  struct netif *next;

   
  ip_addr_t ip_addr;
  ip_addr_t netmask;
  ip_addr_t gw;

  
 
  netif_input_fn input;
  

 
  netif_output_fn output;
  

 
  netif_linkoutput_fn linkoutput;
#line 173 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/netif.h"
  
 
  void *state;

   
  struct dhcp *dhcp;


   
  struct autoip *autoip;





   
  u16_t mtu;
   
  u8_t hwaddr_len;
   
  u8_t hwaddr[6U];
   
  u8_t flags;
   
  char name[2];
   
  u8_t num;
#line 218 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/netif.h"
  
 
  netif_igmp_mac_filter_fn igmp_mac_filter;
#line 233 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/netif.h"
};

#line 253 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/netif.h"


 
extern struct netif *netif_list;
 
extern struct netif *netif_default;

void netif_init(void);

struct netif *netif_add(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
      ip_addr_t *gw, void *state, netif_init_fn init, netif_input_fn input);

void
netif_set_addr(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
      ip_addr_t *gw);
void netif_remove(struct netif * netif);




 
struct netif *netif_find(char *name);

void netif_set_default(struct netif *netif);

void netif_set_ipaddr(struct netif *netif, ip_addr_t *ipaddr);
void netif_set_netmask(struct netif *netif, ip_addr_t *netmask);
void netif_set_gw(struct netif *netif, ip_addr_t *gw);

void netif_set_up(struct netif *netif);
void netif_set_down(struct netif *netif);
 


#line 293 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/netif.h"

void netif_set_link_up(struct netif *netif);
void netif_set_link_down(struct netif *netif);
  
















#line 320 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/netif.h"











#line 41 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/udp.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/ip.h"






























 















 












 














 
#line 88 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/ip.h"

struct ip_pcb {
 
  ip_addr_t local_ip; ip_addr_t remote_ip; u8_t so_options; u8_t tos; u8_t ttl ;
};



 
 



 

 

 
 

 



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/bpstruct.h"






























 


#pragma pack(1)


#line 114 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/ip.h"


struct ip_hdr {
   
  u8_t _v_hl;
   
  u8_t _tos;
   
  u16_t _len;
   
  u16_t _id;
   
  u16_t _offset;




   
  u8_t _ttl;
   
  u8_t _proto;
   
  u16_t _chksum;
   
  ip_addr_p_t src;
  ip_addr_p_t dest; 
} ;

#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/epstruct.h"






























 


#pragma pack()




#line 144 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/ip.h"


#line 155 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/ip.h"

#line 164 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/ip.h"

 
extern struct netif *current_netif;
 
extern const struct ip_hdr *current_header;
 
extern ip_addr_t current_iphdr_src;
 
extern ip_addr_t current_iphdr_dest;


struct netif *ip_route(ip_addr_t *dest);
err_t ip_input(struct pbuf *p, struct netif *inp);
err_t ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
       u8_t ttl, u8_t tos, u8_t proto);
err_t ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
       u8_t ttl, u8_t tos, u8_t proto,
       struct netif *netif);





err_t ip_output_if_opt(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
       u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
       u16_t optlen);



 



 

 

 


 

 

 















#line 43 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/udp.h"







 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/bpstruct.h"






























 


#pragma pack(1)


#line 53 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/udp.h"


struct udp_hdr {
  u16_t src;
  u16_t dest;   
  u16_t len;
  u16_t chksum;
} ;

#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/epstruct.h"






























 


#pragma pack()




#line 64 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/udp.h"







struct udp_pcb;














 
typedef void (*udp_recv_fn)(void *arg, struct udp_pcb *pcb, struct pbuf *p,
    ip_addr_t *addr, u16_t port);


struct udp_pcb {
 
  ip_addr_t local_ip; ip_addr_t remote_ip; u8_t so_options; u8_t tos; u8_t ttl ;

 

  struct udp_pcb *next;

  u8_t flags;
   
  u16_t local_port, remote_port;


   
  ip_addr_t multicast_ip;







   
  udp_recv_fn recv;
   
  void *recv_arg;  
};
 
extern struct udp_pcb *udp_pcbs;


 
struct udp_pcb * udp_new        (void);
void             udp_remove     (struct udp_pcb *pcb);
err_t            udp_bind       (struct udp_pcb *pcb, ip_addr_t *ipaddr,
                                 u16_t port);
err_t            udp_connect    (struct udp_pcb *pcb, ip_addr_t *ipaddr,
                                 u16_t port);
void             udp_disconnect (struct udp_pcb *pcb);
void             udp_recv       (struct udp_pcb *pcb, udp_recv_fn recv,
                                 void *recv_arg);
err_t            udp_sendto_if  (struct udp_pcb *pcb, struct pbuf *p,
                                 ip_addr_t *dst_ip, u16_t dst_port,
                                 struct netif *netif);
err_t            udp_sendto     (struct udp_pcb *pcb, struct pbuf *p,
                                 ip_addr_t *dst_ip, u16_t dst_port);
err_t            udp_send       (struct udp_pcb *pcb, struct pbuf *p);

#line 150 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/udp.h"




 
void             udp_input      (struct pbuf *p, struct netif *inp);

void             udp_init       (void);













#line 76 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\core\\dhcp.c"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sys.h"






























 









#line 76 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sys.h"

 




 


#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/sys_arch.h"






























 



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"































































 






 
#line 1 "F:\\IAR\\arm\\inc\\c\\stddef.h"
 
 
#line 39 "F:\\IAR\\arm\\inc\\c\\stddef.h"

#line 49 "F:\\IAR\\arm\\inc\\c\\stddef.h"





 
#line 73 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"













 
#line 1 "F:\\IAR\\arm\\inc\\c\\stdint.h"
 
 
#line 235 "F:\\IAR\\arm\\inc\\c\\stdint.h"

#line 258 "F:\\IAR\\arm\\inc\\c\\stdint.h"




 
#line 88 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"





 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"


































































 

#line 1 "F:\\IAR\\arm\\inc\\c\\stdint.h"
 
 
#line 235 "F:\\IAR\\arm\\inc\\c\\stdint.h"

#line 258 "F:\\IAR\\arm\\inc\\c\\stdint.h"




 
#line 73 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"
extern uint32_t SystemCoreClock; 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"


 




 



 








 
#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"



 
#line 42 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"



 
#line 52 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"



 
#line 62 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"



 





 





 





 





 





 





 





 





 





 





 




 





 







 





 






 





 




 




 




 







 




 




 




 






 




 




 




 




 








 
#line 76 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"











 

#line 108 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"






#line 127 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"







extern void freertos_pre_sleep_processing(unsigned int *expected_idle_time);
extern void freertos_post_sleep_processing(unsigned int *expected_idle_time);
extern int  freertos_ready_to_sleep();

 


 


 




 






                                                        



 





 
#line 176 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"

 
#line 184 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"



 





 




 


 





#line 95 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"

 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\projdefs.h"































































 







 
typedef void (*TaskFunction_t)( void * );

 










 








#line 98 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"

 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\portable.h"































































 



 







 










































































































































































#line 254 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\portable.h"

#line 262 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\portable.h"







#line 276 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\portable.h"











































 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\portable\\IAR\\ARM_CM4F\\portmacro.h"































































 

















 

 
#line 92 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\portable\\IAR\\ARM_CM4F\\portmacro.h"

typedef uint32_t StackType_t;
typedef long BaseType_t;
typedef unsigned long UBaseType_t;





	typedef uint32_t TickType_t;


 

 



 

 
extern void vPortYield( void );





 

 






	 




	 



	 

#line 1 "F:\\IAR\\arm\\inc\\c\\intrinsics.h"








 




#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 15 "F:\\IAR\\arm\\inc\\c\\intrinsics.h"


  #pragma system_include




 





 









#pragma language=save
#pragma language=extended

__intrinsic __nounwind void    __no_operation(void);

__intrinsic __nounwind void    __disable_interrupt(void);
__intrinsic __nounwind void    __enable_interrupt(void);

typedef unsigned long __istate_t;

__intrinsic __nounwind __istate_t __get_interrupt_state(void);
__intrinsic __nounwind void __set_interrupt_state(__istate_t);



 
__intrinsic __nounwind unsigned long __get_PSR( void );
__intrinsic __nounwind unsigned long __get_IPSR( void );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __get_MSP( void );
__intrinsic __nounwind void          __set_MSP( unsigned long );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __get_PSP( void );
__intrinsic __nounwind void          __set_PSP( unsigned long );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __get_PRIMASK( void );
__intrinsic __nounwind void          __set_PRIMASK( unsigned long );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __get_CONTROL( void );
__intrinsic __nounwind void          __set_CONTROL( unsigned long );



 
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __get_FAULTMASK( void );
__intrinsic __nounwind void          __set_FAULTMASK(unsigned long);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __get_BASEPRI( void );
__intrinsic __nounwind void          __set_BASEPRI( unsigned long );

#line 80 "F:\\IAR\\arm\\inc\\c\\intrinsics.h"

__intrinsic __nounwind void __disable_fiq(void);
__intrinsic __nounwind void __enable_fiq(void);


 

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SWP( unsigned long, volatile unsigned long * );
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned char __SWPB( unsigned char, volatile unsigned char * );

typedef unsigned long __ul;





 
__intrinsic __nounwind void          __MCR( unsigned __constrange(0,15) coproc, unsigned __constrange(0,8) opcode_1, __ul src,
                                 unsigned __constrange(0,15) CRn, unsigned __constrange(0,15) CRm, unsigned __constrange(0,8) opcode_2 );
__intrinsic __nounwind unsigned long __MRC( unsigned __constrange(0,15) coproc, unsigned __constrange(0,8) opcode_1,
                                 unsigned __constrange(0,15) CRn, unsigned __constrange(0,15) CRm, unsigned __constrange(0,8) opcode_2 );
__intrinsic __nounwind void          __MCR2( unsigned __constrange(0,15) coproc, unsigned __constrange(0,8) opcode_1, __ul src,
                                  unsigned __constrange(0,15) CRn, unsigned __constrange(0,15) CRm, unsigned __constrange(0,8) opcode_2 );
__intrinsic __nounwind unsigned long __MRC2( unsigned __constrange(0,15) coproc, unsigned __constrange(0,8) opcode_1,
                                  unsigned __constrange(0,15) CRn, unsigned __constrange(0,15) CRm, unsigned __constrange(0,8) opcode_2 );

 
__intrinsic __nounwind void __LDC( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src);
__intrinsic __nounwind void __LDCL( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src);
__intrinsic __nounwind void __LDC2( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src);
__intrinsic __nounwind void __LDC2L( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src);

 
__intrinsic __nounwind void __STC( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst);
__intrinsic __nounwind void __STCL( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst);
__intrinsic __nounwind void __STC2( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst);
__intrinsic __nounwind void __STC2L( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst);

 
__intrinsic __nounwind void __LDC_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src,
                              unsigned __constrange(0,255) option);

__intrinsic __nounwind void __LDCL_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src,
                               unsigned __constrange(0,255) option);

__intrinsic __nounwind void __LDC2_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src,
                               unsigned __constrange(0,255) option);

__intrinsic __nounwind void __LDC2L_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src,
                                unsigned __constrange(0,255) option);

 
__intrinsic __nounwind void __STC_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst,
                              unsigned __constrange(0,255) option);

__intrinsic __nounwind void __STCL_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst,
                               unsigned __constrange(0,255) option);

__intrinsic __nounwind void __STC2_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst,
                               unsigned __constrange(0,255) option);

__intrinsic __nounwind void __STC2L_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst,
                                unsigned __constrange(0,255) option);


 
__intrinsic __nounwind unsigned long __get_APSR( void );
__intrinsic __nounwind void          __set_APSR( unsigned long );






 
__intrinsic __nounwind unsigned long __get_FPSCR( void );
__intrinsic __nounwind void __set_FPSCR( unsigned long );

 
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned char __CLZ( unsigned long );

 

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind signed long __QADD( signed long, signed long );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind signed long __QDADD( signed long, signed long );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind signed long __QSUB( signed long, signed long );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind signed long __QDSUB( signed long, signed long );

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind signed long __QDOUBLE( signed long );

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind int         __QFlag( void );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind void __reset_Q_flag( void );


_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind int         __QCFlag( void );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind void __reset_QC_flag( void );

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind signed long __SMUL( signed short, signed short );

 
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __REV( unsigned long );
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind signed long __REVSH( short );

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __REV16( unsigned long );
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __RBIT( unsigned long );

_Pragma("function_effects = no_state, no_write(1), always_returns") __intrinsic __nounwind unsigned char  __LDREXB( volatile unsigned char const * );
_Pragma("function_effects = no_state, no_write(1), always_returns") __intrinsic __nounwind unsigned short __LDREXH( volatile unsigned short const * );
_Pragma("function_effects = no_state, no_write(1), always_returns") __intrinsic __nounwind unsigned long  __LDREX ( volatile unsigned long const * );
_Pragma("function_effects = no_state, no_write(1), always_returns") __intrinsic __nounwind unsigned long long __LDREXD( volatile unsigned long long const * );

_Pragma("function_effects = no_state, no_read(2), always_returns") __intrinsic __nounwind unsigned long  __STREXB( unsigned char, volatile unsigned char * );
_Pragma("function_effects = no_state, no_read(2), always_returns") __intrinsic __nounwind unsigned long  __STREXH( unsigned short, volatile unsigned short * );
_Pragma("function_effects = no_state, no_read(2), always_returns") __intrinsic __nounwind unsigned long  __STREX ( unsigned long, volatile unsigned long * );
_Pragma("function_effects = no_state, no_read(2), always_returns") __intrinsic __nounwind unsigned long  __STREXD( unsigned long long, volatile unsigned long long * );

__intrinsic __nounwind void __CLREX( void );

__intrinsic __nounwind void __SEV( void );
__intrinsic __nounwind void __WFE( void );
__intrinsic __nounwind void __WFI( void );
__intrinsic __nounwind void __YIELD( void );

__intrinsic __nounwind void __PLI( volatile void const * );
__intrinsic __nounwind void __PLD( volatile void const * );
__intrinsic __nounwind void __PLDW( volatile void const * );

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind   signed long __SSAT     (unsigned long val,
                                      unsigned int __constrange( 1, 32 ) sat );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __USAT     (unsigned long val,
                                      unsigned int __constrange( 0, 31 ) sat );




 
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SEL( unsigned long op1, unsigned long op2 );

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SADD8    (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SADD16   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SSUB8    (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SSUB16   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SADDSUBX (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SSUBADDX (unsigned long pair1, unsigned long pair2);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHADD8   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHADD16  (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHSUB8   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHSUB16  (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHADDSUBX(unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHSUBADDX(unsigned long pair1, unsigned long pair2);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QADD8    (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QADD16   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QSUB8    (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QSUB16   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QADDSUBX (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QSUBADDX (unsigned long pair1, unsigned long pair2);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UADD8    (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UADD16   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __USUB8    (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __USUB16   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UADDSUBX (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __USUBADDX (unsigned long pair1, unsigned long pair2);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHADD8   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHADD16  (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHSUB8   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHSUB16  (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHADDSUBX(unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHSUBADDX(unsigned long pair1, unsigned long pair2);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQADD8   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQADD16  (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQSUB8   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQSUB16  (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQADDSUBX(unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQSUBADDX(unsigned long pair1, unsigned long pair2);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __USAD8(unsigned long x, unsigned long y );
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __USADA8(unsigned long x, unsigned long y,
                                   unsigned long acc );

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SSAT16   (unsigned long pair,
                                      unsigned int __constrange( 1, 16 ) sat );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __USAT16   (unsigned long pair,
                                      unsigned int __constrange( 0, 15 ) sat );

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMUAD (unsigned long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMUSD (unsigned long x, unsigned long y);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMUADX(unsigned long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMUSDX(unsigned long x, unsigned long y);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLAD (unsigned long x, unsigned long y, long sum);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLSD (unsigned long x, unsigned long y, long sum);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLADX(unsigned long x, unsigned long y, long sum);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLSDX(unsigned long x, unsigned long y, long sum);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLALD (unsigned long pair1,
                                 unsigned long pair2,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLALDX(unsigned long pair1,
                                 unsigned long pair2,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLSLD (unsigned long pair1,
                                 unsigned long pair2,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLSLDX(unsigned long pair1,
                                 unsigned long pair2,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __PKHBT(unsigned long x,
                                  unsigned long y,
                                  unsigned __constrange(0,31) count);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __PKHTB(unsigned long x,
                                  unsigned long y,
                                  unsigned __constrange(0,32) count);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLABB(unsigned long x, unsigned long y, long acc);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLABT(unsigned long x, unsigned long y, long acc);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLATB(unsigned long x, unsigned long y, long acc);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLATT(unsigned long x, unsigned long y, long acc);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLAWB(long x, unsigned long y, long acc);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLAWT(long x, unsigned long y, long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMMLA (long x, long y, long acc);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMMLAR(long x, long y, long acc);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMMLS (long x, long y, long acc);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMMLSR(long x, long y, long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMMUL (long x, long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMMULR(long x, long y);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMULBB(unsigned long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMULBT(unsigned long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMULTB(unsigned long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMULTT(unsigned long x, unsigned long y);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMULWB(long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMULWT(long x, unsigned long y);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SXTAB (long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SXTAH (long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UXTAB (unsigned long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UXTAH (unsigned long x, unsigned long y);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long long __UMAAL(unsigned long x,
                                       unsigned long y,
                                       unsigned long a,
                                       unsigned long b);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLALBB(unsigned long x,
                                 unsigned long y,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLALBT(unsigned long x,
                                 unsigned long y,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLALTB(unsigned long x,
                                 unsigned long y,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLALTT(unsigned long x,
                                 unsigned long y,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UXTB16(unsigned long x);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UXTAB16(unsigned long acc, unsigned long x);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SXTB16(unsigned long x);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SXTAB16(unsigned long acc, unsigned long x);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SASX(unsigned long, unsigned long) ;
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SSAX(unsigned long, unsigned long) ;
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHASX(unsigned long, unsigned long) ;
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHSAX(unsigned long, unsigned long) ;
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QASX(unsigned long, unsigned long) ;
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QSAX(unsigned long, unsigned long) ;

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UASX(unsigned long, unsigned long) ;
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __USAX(unsigned long, unsigned long) ;
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHASX(unsigned long, unsigned long) ;
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHSAX(unsigned long, unsigned long) ;
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQASX(unsigned long, unsigned long) ;
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQSAX(unsigned long, unsigned long) ;


 
__intrinsic __nounwind void __DMB(void);
__intrinsic __nounwind void __DSB(void);
__intrinsic __nounwind void __ISB(void);

 
__intrinsic __nounwind unsigned long __TT(unsigned long);
__intrinsic __nounwind unsigned long __TTT(unsigned long);
__intrinsic __nounwind unsigned long __TTA(unsigned long);
__intrinsic __nounwind unsigned long __TTAT(unsigned long);




__intrinsic __nounwind unsigned long __get_LR(void);
__intrinsic __nounwind void __set_LR(unsigned long);

__intrinsic __nounwind unsigned long __get_SP(void);
__intrinsic __nounwind void __set_SP(unsigned long);

#pragma language=restore










#line 140 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\portable\\IAR\\ARM_CM4F\\portmacro.h"



 

 
extern void vPortEnterCritical( void );
extern void vPortExitCritical( void );
extern uint32_t ulPortSetInterruptMask( void );
extern void vPortClearInterruptMask( uint32_t ulNewMask );

#line 157 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\portable\\IAR\\ARM_CM4F\\portmacro.h"
 

 

	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );



 



 


 






 




 
#pragma diag_suppress=Pe191
#pragma diag_suppress=Pa082







#line 322 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\portable.h"






























#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\mpu_wrappers.h"































































 





 
#line 144 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\mpu_wrappers.h"










#line 353 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\portable.h"






 



	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) ;


 
typedef struct HeapRegion
{
	uint8_t *pucStartAddress;
	size_t xSizeInBytes;
} HeapRegion_t;











 
void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions );




 
void *pvPortMalloc( size_t xSize ) ;
void vPortFree( void *pv ) ;
void vPortInitialiseBlocks( void ) ;
size_t xPortGetFreeHeapSize( void ) ;
size_t xPortGetMinimumEverFreeHeapSize( void ) ;




 
BaseType_t xPortStartScheduler( void ) ;





 
void vPortEndScheduler( void ) ;







 











#line 101 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"





 















































































































































#line 256 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"

 


























































 

	
 




	
 




	
 




	
 














	
 




	



 




	


 




	


 




	


 







 





























































































































































































































#line 633 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"






























































































 




#line 748 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"

	
 












#line 36 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/sys_arch.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\task.h"































































 









#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\list.h"































































 



























 
































 









 
struct xLIST_ITEM
{
	 TickType_t xItemValue;			 
	struct xLIST_ITEM *  pxNext;		 
	struct xLIST_ITEM *  pxPrevious;	 
	void * pvOwner;										 
	void *  pvContainer;				 
};
typedef struct xLIST_ITEM ListItem_t;					 

struct xMINI_LIST_ITEM
{
	 TickType_t xItemValue;
	struct xLIST_ITEM *  pxNext;
	struct xLIST_ITEM *  pxPrevious;
};
typedef struct xMINI_LIST_ITEM MiniListItem_t;



 
typedef struct xLIST
{
	 UBaseType_t uxNumberOfItems;
	ListItem_t *  pxIndex;		 
	MiniListItem_t xListEnd;						 
} List_t;







 








 








 









 








 







 







 







 








 




 





















 
#line 280 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\list.h"

















 










 







 






 











 
void vListInitialise( List_t * const pxList );









 
void vListInitialiseItem( ListItem_t * const pxItem );











 
void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem );



















 
void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem );













 
UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove );







#line 75 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\task.h"







 















 
typedef void * TaskHandle_t;




 
typedef BaseType_t (*TaskHookFunction_t)( void * );

 
typedef enum
{
	eRunning = 0,	 
	eReady,			 
	eBlocked,		 
	eSuspended,		 
	eDeleted		 
} eTaskState;



 
typedef struct xTIME_OUT
{
	BaseType_t xOverflowCount;
	TickType_t  xTimeOnEntering;
} TimeOut_t;



 
typedef struct xMEMORY_REGION
{
	void *pvBaseAddress;
	uint32_t ulLengthInBytes;
	uint32_t ulParameters;
} MemoryRegion_t;



 
typedef struct xTASK_PARAMETERS
{
	TaskFunction_t pvTaskCode;
	const char * const pcName;	 
	uint16_t usStackDepth;
	void *pvParameters;
	UBaseType_t uxPriority;
	StackType_t *puxStackBuffer;
	MemoryRegion_t xRegions[ 1 ];
} TaskParameters_t;


 
typedef struct xTASK_STATUS
{
	TaskHandle_t xHandle;			 
	const char *pcTaskName;			   
	UBaseType_t xTaskNumber;		 
	eTaskState eCurrentState;		 
	UBaseType_t uxCurrentPriority;	 
	UBaseType_t uxBasePriority;		 
	uint32_t ulRunTimeCounter;		 



	uint16_t usStackHighWaterMark;	 
} TaskStatus_t;

 
typedef enum
{
	eAbortSleep = 0,		 
	eStandardSleep,			 
	eNoTasksWaitingTimeout	 
} eSleepModeStatus;






 









 













 













 









 









 




 







 
















































































 




































































 















































 
void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) ;







































 
void vTaskDelete( TaskHandle_t xTaskToDelete ) ;



 














































 
void vTaskDelay( const TickType_t xTicksToDelay ) ;

























































 
void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) ;













































 
UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) ;
















 
eTaskState eTaskGetState( TaskHandle_t xTask ) ;








































 
void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) ;

















































 
void vTaskSuspend( TaskHandle_t xTaskToSuspend ) ;















































 
void vTaskResume( TaskHandle_t xTaskToResume ) ;



























 
BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) ;



 



























 
void vTaskStartScheduler( void ) ;






















































 
void vTaskEndScheduler( void ) ;

















































 
void vTaskSuspendAll( void ) ;




















































 
BaseType_t xTaskResumeAll( void ) ;



 









 
TickType_t xTaskGetTickCount( void ) ;














 
TickType_t xTaskGetTickCountFromISR( void ) ;












 
UBaseType_t uxTaskGetNumberOfTasks( void ) ;












 
char *pcTaskGetTaskName( TaskHandle_t xTaskToQuery ) ;  



















 
UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) ;






 
#line 1141 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\task.h"











 
BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) ;







 
TaskHandle_t xTaskGetIdleTaskHandle( void );

































































































 
UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime );













































 
void vTaskList( char * pcWriteBuffer ) ;  




















































 
void vTaskGetRunTimeStats( char *pcWriteBuffer ) ;  



 















 
BaseType_t xTaskIncrementTick( void ) ;































 
void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) ;
void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) ;











 
void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait ) ;
























 
BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) ;
BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) ;








 
void vTaskSwitchContext( void ) ;




 
TickType_t uxTaskResetEventItemValue( void ) ;



 
TaskHandle_t xTaskGetCurrentTaskHandle( void ) ;



 
void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) ;




 
BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) ;




 
void vTaskMissedYield( void ) ;




 
BaseType_t xTaskGetSchedulerState( void ) ;




 
void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) ;




 
BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) ;




 
BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) ;  



 
UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) ;




 
void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) ;








 
void vTaskStepTick( const TickType_t xTicksToJump ) ;














 
eSleepModeStatus eTaskConfirmSleepModeStatus( void ) ;




 
void *pvTaskIncrementMutexHeldCount( void );








#line 37 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/sys_arch.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\queue.h"































































 


















 
typedef void * QueueHandle_t;





 
typedef void * QueueSetHandle_t;





 
typedef void * QueueSetMemberHandle_t;

 




 
#line 112 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\queue.h"
























































 

















































































 

















































































 



















































































 


















































































 























































































 
BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition ) ;






























































































 
































 
BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void * const pvBuffer ) ;



























































































 


































































































 
BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeek ) ;













 
UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue ) ;















 
UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue ) ;












 
void vQueueDelete( QueueHandle_t xQueue ) ;




































































 






































































 






















































































 









































































 













































































 
BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition ) ;























































































 
BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken ) ;




 
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue ) ;
BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue ) ;
UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue ) ;















 
BaseType_t xQueueAltGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, BaseType_t xCopyPosition );
BaseType_t xQueueAltGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, BaseType_t xJustPeeking );













 
BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken );
BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxTaskWoken );
BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait );
BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait );





 
QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType ) ;
QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount ) ;
void* xQueueGetMutexHolder( QueueHandle_t xSemaphore ) ;




 
BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait ) ;
BaseType_t xQueueGiveMutexRecursive( QueueHandle_t pxMutex ) ;






 























 













 







 
QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType ) ;
















































 
QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength ) ;






















 
BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) ;

















 
BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) ;


































 
QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait ) ;



 
QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet ) ;

 
void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait ) ;
BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue ) ;
void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber ) ;
UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue ) ;
uint8_t ucQueueGetQueueType( QueueHandle_t xQueue ) ;








#line 38 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/sys_arch.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\semphr.h"































































 










typedef QueueHandle_t SemaphoreHandle_t;


















































 
#line 135 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\semphr.h"













































 


































































 




























































































 














 






























































 



















































































 













 


























































































 

































 














































 






















































 






























































 













 














 





#line 39 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/sys_arch.h"





typedef SemaphoreHandle_t sys_sem_t;
typedef SemaphoreHandle_t sys_mutex_t;
typedef QueueHandle_t sys_mbox_t;
typedef TaskHandle_t sys_thread_t;

typedef struct _sys_arch_state_t
{
	
	char cTaskName[( 10 )];
	unsigned short nStackDepth;
	unsigned short nTaskCount;
} sys_arch_state_t;








 



#line 87 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sys.h"

 
typedef void (*lwip_thread_fn)(void *arg);


 

 


 

 
#line 107 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sys.h"

#line 132 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sys.h"

 




 
err_t sys_sem_new(sys_sem_t *sem, u8_t count);

 
void sys_sem_signal(sys_sem_t *sem);




 
u32_t sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout);

 
void sys_sem_free(sys_sem_t *sem);
 


 
int sys_sem_valid(sys_sem_t *sem);


 
void sys_sem_set_invalid(sys_sem_t *sem);


 

void sys_msleep(u32_t ms);  


 




 
err_t sys_mbox_new(sys_mbox_t *mbox, int size);



 
void sys_mbox_post(sys_mbox_t *mbox, void *msg);


 
err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg);






 
u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout);
 






 
u32_t sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg);

 


 
void sys_mbox_free(sys_mbox_t *mbox);


 
int sys_mbox_valid(sys_mbox_t *mbox);


 
void sys_mbox_set_invalid(sys_mbox_t *mbox);








 
sys_thread_t sys_thread_new(const char *name, lwip_thread_fn thread, void *arg, int stacksize, int prio);
sys_thread_t sys_thread_new_tcm(const char *name, lwip_thread_fn thread , void *arg, int stacksize, int prio);



 
void sys_init(void);


 
u32_t sys_jiffies(void);



 
u32_t sys_now(void);

 



 





 






 









 








 

sys_prot_t sys_arch_protect(void);
void sys_arch_unprotect(sys_prot_t pval);

#line 289 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sys.h"






 

#line 305 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sys.h"

#line 314 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sys.h"

#line 323 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sys.h"

#line 332 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sys.h"






#line 80 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\core\\dhcp.c"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/dhcp.h"

 















 

 

 






struct dhcp
{
    
  u32_t xid;
    
  struct udp_pcb *pcb;
   
  struct dhcp_msg *msg_in;
   
  u8_t state;
   
  u8_t tries;



  u8_t subnet_mask_given;

  struct pbuf *p_out;  
  struct dhcp_msg *msg_out;  
  u16_t options_out_len;  
  u16_t request_timeout;  
  u16_t t1_timeout;   
  u16_t t2_timeout;   
  u16_t t1_renew_time;   
  u16_t t2_rebind_time;  
  u16_t lease_used;  
  u16_t t0_timeout;  
  ip_addr_t server_ip_addr;  
  ip_addr_t offered_ip_addr;
  ip_addr_t offered_sn_mask;
  ip_addr_t offered_gw_addr;
  ip_addr_t offered_bc_addr;
  
  u32_t offered_t0_lease;  
  u32_t offered_t1_renew;  
  u32_t offered_t2_rebind;  
  
 




  u32_t seconds_elapsed;
};

 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/bpstruct.h"






























 


#pragma pack(1)


#line 77 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/dhcp.h"


 
struct dhcp_msg
{
  u8_t op;
  u8_t htype;
  u8_t hlen;
  u8_t hops;
  u32_t xid;
  u16_t secs;
  u16_t flags;
  ip_addr_p_t ciaddr;
  ip_addr_p_t yiaddr;
  ip_addr_p_t siaddr;
  ip_addr_p_t giaddr;
  u8_t chaddr[16U];
  u8_t sname[64U];
  u8_t file[128U];
  u32_t cookie;

 



 

 


  u8_t options[68U];
} ;

#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/epstruct.h"






























 


#pragma pack()




#line 112 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/dhcp.h"


void dhcp_set_struct(struct netif *netif, struct dhcp *dhcp);
 

void dhcp_cleanup(struct netif *netif);
 
err_t dhcp_start(struct netif *netif);
 
err_t dhcp_renew(struct netif *netif);
 
err_t dhcp_release(struct netif *netif);
 
void dhcp_stop(struct netif *netif);
 
void dhcp_inform(struct netif *netif);
 
void dhcp_network_changed(struct netif *netif);

 

void dhcp_arp_reply(struct netif *netif, ip_addr_t *addr);


 
void dhcp_coarse_tmr(void);
 
void dhcp_fine_tmr(void);
 
 
#line 157 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/dhcp.h"







 
#line 178 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/dhcp.h"

 


 



 
#line 195 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/dhcp.h"

 




 

 
#line 214 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/dhcp.h"

 













#line 235 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/dhcp.h"

 











#line 81 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\core\\dhcp.c"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/autoip.h"




 




































 
 







#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\netif/etharp.h"
































 





















#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/bpstruct.h"






























 


#pragma pack(1)


#line 57 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\netif/etharp.h"


struct eth_addr {
  u8_t addr[6];
} ;

#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/epstruct.h"






























 


#pragma pack()




#line 65 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\netif/etharp.h"


#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/bpstruct.h"






























 


#pragma pack(1)


#line 69 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\netif/etharp.h"


 
struct eth_hdr {



  struct eth_addr dest;
  struct eth_addr src;
  u16_t type;
} ;

#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/epstruct.h"






























 


#pragma pack()




#line 83 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\netif/etharp.h"




#line 109 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\netif/etharp.h"

#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/bpstruct.h"






























 


#pragma pack(1)


#line 112 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\netif/etharp.h"


 
struct etharp_hdr {
  u16_t hwtype;
  u16_t proto;
  u8_t hwlen;
  u8_t protolen;
  u16_t opcode;
  struct eth_addr shwaddr;
  struct ip_addr2 sipaddr;
  struct eth_addr dhwaddr;
  struct ip_addr2 dipaddr;
} ;

#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/epstruct.h"






























 


#pragma pack()




#line 129 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\netif/etharp.h"





 











void rarp_retrieve_hook_callback(void (*callback)(u8_t *, u8_t *));



 





 






 








 




#line 186 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\netif/etharp.h"


void etharp_tmr(void);
s8_t etharp_find_addr(struct netif *netif, ip_addr_t *ipaddr,
         struct eth_addr **eth_ret, ip_addr_t **ip_ret);
err_t etharp_output(struct netif *netif, struct pbuf *q, ip_addr_t *ipaddr);
err_t etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q);
err_t etharp_request(struct netif *netif, ip_addr_t *ipaddr);



 

void etharp_cleanup_netif(struct netif *netif);







err_t etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
                 const struct eth_addr *ethdst_addr,
                 const struct eth_addr *hwsrc_addr, const ip_addr_t *ipsrc_addr,
                 const struct eth_addr *hwdst_addr, const ip_addr_t *ipdst_addr,
                 const u16_t opcode);




err_t ethernet_input(struct pbuf *p, struct netif *netif);



extern const struct eth_addr ethbroadcast, ethzero;







#line 54 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/autoip.h"





 



 
#line 74 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/autoip.h"

 





struct autoip
{
  ip_addr_t llipaddr;        
  u8_t state;                
  u8_t sent_num;             
  u16_t ttw;                 
  u8_t lastconflict;         
  u8_t tried_llipaddr;       
};




 
void autoip_set_struct(struct netif *netif, struct autoip *autoip);

 
err_t autoip_start(struct netif *netif);

 
err_t autoip_stop(struct netif *netif);

 
void autoip_arp_reply(struct netif *netif, struct etharp_hdr *hdr);

 
void autoip_tmr(void);

 
void autoip_network_changed(struct netif *netif);







#line 82 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\core\\dhcp.c"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/dns.h"































 












 


 
#line 65 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/dns.h"

 










 


#line 96 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/dns.h"







 
typedef void (*dns_found_callback)(const char *name, ip_addr_t *ipaddr, void *callback_arg);

void           dns_init(void);
void           dns_tmr(void);
void           dns_setserver(u8_t numdns, ip_addr_t *dnsserver);
ip_addr_t      dns_getserver(u8_t numdns);
err_t          dns_gethostbyname(const char *hostname, ip_addr_t *addr,
                                 dns_found_callback found, void *callback_arg);
void           dns_reset_ttl();












#line 83 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\core\\dhcp.c"


#line 1 "F:\\IAR\\arm\\inc\\c\\string.h"
 
 
#line 456 "F:\\IAR\\arm\\inc\\c\\string.h"

#line 479 "F:\\IAR\\arm\\inc\\c\\string.h"




 
#line 86 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\core\\dhcp.c"



 








 





 


 








 
#line 127 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\core\\dhcp.c"


 
u32_t dhcp_rx_options_val[(8 + 2)];


 
u8_t  dhcp_rx_options_given[(8 + 2)];






#line 147 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\core\\dhcp.c"


 
static err_t dhcp_discover(struct netif *netif);
static err_t dhcp_select(struct netif *netif);
static void dhcp_bind(struct netif *netif);

static err_t dhcp_decline(struct netif *netif);

static err_t dhcp_rebind(struct netif *netif);
static err_t dhcp_reboot(struct netif *netif);
static void dhcp_set_state(struct dhcp *dhcp, u8_t new_state);

 
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *addr, u16_t port);

 
static void dhcp_timeout(struct netif *netif);
static void dhcp_t1_timeout(struct netif *netif);
static void dhcp_t2_timeout(struct netif *netif);

 
 
static err_t dhcp_create_msg(struct netif *netif, struct dhcp *dhcp, u8_t message_type);
 
static void dhcp_delete_msg(struct dhcp *dhcp);
 
static void dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len);
 
static void dhcp_option_byte(struct dhcp *dhcp, u8_t value);
static void dhcp_option_short(struct dhcp *dhcp, u16_t value);
static void dhcp_option_long(struct dhcp *dhcp, u32_t value);



 
static void dhcp_option_trailer(struct dhcp *dhcp);












 
static void
dhcp_handle_nak(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_handle_nak(netif=%p) %c%c%" "d" "\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);

   
  netif_set_down(netif);
   
  netif_set_ipaddr(netif, ((ip_addr_t *)&ip_addr_any));
  netif_set_gw(netif, ((ip_addr_t *)&ip_addr_any));
  netif_set_netmask(netif, ((ip_addr_t *)&ip_addr_any)); 
   
  dhcp_set_state(dhcp, 12);
   
  dhcp_discover(netif);
}










 
static void
dhcp_check(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result;
  u16_t msecs;
  do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0], (s16_t)netif->name[1]); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);

  dhcp_set_state(dhcp, 8);
  
 
  result = etharp_query(netif, &dhcp->offered_ip_addr, 0);
  if (result != 0) {
    do { if ( ((0x00U | 0x40U | 0x01) & 0x80U) && ((0x00U | 0x40U | 0x01) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x01) & 0x03) >= 0x00)) { rtl_printf ("dhcp_check: could not perform ARP query\n"); if ((0x00U | 0x40U | 0x01) & 0x08U) { while(1); } } } while(0);
  }
  dhcp->tries++;
  msecs = 500;
  dhcp->request_timeout = (msecs + 500 - 1) / 500;
  do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_check(): set request timeout %" "d" " msecs\n", msecs); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
}






 
static void
dhcp_handle_offer(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_handle_offer(netif=%p) %c%c%" "d" "\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);

   
  if ((dhcp_rx_options_given[2] != 0)) {
    ((&dhcp->server_ip_addr)->addr = (lwip_htonl((dhcp_rx_options_val[2]))));
    do { if ( ((0x00U | 0x20U) & 0x80U) && ((0x00U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_handle_offer(): server 0x%08" "x" "\n", ((&dhcp->server_ip_addr)->addr)); if ((0x00U | 0x20U) & 0x08U) { while(1); } } } while(0);

     
    ((dhcp->offered_ip_addr). addr = (dhcp->msg_in->yiaddr). addr);
    do { if ( ((0x00U | 0x20U) & 0x80U) && ((0x00U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_handle_offer(): offer for 0x%08" "x" "\n", ((&dhcp->offered_ip_addr)->addr)); if ((0x00U | 0x20U) & 0x08U) { while(1); } } } while(0);


    dhcp_select(netif);
  } else {
    do { if ( ((0x00U | 0x40U | 0x02) & 0x80U) && ((0x00U | 0x40U | 0x02) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x02) & 0x03) >= 0x00)) { rtl_printf ("dhcp_handle_offer(netif=%p) did not get server ID!\n", (void*)netif); if ((0x00U | 0x40U | 0x02) & 0x08U) { while(1); } } } while(0);

  }
}








 
static err_t
dhcp_select(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result;
  u16_t msecs;

  do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_select(netif=%p) %c%c%" "d" "\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
  dhcp_set_state(dhcp, 1);

   
  result = dhcp_create_msg(netif, dhcp, 3);
  if (result == 0) {
    dhcp_option(dhcp, 57, 2);
    dhcp_option_short(dhcp, (netif->mtu));

     
    dhcp_option(dhcp, 50, 4);
    dhcp_option_long(dhcp, lwip_ntohl(((&dhcp->offered_ip_addr)->addr)));

    dhcp_option(dhcp, 54, 4);
    dhcp_option_long(dhcp, lwip_ntohl(((&dhcp->server_ip_addr)->addr)));

    dhcp_option(dhcp, 55, 4 );
    dhcp_option_byte(dhcp, 1);
    dhcp_option_byte(dhcp, 3);
    dhcp_option_byte(dhcp, 28);
    dhcp_option_byte(dhcp, 6);





    dhcp_option_trailer(dhcp);
     
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - 68U + dhcp->options_out_len);

     
    udp_sendto_if(dhcp->pcb, dhcp->p_out, ((ip_addr_t *)&ip_addr_broadcast), 67, netif);
    dhcp_delete_msg(dhcp);
    do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_select: REQUESTING\n"); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
  } else {
    do { if ( ((0x00U | 0x40U | 0x01) & 0x80U) && ((0x00U | 0x40U | 0x01) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x01) & 0x03) >= 0x00)) { rtl_printf ("dhcp_select: could not allocate DHCP request\n"); if ((0x00U | 0x40U | 0x01) & 0x08U) { while(1); } } } while(0);
  }
  dhcp->tries++;
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
  dhcp->request_timeout = (msecs + 500 - 1) / 500;
  do { if ( ((0x00U | 0x20U) & 0x80U) && ((0x00U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_select(): set request timeout %" "d" " msecs\n", msecs); if ((0x00U | 0x20U) & 0x08U) { while(1); } } } while(0);
  return result;
}



 
void
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_coarse_tmr()\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
   
  while (netif != 0) {
     
    if (netif->dhcp != 0) {
       	
       	
      if(netif->dhcp->state == 0){
        netif = netif->next;
        continue;
      }
       	
       
      if (++netif->dhcp->lease_used == netif->dhcp->t0_timeout) {
        do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_coarse_tmr(): t0 timeout\n"); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
         
        igmp_report_groups_leave(netif);	
        dhcp_release(netif);
        netif->dhcp->seconds_elapsed = sys_now();        
        dhcp_discover(netif);
      }else if (netif->dhcp->t2_rebind_time-- == 1) {
        do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_coarse_tmr(): t2 timeout\n"); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
         
        dhcp_t2_timeout(netif);
       
      } else if (netif->dhcp->t1_renew_time-- == 1) {
        do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_coarse_tmr(): t1 timeout\n"); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
         
        dhcp_t1_timeout(netif);
      }
    }
     
    netif = netif->next;
  }
}






 
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
   
  while (netif != 0) {
     
    if (netif->dhcp != 0) {
             
      if (netif->dhcp->request_timeout > 1) {
        netif->dhcp->request_timeout--;
      }
      else if (netif->dhcp->request_timeout == 1) {
        netif->dhcp->request_timeout--;
         
        do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_fine_tmr(): request timeout\n"); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
         
        dhcp_timeout(netif);
      }
    }
     
    netif = netif->next;
  }
}








 
static void
dhcp_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_timeout()\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
   
  if ((dhcp->state == 12) || (dhcp->state == 6)) {
    do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_timeout(): restarting discovery\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
    dhcp_discover(netif);
   
  } else if (dhcp->state == 1) {
    do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
    if (dhcp->tries <= 5) {
      dhcp_select(netif);
    } else {
      do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_timeout(): REQUESTING, releasing, restarting\n"); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
      dhcp_release(netif);
      dhcp_discover(netif);
    }

   
  } else if (dhcp->state == 8) {
    do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_timeout(): CHECKING, ARP request timed out\n"); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
    if (dhcp->tries <= 1) {
      dhcp_check(netif);
    
 
    } else {
       
      dhcp_bind(netif);
    }

  }
   
  else if (dhcp->state == 5) {
    do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_timeout(): RENEWING, DHCP request timed out\n"); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
     
     
    dhcp_renew(netif);
   
  } else if (dhcp->state == 4) {
    do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_timeout(): REBINDING, DHCP request timed out\n"); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
    if (dhcp->tries <= 8) {
      dhcp_rebind(netif);
    } else {
      do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_timeout(): RELEASING, DISCOVERING\n"); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
      dhcp_release(netif);
      dhcp_discover(netif);
    }
  } else if (dhcp->state == 3) {
    if (dhcp->tries < 2) {
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
    }
  }
}





 
static void
dhcp_t1_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  do { if ( ((0x00U | 0x20U) & 0x80U) && ((0x00U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_t1_timeout()\n"); if ((0x00U | 0x20U) & 0x08U) { while(1); } } } while(0);
  if ((dhcp->state == 1) || (dhcp->state == 10) ||
      (dhcp->state == 5)) {
    
 
    do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_t1_timeout(): must renew\n"); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);

    
 
    dhcp->seconds_elapsed = sys_now();       
    dhcp_renew(netif);
  }
}





 
static void
dhcp_t2_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_t2_timeout()\n"); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
  if ((dhcp->state == 1) || (dhcp->state == 10) ||
      (dhcp->state == 5) || (dhcp->state == 4)) {
     
    do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_t2_timeout(): must rebind\n"); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);

    
 
    dhcp_rebind(netif);
     
    if (((netif->dhcp->t0_timeout - dhcp->lease_used) / 2) >= ((60 + 60 / 2) / 60))
    {
       netif->dhcp->t2_rebind_time = ((netif->dhcp->t0_timeout - dhcp->lease_used) / 2);
    }
  }
}





 
static void
dhcp_handle_ack(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;

  u8_t n;


   
  ((&dhcp->offered_sn_mask)->addr = 0);
  ((&dhcp->offered_gw_addr)->addr = 0);




   
  if ((dhcp_rx_options_given[3] != 0)) {
     
    dhcp->offered_t0_lease = (dhcp_rx_options_val[3]);
  }
   
  if ((dhcp_rx_options_given[4] != 0)) {
     
    dhcp->offered_t1_renew = (dhcp_rx_options_val[4]);
  } else {
     
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  }

   
  if ((dhcp_rx_options_given[5] != 0)) {
     
    dhcp->offered_t2_rebind = (dhcp_rx_options_val[5]);
  } else {
     
    dhcp->offered_t2_rebind = (u32_t)(dhcp->offered_t0_lease * 0.875);
  }

   
  ((dhcp->offered_ip_addr). addr = (dhcp->msg_in->yiaddr). addr);







   
  if ((dhcp_rx_options_given[6] != 0)) {
     
    ((&dhcp->offered_sn_mask)->addr = (lwip_htonl((dhcp_rx_options_val[6]))));
    dhcp->subnet_mask_given = 1;
  } else {
    dhcp->subnet_mask_given = 0;
  }

   
  if ((dhcp_rx_options_given[7] != 0)) {
    ((&dhcp->offered_gw_addr)->addr = (lwip_htonl((dhcp_rx_options_val[7]))));
  }
  

   
  n = 0;
  while((dhcp_rx_options_given[8 + n] != 0) && (n < 2)) {
    ip_addr_t dns_addr;
    ((&dns_addr)->addr = (lwip_htonl((dhcp_rx_options_val[8 + n]))));
    dns_setserver(n, &dns_addr);
    n++;
  }

}






 
void
dhcp_set_struct(struct netif *netif, struct dhcp *dhcp)
{
  do { if(!(netif != 0)) ; } while(0);
  do { if(!(dhcp != 0)) ; } while(0);
  do { if(!(netif->dhcp == 0)) ; } while(0);

   
  _memset(dhcp, 0, sizeof(struct dhcp));
   
  netif->dhcp = dhcp;
}







 
void dhcp_cleanup(struct netif *netif)
{
  do { if(!(netif != 0)) ; } while(0);

  if (netif->dhcp != 0) {
    mem_free(netif->dhcp);
    netif->dhcp = 0;
  }
}












 
err_t
dhcp_start(struct netif *netif)
{
  struct dhcp *dhcp;
  err_t result = 0;

  do { if (!((netif != 0))) { ; return -14;;}} while(0);
  dhcp = netif->dhcp;
  do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_start(netif=%p) %c%c%" "d" "\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
  
 
  netif->flags &= ~0x08U;

   
  if ((netif->flags & 0x20U) == 0) {
    do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_start(): No ETHARP netif\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
    return -14;
  }

   
  if (netif->mtu < 576) {
    do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_start(): Cannot use this netif with DHCP: MTU is too small\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
    return -1;
  }

   
  if (dhcp == 0) {
    do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_start(): starting new DHCP client\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
    dhcp = (struct dhcp *)mem_malloc(sizeof(struct dhcp));
    if (dhcp == 0) {
      do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_start(): could not allocate dhcp\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
      return -1;
    }
     
    netif->dhcp = dhcp;
    do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_start(): allocated dhcp"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
   
  } else {
    do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_start(): restarting DHCP configuration\n"); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
    if (dhcp->pcb != 0) {
      udp_remove(dhcp->pcb);
    }
    do { if(!(dhcp->p_out == 0)) ; } while(0);
    do { if(!(dhcp->msg_in == 0)) ; } while(0);
  }
    

   
  srand(sys_now());

    
   
  _memset(dhcp, 0, sizeof(struct dhcp));
   
   
  dhcp->pcb = udp_new();
  if (dhcp->pcb == 0) {
    do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_start(): could not obtain pcb\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
    return -1;
  }
  ((dhcp->pcb)->so_options |= (0x20U));
  ((dhcp->pcb)->so_options |= (0x04U));
   
  udp_bind(dhcp->pcb, ((ip_addr_t *)&ip_addr_any), 68);
  udp_connect(dhcp->pcb, ((ip_addr_t *)&ip_addr_any), 67);
   
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_start(): starting DHCP configuration\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
   
  dhcp->seconds_elapsed = sys_now();  
  result = dhcp_discover(netif);
  if (result != 0) {
     
    dhcp_stop(netif);
    return -1;
  }
   
  netif->flags |= 0x08U;
  return result;
}









 
void
dhcp_inform(struct netif *netif)
{
  struct dhcp dhcp;
  err_t result = 0;
  struct udp_pcb *pcb;

  do { if (!((netif != 0))) { ; return;;}} while(0);

  _memset(&dhcp, 0, sizeof(struct dhcp));
  dhcp_set_state(&dhcp, 8);

  if ((netif->dhcp != 0) && (netif->dhcp->pcb != 0)) {
     
    pcb = netif->dhcp->pcb;
  } else {
    pcb = udp_new();
    if (pcb == 0) {
      do { if ( ((0x00U | 0x40U | 0x02) & 0x80U) && ((0x00U | 0x40U | 0x02) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x02) & 0x03) >= 0x00)) { rtl_printf ("dhcp_inform(): could not obtain pcb"); if ((0x00U | 0x40U | 0x02) & 0x08U) { while(1); } } } while(0);
      return;
    }
    dhcp.pcb = pcb;
    ((dhcp . pcb)->so_options |= (0x20U));
    ((dhcp . pcb)->so_options |= (0x04U));		
    udp_bind(dhcp.pcb, ((ip_addr_t *)&ip_addr_any), 68);
    do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_inform(): created new udp pcb\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
  }
   
  result = dhcp_create_msg(netif, &dhcp, 8);
  if (result == 0) {
    dhcp_option(&dhcp, 57, 2);
    dhcp_option_short(&dhcp, (netif->mtu));

    dhcp_option_trailer(&dhcp);

    pbuf_realloc(dhcp.p_out, sizeof(struct dhcp_msg) - 68U + dhcp.options_out_len);

    do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_inform: INFORMING\n"); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
    udp_sendto_if(pcb, dhcp.p_out, ((ip_addr_t *)&ip_addr_broadcast), 67, netif);
    dhcp_delete_msg(&dhcp);
  } else {
    do { if ( ((0x00U | 0x40U | 0x02) & 0x80U) && ((0x00U | 0x40U | 0x02) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x02) & 0x03) >= 0x00)) { rtl_printf ("dhcp_inform: could not allocate DHCP request\n"); if ((0x00U | 0x40U | 0x02) & 0x08U) { while(1); } } } while(0);
  }

  if (dhcp.pcb != 0) {
     
    udp_remove(dhcp.pcb);
  }
}





 
void
dhcp_network_changed(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  if (!dhcp)
    return;
  switch (dhcp->state) {
  case 4:
  case 5:
  case 10:
  case 3:
    netif_set_down(netif);
    dhcp->tries = 0;
    dhcp_reboot(netif);
    break;
  case 0:
     
    break;
  default:
    dhcp->tries = 0;
#line 820 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\core\\dhcp.c"
    dhcp_discover(netif);
    break;
  }
}







 
void dhcp_arp_reply(struct netif *netif, ip_addr_t *addr)
{
  do { if (!((netif != 0))) { ; return;;}} while(0);
  do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_arp_reply()\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
   
  if ((netif->dhcp != 0) && (netif->dhcp->state == 8)) {
    do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08" "x" "\n", ((addr)->addr)); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);

    
 
    if (((addr)->addr == (&netif->dhcp->offered_ip_addr)->addr)) {
       
      do { if ( ((0x00U | 0x40U | 0x20U | 0x01) & 0x80U) && ((0x00U | 0x40U | 0x20U | 0x01) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U | 0x01) & 0x03) >= 0x00)) { rtl_printf ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"); if ((0x00U | 0x40U | 0x20U | 0x01) & 0x08U) { while(1); } } } while(0);

      dhcp_decline(netif);
    }
  }
}









 
static err_t
dhcp_decline(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result = 0;
  u16_t msecs;
  do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_decline()\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
  dhcp_set_state(dhcp, 12);
   
  result = dhcp_create_msg(netif, dhcp, 4);
  if (result == 0) {
    dhcp_option(dhcp, 50, 4);
    dhcp_option_long(dhcp, lwip_ntohl(((&dhcp->offered_ip_addr)->addr)));

    dhcp_option(dhcp, 54, 4);
    dhcp_option_long(dhcp, lwip_ntohl(((&dhcp->server_ip_addr)->addr)));

    dhcp_option_trailer(dhcp);
     
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - 68U + dhcp->options_out_len);

     
    udp_sendto_if(dhcp->pcb, dhcp->p_out, ((ip_addr_t *)&ip_addr_broadcast), 67, netif);
    dhcp_delete_msg(dhcp);
    do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_decline: BACKING OFF\n"); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
  } else {
    do { if ( ((0x00U | 0x40U | 0x02) & 0x80U) && ((0x00U | 0x40U | 0x02) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x02) & 0x03) >= 0x00)) { rtl_printf ("dhcp_decline: could not allocate DHCP request\n"); if ((0x00U | 0x40U | 0x02) & 0x08U) { while(1); } } } while(0);

  }
  dhcp->tries++;
  msecs = 10*1000;
  dhcp->request_timeout = (msecs + 500 - 1) / 500;
  do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_decline(): set request timeout %" "d" " msecs\n", msecs); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
  return result;
}







 
static err_t
dhcp_discover(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result = 0;
  u16_t msecs;
  do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_discover()\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
  ((&dhcp->offered_ip_addr)->addr = ((u32_t)0x00000000UL));
  dhcp_set_state(dhcp, 6);
   
  result = dhcp_create_msg(netif, dhcp, 1);
  if (result == 0) {
    do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_discover: making request\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);

    dhcp_option(dhcp, 57, 2);
    dhcp_option_short(dhcp, (netif->mtu));

    dhcp_option(dhcp, 55, 4 );
    dhcp_option_byte(dhcp, 1);
    dhcp_option_byte(dhcp, 3);
    dhcp_option_byte(dhcp, 28);
    dhcp_option_byte(dhcp, 6);

    dhcp_option_trailer(dhcp);

    do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_discover: realloc()ing\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - 68U + dhcp->options_out_len);

    do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
    udp_sendto_if(dhcp->pcb, dhcp->p_out, ((ip_addr_t *)&ip_addr_broadcast), 67, netif);
    do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_discover: deleting()ing\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
    dhcp_delete_msg(dhcp);
    do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_discover: SELECTING\n"); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
  } else {
    do { if ( ((0x00U | 0x40U | 0x02) & 0x80U) && ((0x00U | 0x40U | 0x02) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x02) & 0x03) >= 0x00)) { rtl_printf ("dhcp_discover: could not allocate DHCP request\n"); if ((0x00U | 0x40U | 0x02) & 0x08U) { while(1); } } } while(0);
  }
  dhcp->tries++;
#line 946 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\core\\dhcp.c"
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
  dhcp->request_timeout = (msecs + 500 - 1) / 500;
  do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_discover(): set request timeout %" "d" " msecs\n", msecs); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
  return result;
}






 
static void
dhcp_bind(struct netif *netif)
{
  u32_t timeout;
  struct dhcp *dhcp;
  ip_addr_t sn_mask, gw_addr;
  do { if (!((netif != 0))) { ; return;;}} while(0);
  dhcp = netif->dhcp;
  do { if (!((dhcp != 0))) { ; return;;}} while(0);
  do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_bind(netif=%p) %c%c%" "d" "\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);

	   
  dhcp->lease_used = 0;

  if( dhcp->offered_t0_lease != 0xffffffffUL) {
      
     do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_bind(): t0 renewal timer %" "d" " secs\n", dhcp->offered_t0_lease); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
     timeout = (dhcp->offered_t0_lease + 60 / 2) / 60;
     if(timeout > 0xffff) {
       timeout = 0xffff;
     }
     dhcp->t0_timeout = (u16_t)timeout;
     if (dhcp->t0_timeout == 0) {
       dhcp->t0_timeout = 1;
     }
     do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_bind(): set request timeout %" "d" " msecs\n", dhcp->offered_t0_lease*1000); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
  }
   
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
     
    do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_bind(): t1 renewal timer %" "d" " secs\n", dhcp->offered_t1_renew); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
    timeout = (dhcp->offered_t1_renew + 60 / 2) / 60;
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t1_timeout = (u16_t)timeout;
    if (dhcp->t1_timeout == 0) {
      dhcp->t1_timeout = 1;
    }
    do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_bind(): set request timeout %" "d" " msecs\n", dhcp->offered_t1_renew*1000); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
    dhcp->t1_renew_time = dhcp->t1_timeout;
  }
   
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
    do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_bind(): t2 rebind timer %" "d" " secs\n", dhcp->offered_t2_rebind); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
    timeout = (dhcp->offered_t2_rebind + 60 / 2) / 60;
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t2_timeout = (u16_t)timeout;
    if (dhcp->t2_timeout == 0) {
      dhcp->t2_timeout = 1;
    }
    do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_bind(): set request timeout %" "d" " msecs\n", dhcp->offered_t2_rebind*1000); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
    dhcp->t2_rebind_time = dhcp->t2_timeout;
  }

  if (dhcp->subnet_mask_given) {
     
    ((sn_mask). addr = (dhcp->offered_sn_mask). addr);
  } else {
     
    u8_t first_octet = (((u8_t*)(&dhcp->offered_ip_addr))[0]);
    if (first_octet <= 127) {
      ((&sn_mask)->addr = (((((0xff000000UL) & 0xff) << 24) | (((0xff000000UL) & 0xff00) << 8) | (((0xff000000UL) & 0xff0000UL) >> 8) | (((0xff000000UL) & 0xff000000UL) >> 24))));
    } else if (first_octet >= 192) {
      ((&sn_mask)->addr = (((((0xffffff00UL) & 0xff) << 24) | (((0xffffff00UL) & 0xff00) << 8) | (((0xffffff00UL) & 0xff0000UL) >> 8) | (((0xffffff00UL) & 0xff000000UL) >> 24))));
    } else {
      ((&sn_mask)->addr = (((((0xffff0000UL) & 0xff) << 24) | (((0xffff0000UL) & 0xff00) << 8) | (((0xffff0000UL) & 0xff0000UL) >> 8) | (((0xffff0000UL) & 0xff000000UL) >> 24))));
    }
  }

  ((gw_addr). addr = (dhcp->offered_gw_addr). addr);
   
  if (((&gw_addr) == 0 || (&gw_addr)->addr == ((u32_t)0x00000000UL))) {
     
    ((&gw_addr)->addr = ((&dhcp->offered_ip_addr)->addr) & ((&sn_mask)->addr));
     
    ((&gw_addr)->addr = (((&gw_addr)->addr) | ((((0x00000001UL) & 0xff) << 24) | (((0x00000001UL) & 0xff00) << 8) | (((0x00000001UL) & 0xff0000UL) >> 8) | (((0x00000001UL) & 0xff000000UL) >> 24))));
  }

#line 1045 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\core\\dhcp.c"

  do { if ( ((0x00U | 0x20U) & 0x80U) && ((0x00U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_bind(): IP: 0x%08" "x" "\n", ((&dhcp->offered_ip_addr)->addr)); if ((0x00U | 0x20U) & 0x08U) { while(1); } } } while(0);

  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  do { if ( ((0x00U | 0x20U) & 0x80U) && ((0x00U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_bind(): SN: 0x%08" "x" "\n", ((&sn_mask)->addr)); if ((0x00U | 0x20U) & 0x08U) { while(1); } } } while(0);

  netif_set_netmask(netif, &sn_mask);
  do { if ( ((0x00U | 0x20U) & 0x80U) && ((0x00U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_bind(): GW: 0x%08" "x" "\n", ((&gw_addr)->addr)); if ((0x00U | 0x20U) & 0x08U) { while(1); } } } while(0);

  netif_set_gw(netif, &gw_addr);
   
  netif_set_up(netif);
   
  dhcp_set_state(dhcp, 10);
}





 
err_t
dhcp_renew(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result;
  u16_t msecs;
  do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_renew()\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
  dhcp_set_state(dhcp, 5);

   
  result = dhcp_create_msg(netif, dhcp, 3);
  if (result == 0) {
    dhcp_option(dhcp, 57, 2);
    dhcp_option_short(dhcp, (netif->mtu));















     
    dhcp_option_trailer(dhcp);

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - 68U + dhcp->options_out_len);

    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, 67, netif);
    dhcp_delete_msg(dhcp);

    do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_renew: RENEWING\n"); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
  } else {
    do { if ( ((0x00U | 0x40U | 0x02) & 0x80U) && ((0x00U | 0x40U | 0x02) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x02) & 0x03) >= 0x00)) { rtl_printf ("dhcp_renew: could not allocate DHCP request\n"); if ((0x00U | 0x40U | 0x02) & 0x08U) { while(1); } } } while(0);
  }
  dhcp->tries++;
   
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  dhcp->request_timeout = (msecs + 500 - 1) / 500;
  do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_renew(): set request timeout %" "d" " msecs\n", msecs); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
  return result;
}





 
static err_t
dhcp_rebind(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result;
  u16_t msecs;
  do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_rebind()\n"); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
  dhcp_set_state(dhcp, 4);

   
  result = dhcp_create_msg(netif, dhcp, 3);
  if (result == 0) {
    dhcp_option(dhcp, 57, 2);
    dhcp_option_short(dhcp, (netif->mtu));





#line 1146 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\core\\dhcp.c"

    dhcp_option_trailer(dhcp);

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - 68U + dhcp->options_out_len);

     
    udp_sendto_if(dhcp->pcb, dhcp->p_out, ((ip_addr_t *)&ip_addr_broadcast), 67, netif);
    dhcp_delete_msg(dhcp);
    do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_rebind: REBINDING\n"); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
  } else {
    do { if ( ((0x00U | 0x40U | 0x02) & 0x80U) && ((0x00U | 0x40U | 0x02) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x02) & 0x03) >= 0x00)) { rtl_printf ("dhcp_rebind: could not allocate DHCP request\n"); if ((0x00U | 0x40U | 0x02) & 0x08U) { while(1); } } } while(0);
  }
  dhcp->tries++;
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  dhcp->request_timeout = (msecs + 500 - 1) / 500;
  do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_rebind(): set request timeout %" "d" " msecs\n", msecs); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
  return result;
}





 
static err_t
dhcp_reboot(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result;
  u16_t msecs;
  do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_reboot()\n"); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
  dhcp_set_state(dhcp, 3);

   
  result = dhcp_create_msg(netif, dhcp, 3);
  if (result == 0) {
    dhcp_option(dhcp, 57, 2);
    dhcp_option_short(dhcp, 576);

    dhcp_option(dhcp, 50, 4);
    dhcp_option_long(dhcp, lwip_ntohl(((&dhcp->offered_ip_addr)->addr)));

    dhcp_option_trailer(dhcp);

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - 68U + dhcp->options_out_len);

     
    udp_sendto_if(dhcp->pcb, dhcp->p_out, ((ip_addr_t *)&ip_addr_broadcast), 67, netif);
    dhcp_delete_msg(dhcp);
    do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_reboot: REBOOTING\n"); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
  } else {
    do { if ( ((0x00U | 0x40U | 0x02) & 0x80U) && ((0x00U | 0x40U | 0x02) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x02) & 0x03) >= 0x00)) { rtl_printf ("dhcp_reboot: could not allocate DHCP request\n"); if ((0x00U | 0x40U | 0x02) & 0x08U) { while(1); } } } while(0);
  }
  dhcp->tries++;
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  dhcp->request_timeout = (msecs + 500 - 1) / 500;
  do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_reboot(): set request timeout %" "d" " msecs\n", msecs); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
  return result;
}






 
u8_t
dhcp_supplied_address(const struct netif *netif)
{
  if ((netif != 0) && (netif->dhcp != 0)) {
    struct dhcp* dhcp = netif->dhcp;
    return (dhcp->state == 10) || (dhcp->state == 5);
  }
  return 0;
}





 
err_t
dhcp_release(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result;
  u16_t msecs;
  ip_addr_t server_ip_addr;
  u8_t is_dhcp_supplied_address;
  do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_release()\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
  if (dhcp == 0) {
    return -14;
  }
  ((server_ip_addr). addr = (dhcp->server_ip_addr). addr);

  is_dhcp_supplied_address = dhcp_supplied_address(netif);
   
  dhcp_set_state(dhcp, 0);
   
  ((&dhcp->server_ip_addr)->addr = 0);
  ((&dhcp->offered_ip_addr)->addr = 0);
  ((&dhcp->offered_sn_mask)->addr = 0);
  ((&dhcp->offered_gw_addr)->addr = 0);



  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  dhcp->t1_renew_time = dhcp->t2_rebind_time = dhcp->lease_used = dhcp->t0_timeout = 0;

  if (!is_dhcp_supplied_address) {
     
    return 0;
  }

   
  result = dhcp_create_msg(netif, dhcp, 7);
  if (result == 0) {
    dhcp_option(dhcp, 54, 4);
    dhcp_option_long(dhcp, lwip_ntohl(((&server_ip_addr)->addr)));

    dhcp_option_trailer(dhcp);

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - 68U + dhcp->options_out_len);

    udp_sendto_if(dhcp->pcb, dhcp->p_out, &server_ip_addr, 67, netif);
    dhcp_delete_msg(dhcp);
    do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_release: RELEASED, DHCP_OFF\n"); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
  } else {
    do { if ( ((0x00U | 0x40U | 0x02) & 0x80U) && ((0x00U | 0x40U | 0x02) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x02) & 0x03) >= 0x00)) { rtl_printf ("dhcp_release: could not allocate DHCP request\n"); if ((0x00U | 0x40U | 0x02) & 0x08U) { while(1); } } } while(0);
  }
  dhcp->tries++;
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  dhcp->request_timeout = (msecs + 500 - 1) / 500;
  do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_release(): set request timeout %" "d" " msecs\n", msecs); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
   
  netif_set_down(netif);
   
  netif_set_ipaddr(netif, ((ip_addr_t *)&ip_addr_any));
  netif_set_gw(netif, ((ip_addr_t *)&ip_addr_any));
  netif_set_netmask(netif, ((ip_addr_t *)&ip_addr_any));
  
   
  return result;
}





 
err_t
dhcp_release_unicast(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result;
  u16_t msecs;
  do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_release()\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);

   
  dhcp_set_state(dhcp, 11);
   




 
  
   
  result = dhcp_create_msg(netif,netif->dhcp,3);
  if (result == 0) {
    dhcp_option(dhcp, 53, 1);
    dhcp_option_byte(dhcp, 7);

	dhcp_option(dhcp, 54, 4);
    dhcp_option_long(dhcp, lwip_ntohl(dhcp->server_ip_addr . addr));

    dhcp_option_trailer(dhcp);

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - 68U + dhcp->options_out_len);

    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, 67, netif);
    dhcp_delete_msg(netif->dhcp);
    do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_release: RELEASED, DHCP_OFF\n"); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
  } else {
    do { if ( ((0x00U | 0x40U | 0x02) & 0x80U) && ((0x00U | 0x40U | 0x02) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x02) & 0x03) >= 0x00)) { rtl_printf ("dhcp_release: could not allocate DHCP request\n"); if ((0x00U | 0x40U | 0x02) & 0x08U) { while(1); } } } while(0);
  }
  dhcp->tries++;
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  dhcp->request_timeout = (msecs + 500 - 1) / 500;
  do { if ( ((0x00U | 0x40U | 0x20U) & 0x80U) && ((0x00U | 0x40U | 0x20U) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x20U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_release(): set request timeout %" "d" " msecs\n", msecs); if ((0x00U | 0x40U | 0x20U) & 0x08U) { while(1); } } } while(0);
   
  netif_set_down(netif);
   
  netif_set_ipaddr(netif, ((ip_addr_t *)&ip_addr_any));
  netif_set_gw(netif, ((ip_addr_t *)&ip_addr_any));
  netif_set_netmask(netif, ((ip_addr_t *)&ip_addr_any));
  
   
  return result;
}





 
void
dhcp_stop(struct netif *netif)
{
  struct dhcp *dhcp;
  do { if (!((netif != 0))) { ; return;;}} while(0);
  dhcp = netif->dhcp;
   
  netif->flags &= ~0x08U;

  do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_stop()\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
   
  if (dhcp != 0) {
#line 1370 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\core\\dhcp.c"

    if (dhcp->pcb != 0) {
      udp_remove(dhcp->pcb);
      dhcp->pcb = 0;
    }
    do { if(!(dhcp->msg_in == 0)) ; } while(0);
    dhcp_set_state(dhcp, 0);
  }
}





 
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    dhcp->state = new_state;
    dhcp->tries = 0;
    dhcp->request_timeout = 0;
  }
}





 
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  do { if(!(dhcp->options_out_len + 2U + option_len <= 68U)) ; } while(0);
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
}



 
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  do { if(!(dhcp->options_out_len < 68U)) ; } while(0);
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  do { if(!(dhcp->options_out_len + 2U <= 68U)) ; } while(0);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
}

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  do { if(!(dhcp->options_out_len + 4U <= 68U)) ; } while(0);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
}

#line 1458 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\core\\dhcp.c"










 
static err_t
dhcp_parse_reply(struct dhcp *dhcp, struct pbuf *p)
{
  u8_t *options;
  u16_t offset;
  u16_t offset_max;
  u16_t options_idx;
  u16_t options_idx_max;
  struct pbuf *q;
  int parse_file_as_options = 0;
  int parse_sname_as_options = 0;

   
  (_memset(dhcp_rx_options_given, 0, sizeof(dhcp_rx_options_given)));
   
  if (p->len < 44) {
    return -2;
  }
  dhcp->msg_in = (struct dhcp_msg *)p->payload;





   

   
  options_idx = (236 + 4);
   
  options_idx_max = p->tot_len;
again:
  q = p;
  while((q != 0) && (options_idx >= q->len)) {
    options_idx -= q->len;
    options_idx_max -= q->len;
    q = q->next;
  }
  if (q == 0) {
    return -2;
  }
  offset = options_idx;
  offset_max = options_idx_max;
  options = (u8_t*)q->payload;
   
  while((q != 0) && (options[offset] != 255) && (offset < offset_max)) {
    u8_t op = options[offset];
    u8_t len;
    u8_t decode_len = 0;
    int decode_idx = -1;
    u16_t val_offset = offset + 2;
     
    if (offset + 1 < q->len) {
      len = options[offset + 1];
    } else {
      len = (q->next != 0 ? ((u8_t*)q->next->payload)[0] : 0);
    }
     
    decode_len = len;
    switch(op) {
       
      case(0):
         
        decode_len = len = 0;
         
        offset--;
        break;
      case(1):
        do { if (!(len == 4)) { ; return -6;;}} while(0);
        decode_idx = 6;
        break;
      case(3):
        decode_len = 4;  
        do { if (!(len >= decode_len)) { ; return -6;;}} while(0);
        decode_idx = 7;
        break;
      case(6):
         
        do { if (!(len % 4 == 0)) { ; return -6;;}} while(0);
         
        decode_len = (((len) < (4 * 2)) ? (len) : (4 * 2));
        do { if (!(len >= decode_len)) { ; return -6;;}} while(0);
        decode_idx = 8;
        break;
      case(51):
        do { if (!(len == 4)) { ; return -6;;}} while(0);
        decode_idx = 3;
        break;
      case(52):
        do { if (!(len == 1)) { ; return -6;;}} while(0);
        decode_idx = 0;
        break;
      case(53):
        do { if (!(len == 1)) { ; return -6;;}} while(0);
        decode_idx = 1;
        break;
      case(54):
        do { if (!(len == 4)) { ; return -6;;}} while(0);
        decode_idx = 2;
        break;
      case(58):
        do { if (!(len == 4)) { ; return -6;;}} while(0);
        decode_idx = 4;
        break;
      case(59):
        do { if (!(len == 4)) { ; return -6;;}} while(0);
        decode_idx = 5;
        break;
      default:
        decode_len = 0;
        do { if ( ((0x00U) & 0x80U) && ((0x00U) & 0x80U) && ((s16_t)((0x00U) & 0x03) >= 0x00)) { rtl_printf ("skipping option %" "d" " in options\n", op); if ((0x00U) & 0x08U) { while(1); } } } while(0);
        break;
    }
    offset += len + 2;
    if (decode_len > 0) {
      u32_t value = 0;
      u16_t copy_len;
decode_next:
      do { if(!(decode_idx >= 0 && decode_idx < (8 + 2))) ; } while(0);
      if (!(dhcp_rx_options_given[decode_idx] != 0)) {
        copy_len = (((decode_len) < (4)) ? (decode_len) : (4));
        pbuf_copy_partial(q, &value, copy_len, val_offset);
        if (decode_len > 4) {
           
          do { if (!(decode_len % 4 == 0)) { ; return -6;;}} while(0);
          (dhcp_rx_options_given[decode_idx] = 1);
          (dhcp_rx_options_val[decode_idx] = (lwip_htonl(value)));
          decode_len -= 4;
          val_offset += 4;
          decode_idx++;
          goto decode_next;
        } else if (decode_len == 4) {
          value = lwip_ntohl(value);
        } else {
          do { if (!(decode_len == 1)) { ; return -6;;}} while(0);
          value = ((u8_t*)&value)[0];
        }
        (dhcp_rx_options_given[decode_idx] = 1);
        (dhcp_rx_options_val[decode_idx] = (value));
      }
    }
    if (offset >= q->len) {
      offset -= q->len;
      offset_max -= q->len;
      if ((offset < offset_max) && offset_max) {
        q = q->next;
        do { if(!(q)) ; } while(0);
        options = (u8_t*)q->payload;
      } else {
        
        break;
      }
    }
  }
   
  if ((dhcp_rx_options_given[0] != 0)) {
    u32_t overload = (dhcp_rx_options_val[0]);
    (dhcp_rx_options_given[0] = 0);
    if (overload == 1) {
      parse_file_as_options = 1;
      do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("overloaded file field\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
    } else if (overload == 2) {
      parse_sname_as_options = 1;
      do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("overloaded sname field\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
    } else if (overload == 3) {
      parse_sname_as_options = 1;
      parse_file_as_options = 1;
      do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("overloaded sname and file field\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
    } else {
      do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("invalid overload option: %d\n", (int)overload); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
    }
#line 1650 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\core\\dhcp.c"
  }
  if (parse_file_as_options) {
     
    parse_file_as_options = 0;
    options_idx = 108;
    options_idx_max = 108 + 128U;
    goto again;
  } else if (parse_sname_as_options) {
    parse_sname_as_options = 0;
    options_idx = 44;
    options_idx_max = 44 + 64U;
    goto again;
  }
  return 0;
}



 
static void
dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *addr, u16_t port)
{
  struct netif *netif = (struct netif *)arg;
  struct dhcp *dhcp = netif->dhcp;
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  u8_t msg_type;
  u8_t i;
  do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("dhcp_recv(pbuf = %p) from DHCP server %" "d" ".%" "d" ".%" "d" ".%" "d" " port %" "d" "\n", (void*)p, ((u16_t)(((u8_t*)(addr))[0])), ((u16_t)(((u8_t*)(addr))[1])), ((u16_t)(((u8_t*)(addr))[2])), ((u16_t)(((u8_t*)(addr))[3])), port); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);

  do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("pbuf->len = %" "d" "\n", p->len); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
  do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("pbuf->tot_len = %" "d" "\n", p->tot_len); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
   
  (void)pcb;
  (void)addr;
  (void)port;

  do { if(!(dhcp->msg_in == 0)) ; } while(0);

  if (p->len < 44) {
    do { if ( ((0x00U | 0x40U | 0x01) & 0x80U) && ((0x00U | 0x40U | 0x01) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x01) & 0x03) >= 0x00)) { rtl_printf ("DHCP reply message or pbuf too short\n"); if ((0x00U | 0x40U | 0x01) & 0x08U) { while(1); } } } while(0);
    goto free_pbuf_and_return;
  }

  if (reply_msg->op != 2) {
    do { if ( ((0x00U | 0x40U | 0x01) & 0x80U) && ((0x00U | 0x40U | 0x01) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x01) & 0x03) >= 0x00)) { rtl_printf ("not a DHCP reply message, but type %" "d" "\n", (u16_t)reply_msg->op); if ((0x00U | 0x40U | 0x01) & 0x08U) { while(1); } } } while(0);
    goto free_pbuf_and_return;
  }
   
  for (i = 0; i < netif->hwaddr_len; i++) {
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
      do { if ( ((0x00U | 0x40U | 0x01) & 0x80U) && ((0x00U | 0x40U | 0x01) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x01) & 0x03) >= 0x00)) { rtl_printf ("netif->hwaddr[%" "d" "]==%02" "x" " != reply_msg->chaddr[%" "d" "]==%02" "x" "\n", (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]); if ((0x00U | 0x40U | 0x01) & 0x08U) { while(1); } } } while(0);


      goto free_pbuf_and_return;
    }
  }
   
  if (lwip_ntohl(reply_msg->xid) != dhcp->xid) {
    do { if ( ((0x00U | 0x40U | 0x01) & 0x80U) && ((0x00U | 0x40U | 0x01) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x01) & 0x03) >= 0x00)) { rtl_printf ("transaction id mismatch reply_msg->xid(%" "x" ")!=dhcp->xid(%" "x" ")\n",lwip_ntohl(reply_msg->xid),dhcp->xid); if ((0x00U | 0x40U | 0x01) & 0x08U) { while(1); } } } while(0);

    goto free_pbuf_and_return;
  }
   
  if (dhcp_parse_reply(dhcp, p) != 0) {
    do { if ( ((0x00U | 0x40U | 0x02) & 0x80U) && ((0x00U | 0x40U | 0x02) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x02) & 0x03) >= 0x00)) { rtl_printf ("problem unfolding DHCP message - too short on memory?\n"); if ((0x00U | 0x40U | 0x02) & 0x08U) { while(1); } } } while(0);

    goto free_pbuf_and_return;
  }

  do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("searching DHCP_OPTION_MESSAGE_TYPE\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
   
  if (!(dhcp_rx_options_given[1] != 0)) {
    do { if ( ((0x00U | 0x40U | 0x01) & 0x80U) && ((0x00U | 0x40U | 0x01) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x01) & 0x03) >= 0x00)) { rtl_printf ("DHCP_OPTION_MESSAGE_TYPE option not found\n"); if ((0x00U | 0x40U | 0x01) & 0x08U) { while(1); } } } while(0);
    goto free_pbuf_and_return;
  }

   
  msg_type = (u8_t)(dhcp_rx_options_val[1]);
   
  if (msg_type == 5) {
    do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("DHCP_ACK received\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
     
    if (dhcp->state == 1) {
      dhcp_handle_ack(netif);

       
      dhcp_check(netif);




    }
     
    else if ((dhcp->state == 3) || (dhcp->state == 4) || (dhcp->state == 5)) {
      dhcp_bind(netif);
    }
  }
   
  else if ((msg_type == 6) &&
    ((dhcp->state == 3) || (dhcp->state == 1) ||
     (dhcp->state == 4) || (dhcp->state == 5  ))) {
    do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("DHCP_NAK received\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
    dhcp_handle_nak(netif);
  }
   
  else if ((msg_type == 2) && (dhcp->state == 6)) {
    do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("DHCP_OFFER received in DHCP_SELECTING state\n"); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);
    dhcp->request_timeout = 0;
     
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  dhcp->msg_in = 0;
  pbuf_free(p);
}







 
static err_t
dhcp_create_msg(struct netif *netif, struct dhcp *dhcp, u8_t message_type)
{
  u16_t i;

  


 

  static u32_t xid;
#line 1793 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\core\\dhcp.c"
  do { if (!((netif != 0))) { ; return -14;;}} while(0);
  do { if (!((dhcp != 0))) { ; return -6;;}} while(0);
  do { if(!(dhcp->p_out == 0)) ; } while(0);
  do { if(!(dhcp->msg_out == 0)) ; } while(0);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  if (dhcp->p_out == 0) {
    do { if ( ((0x00U | 0x40U | 0x02) & 0x80U) && ((0x00U | 0x40U | 0x02) & 0x80U) && ((s16_t)((0x00U | 0x40U | 0x02) & 0x03) >= 0x00)) { rtl_printf ("dhcp_create_msg(): could not allocate pbuf\n"); if ((0x00U | 0x40U | 0x02) & 0x08U) { while(1); } } } while(0);

    return -1;
  }
  do { if(!((dhcp->p_out->len >= sizeof(struct dhcp_msg)))) ; } while(0);


   
  if (message_type != 3) {
     
    if (dhcp->tries == 0) {

      xid = rand();



    }
    dhcp->xid = xid;
  }
  do { if ( ((0x00U | 0x40U) & 0x80U) && ((0x00U | 0x40U) & 0x80U) && ((s16_t)((0x00U | 0x40U) & 0x03) >= 0x00)) { rtl_printf ("transaction id xid(%" "x" ")\n", xid); if ((0x00U | 0x40U) & 0x08U) { while(1); } } } while(0);


  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;

  dhcp->msg_out->op = 1;
   
  dhcp->msg_out->htype = 1;
  dhcp->msg_out->hlen = netif->hwaddr_len;
  dhcp->msg_out->hops = 0;
  dhcp->msg_out->xid = lwip_htonl(dhcp->xid);
  if ((message_type == 1) || (message_type == 3)) {
    dhcp->msg_out->secs = (uint16_t)((sys_now() - dhcp->seconds_elapsed) / ( ( uint32_t ) 1000 ));
  } else {
    dhcp->msg_out->secs = 0;
  }
  
 
  dhcp->msg_out->flags = 0;
  ((&dhcp->msg_out->ciaddr)->addr = 0);
   
  if ((message_type == 8) || (message_type == 4) || (message_type == 7) ||
      ((message_type == 3) &&  
       ((dhcp->state==5) || dhcp->state==4))) {
    ((dhcp->msg_out->ciaddr). addr = (netif->ip_addr). addr);
  }
  ((&dhcp->msg_out->yiaddr)->addr = 0);
  ((&dhcp->msg_out->siaddr)->addr = 0);
  ((&dhcp->msg_out->giaddr)->addr = 0);
  for (i = 0; i < 16U; i++) {
     
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0 ;
  }
  for (i = 0; i < 64U; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < 128U; i++) {
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = ((((0x63825363UL) & 0xff) << 24) | (((0x63825363UL) & 0xff00) << 8) | (((0x63825363UL) & 0xff0000UL) >> 8) | (((0x63825363UL) & 0xff000000UL) >> 24));
  dhcp->options_out_len = 0;
   
  for (i = 0; i < 68U; i++) {
    dhcp->msg_out->options[i] = (u8_t)i;  
  }
   
  dhcp_option(dhcp, 53, 1);
  dhcp_option_byte(dhcp, message_type);
  return 0;
}





 
static void
dhcp_delete_msg(struct dhcp *dhcp)
{
  do { if (!((dhcp != 0))) { ; return;;}} while(0);
  do { if(!(dhcp->p_out != 0)) ; } while(0);
  do { if(!(dhcp->msg_out != 0)) ; } while(0);
  if (dhcp->p_out != 0) {
    pbuf_free(dhcp->p_out);
  }
  dhcp->p_out = 0;
  dhcp->msg_out = 0;
}








 
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  do { if (!((dhcp != 0))) { ; return;;}} while(0);
  do { if(!(dhcp->msg_out != 0)) ; } while(0);
  do { if(!(dhcp->options_out_len < 68U)) ; } while(0);
  dhcp->msg_out->options[dhcp->options_out_len++] = 255;
   
  while (((dhcp->options_out_len < 68U) || (dhcp->options_out_len & 3)) &&
         (dhcp->options_out_len < 68U)) {
     
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}

