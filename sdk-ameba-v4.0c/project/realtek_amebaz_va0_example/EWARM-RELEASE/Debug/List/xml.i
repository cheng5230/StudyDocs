#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\utilities\\xml.c"










 

#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"





 









#line 22 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"

#line 150 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"

#line 1 "F:\\IAR\\arm\\inc\\c\\stdio.h"
 
 




  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"















 

#line 103 "F:\\IAR\\arm\\inc\\c\\ycheck.h"









#line 11 "F:\\IAR\\arm\\inc\\c\\stdio.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\yvals.h"
 
 





  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 12 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 









  


                 




















 


   
#line 59 "F:\\IAR\\arm\\inc\\c\\yvals.h"





#line 70 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 
#line 1 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"



























 





  #pragma system_include


 
#line 1 "F:\\IAR\\arm\\INC\\c\\DLib_Config_Normal.h"
 
 





  #pragma system_include


 

#line 40 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"
   
#line 47 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"

 
#line 1 "F:\\IAR\\arm\\inc\\c\\DLib_Product.h"




   #pragma system_include







 




 


 



 



 


 




 
#line 45 "F:\\IAR\\arm\\inc\\c\\DLib_Product.h"

 


 


 






 




 


 


 
#line 99 "F:\\IAR\\arm\\inc\\c\\DLib_Product.h"







#line 51 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"











 












 
























 













 























































































































 






 














 
























 


















 
















 








 















 

#line 351 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"













 













 












 














 












 












 












 












 

















 

















 






















 















 








 














 

#line 566 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"












 












 












 












 












 












 












 












 












 










 







 












 







 








 



















































 
















 




#line 812 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"





 

#line 826 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"


   
#line 836 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"

#line 844 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"
  







 









 








 







 






 

#line 899 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"




 







 






 















 

   
#line 943 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"









 

  #pragma language = save 
  #pragma language = extended





  #pragma language = restore










 








 







 
#line 997 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"





 







#line 73 "F:\\IAR\\arm\\inc\\c\\yvals.h"











                 




















 
#line 147 "F:\\IAR\\arm\\inc\\c\\yvals.h"





                 


 




 
 
#line 170 "F:\\IAR\\arm\\inc\\c\\yvals.h"

 




 






 






 
#line 233 "F:\\IAR\\arm\\inc\\c\\yvals.h"











                 
#line 292 "F:\\IAR\\arm\\inc\\c\\yvals.h"









#line 308 "F:\\IAR\\arm\\inc\\c\\yvals.h"








#line 1 "F:\\IAR\\arm\\inc\\c\\xencoding_limits.h"
 
 





  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 12 "F:\\IAR\\arm\\inc\\c\\xencoding_limits.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\yvals.h"
 
 

#line 711 "F:\\IAR\\arm\\inc\\c\\yvals.h"




 
#line 13 "F:\\IAR\\arm\\inc\\c\\xencoding_limits.h"

                                 


#line 24 "F:\\IAR\\arm\\inc\\c\\xencoding_limits.h"




#line 42 "F:\\IAR\\arm\\inc\\c\\xencoding_limits.h"

                                 














#line 317 "F:\\IAR\\arm\\inc\\c\\yvals.h"



                 

                 
#line 335 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 
#line 360 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 
                 




#line 382 "F:\\IAR\\arm\\inc\\c\\yvals.h"


                 

                                 







  #pragma language=save
  #pragma language=extended
  typedef long long _Longlong;
  typedef unsigned long long _ULonglong;
  #pragma language=restore
#line 405 "F:\\IAR\\arm\\inc\\c\\yvals.h"






  typedef unsigned short int _Wchart;
  typedef unsigned short int _Wintt;


#line 424 "F:\\IAR\\arm\\inc\\c\\yvals.h"

#line 432 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 


typedef signed int  _Ptrdifft;
typedef unsigned int     _Sizet;

 


                 







 
  typedef struct __va_list
  {
    char  *_Ap;
  } __va_list;

  typedef __va_list __Va_list;





__intrinsic __nounwind void __iar_Atexit(void (*)(void));



  typedef struct
  {        
    unsigned int _Wchar;
    unsigned int _State;
  } _Mbstatet;
#line 481 "F:\\IAR\\arm\\inc\\c\\yvals.h"










typedef struct
{        

  _Longlong _Off;     



  _Mbstatet _Wstate;
} _Fpost;







                 

#line 1 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"













 





  #pragma system_include






 






















































































 

 



#line 157 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"

  
 

   





  


#line 176 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"





#line 187 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"





  #pragma language=save 
  #pragma language=extended
  __intrinsic __nounwind void __iar_dlib_perthread_initialize(void  *);
  __intrinsic __nounwind void  *__iar_dlib_perthread_allocate(void);
  __intrinsic __nounwind void __iar_dlib_perthread_destroy(void);
  __intrinsic __nounwind void __iar_dlib_perthread_deallocate(void  *);









  #pragma segment = "__DLIB_PERTHREAD" 
  #pragma segment = "__DLIB_PERTHREAD_init" 


























#line 242 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"

   
  void  *__iar_dlib_perthread_access(void  *);
  #pragma language=restore



























     
  









   






  





  
  typedef void *__iar_Rmtx;
  

  
  __intrinsic __nounwind void __iar_system_Mtxinit(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_system_Mtxdst(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_system_Mtxlock(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_system_Mtxunlock(__iar_Rmtx *m);

  __intrinsic __nounwind void __iar_file_Mtxinit(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_file_Mtxdst(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_file_Mtxlock(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_file_Mtxunlock(__iar_Rmtx *m);

  
 
  __intrinsic __nounwind void __iar_clearlocks(void);


#line 323 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"

  





  

#line 341 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"

  typedef unsigned _Once_t;



  













#line 510 "F:\\IAR\\arm\\inc\\c\\yvals.h"

#line 520 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 
#line 528 "F:\\IAR\\arm\\inc\\c\\yvals.h"


                 

  
  
    
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock_Locale(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock_Malloc(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock_Stream(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock_Debug(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock_StaticGuard(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock(unsigned int);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock_Locale(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock_Malloc(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock_Stream(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock_Debug(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock_StaticGuard(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock(unsigned int);

  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Initdynamicfilelock(__iar_Rmtx *);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Dstdynamicfilelock(__iar_Rmtx *);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Lockdynamicfilelock(__iar_Rmtx *);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlockdynamicfilelock(__iar_Rmtx *);
  
  
#line 568 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 
#line 576 "F:\\IAR\\arm\\inc\\c\\yvals.h"

#line 694 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 





#line 709 "F:\\IAR\\arm\\inc\\c\\yvals.h"






 
#line 12 "F:\\IAR\\arm\\inc\\c\\stdio.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\ysizet.h"
 
 





  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 12 "F:\\IAR\\arm\\inc\\c\\ysizet.h"



                 




typedef _Sizet size_t;




typedef unsigned int __data_size_t;











#line 13 "F:\\IAR\\arm\\inc\\c\\stdio.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\ystdio.h"
 
 




  #pragma system_include







#line 58 "F:\\IAR\\arm\\inc\\c\\ystdio.h"
  

 

__intrinsic __nounwind int remove(const char *);
__intrinsic __nounwind int rename(const char *, const char *);














 
#line 14 "F:\\IAR\\arm\\inc\\c\\stdio.h"



 
#pragma rtmodel="__dlib_file_descriptor","0"

                 








#line 66 "F:\\IAR\\arm\\inc\\c\\stdio.h"

#line 88 "F:\\IAR\\arm\\inc\\c\\stdio.h"

#line 99 "F:\\IAR\\arm\\inc\\c\\stdio.h"










                 
typedef _Fpost fpos_t;

                 
#pragma language=save
#pragma language=extended

#line 125 "F:\\IAR\\arm\\inc\\c\\stdio.h"

#line 177 "F:\\IAR\\arm\\inc\\c\\stdio.h"


              
_Pragma("function_effects = no_read(1), always_returns")    __intrinsic __nounwind char * __gets(char *, int);
_Pragma("function_effects = no_read(1), always_returns")    __intrinsic __nounwind char * gets(char *);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind void perror(const char *);
_Pragma("function_effects = no_write(1), always_returns")    _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int printf(const char *, ...);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind int puts(const char *);
_Pragma("function_effects = no_write(1), always_returns")    _Pragma("__scanf_args") _Pragma("library_default_requirements _Scanf = unknown")  __intrinsic __nounwind int scanf(const char *, ...);
_Pragma("function_effects = no_read(1), no_write(2), always_returns") _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int sprintf(char *, 
                                                 const char *, ...);
_Pragma("function_effects = no_write(1,2), always_returns") _Pragma("__scanf_args") _Pragma("library_default_requirements _Scanf = unknown")  __intrinsic __nounwind int sscanf(const char *, 
                                                const char *, ...);
             __intrinsic __nounwind char * tmpnam(char *);
              
             __intrinsic __nounwind int __ungetchar(int);
_Pragma("function_effects = no_write(1), always_returns")    _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int vprintf(const char *,
                                                 __Va_list);

  _Pragma("function_effects = no_write(1), always_returns")    _Pragma("__scanf_args") _Pragma("library_default_requirements _Scanf = unknown")  __intrinsic __nounwind int vscanf(const char *, 
                                                  __Va_list);
  _Pragma("function_effects = no_write(1,2), always_returns") _Pragma("__scanf_args") _Pragma("library_default_requirements _Scanf = unknown")  __intrinsic __nounwind int vsscanf(const char *, 
                                                   const char *, 
                                                   __Va_list);

_Pragma("function_effects = no_read(1), no_write(2), always_returns")  _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int vsprintf(char *, 
                                                   const char *,
                                                   __Va_list);
               
_Pragma("function_effects = no_write(1), always_returns")      __intrinsic __nounwind size_t __write_array(const void *, size_t, size_t);

  _Pragma("function_effects = no_read(1), no_write(3), always_returns") _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int snprintf(char *, size_t, 
                                                    const char *, ...);
  _Pragma("function_effects = no_read(1), no_write(3), always_returns") _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int vsnprintf(char *, size_t,
                                                     const char *, 
                                                     __Va_list);


              __intrinsic __nounwind int getchar(void);
              __intrinsic __nounwind int putchar(int);



#pragma language=restore

#line 238 "F:\\IAR\\arm\\inc\\c\\stdio.h"




#line 292 "F:\\IAR\\arm\\inc\\c\\stdio.h"




 
#line 162 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\stdlib.h"
 
 





  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 12 "F:\\IAR\\arm\\inc\\c\\stdlib.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\ysizet.h"
 
 

#line 30 "F:\\IAR\\arm\\inc\\c\\ysizet.h"







#line 14 "F:\\IAR\\arm\\inc\\c\\stdlib.h"


 
#pragma rtmodel="__dlib_full_locale_support",   "0"





extern int __aeabi_MB_CUR_MAX(void);


#line 34 "F:\\IAR\\arm\\inc\\c\\stdlib.h"





                 













                 


  typedef _Wchart wchar_t;


typedef struct
{        
  int quot;
  int rem;
} div_t;

typedef struct
{        
  long quot;
  long rem;
} ldiv_t;



    #pragma language=save
    #pragma language=extended
    typedef struct
    {      
      _Longlong quot;
      _Longlong rem;
    } lldiv_t;
    #pragma language=restore



                 
  
__intrinsic __nounwind int atexit(void (*)(void));

  __intrinsic __noreturn __nounwind void _Exit(int) ;

__intrinsic __noreturn __nounwind void exit(int) ;
__intrinsic __nounwind char * getenv(const char *);
__intrinsic __nounwind int system(const char *);



             __intrinsic __noreturn __nounwind void abort(void) ;
_Pragma("function_effects = no_state, always_returns")     __intrinsic __nounwind int abs(int);
             __intrinsic __nounwind void * calloc(size_t, size_t);
_Pragma("function_effects = no_state, always_returns")     __intrinsic __nounwind div_t div(int, int);
             __intrinsic __nounwind void free(void *);
_Pragma("function_effects = no_state, always_returns")     __intrinsic __nounwind long labs(long);
_Pragma("function_effects = no_state, always_returns")     __intrinsic __nounwind ldiv_t ldiv(long, long);


    #pragma language=save
    #pragma language=extended
    _Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long llabs(long long);
    _Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind lldiv_t lldiv(long long, long long);
    #pragma language=restore


             __intrinsic __nounwind void * malloc(size_t);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind int mblen(const char *, size_t);
_Pragma("function_effects = no_read(1), no_write(2), always_returns") __intrinsic __nounwind size_t mbstowcs(wchar_t *, 
                                          const char *, size_t);
_Pragma("function_effects = no_read(1), no_write(2), always_returns") __intrinsic __nounwind int mbtowc(wchar_t *, const char *, 
                                     size_t);
             __intrinsic __nounwind int rand(void);
             __intrinsic __nounwind void srand(unsigned int);
             __intrinsic __nounwind void * realloc(void *, size_t);
_Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long strtol(const char *, 
                                      char **, int);
_Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind unsigned long strtoul(const char *, char **, int);
_Pragma("function_effects = no_read(1), no_write(2), always_returns") __intrinsic __nounwind size_t wcstombs(char *, 
                                          const wchar_t *, size_t);
_Pragma("function_effects = no_read(1), always_returns")    __intrinsic __nounwind int wctomb(char *, wchar_t);


    #pragma language=save
    #pragma language=extended
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long long strtoll(const char *, char **, int);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind unsigned long long strtoull(const char *, 
                                                          char **, int);
    #pragma language=restore





#line 188 "F:\\IAR\\arm\\inc\\c\\stdlib.h"



    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind unsigned long __iar_Stoul(const char *, char **, 
                                                        int);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind float         __iar_Stof(const char *, char **, long);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind double        __iar_Stod(const char *, char **, long);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long double   __iar_Stold(const char *, char **, 
                                                          long);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long          __iar_Stolx(const char *, char **, int, 
                                                        int *);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind unsigned long __iar_Stoulx(const char *, char **,
                                                         int, int *);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind float         __iar_Stofx(const char *, char **, 
                                                        long, int *);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind double        __iar_Stodx(const char *, char **, 
                                                        long, int *);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long double   __iar_Stoldx(const char *, char **, 
                                                         long, int *);

      #pragma language=save
      #pragma language=extended
      _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind _Longlong   __iar_Stoll(const char *, char **, 
                                                        int);
      _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind _ULonglong   __iar_Stoull(const char *, char **, 
                                                          int);
      _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind _Longlong    __iar_Stollx(const char *, char **, 
                                                          int, int *);
      _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind _ULonglong   __iar_Stoullx(const char *, char **, 
                                                           int, int *);
      #pragma language=restore








typedef int _Cmpfun(const void *, const void *);

_Pragma("function_effects = no_write(1,2), always_returns") __intrinsic void * bsearch(const void *, 
                                                   const void *, size_t,
                                                   size_t, _Cmpfun *);
             __intrinsic void qsort(void *, size_t, size_t, 
                                               _Cmpfun *);
             __intrinsic void __qsortbbl(void *, size_t, size_t, 
                                                    _Cmpfun *);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind double atof(const char *);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind int atoi(const char *);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind long atol(const char *);


    #pragma language=save
    #pragma language=extended
    _Pragma("function_effects = no_write(1), always_returns") __intrinsic __nounwind long long atoll(const char *);
    #pragma language=restore

  _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind float strtof(const char *, 
                                         char **);
  _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long double strtold(const char *, char **);

_Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind double strtod(const char *, 
                                        char **);
                                        

                                        
               __intrinsic __nounwind size_t __iar_Mbcurmax(void);

  _Pragma("function_effects = no_state, always_returns")     __intrinsic __nounwind int __iar_DLib_library_version(void);

  


#line 276 "F:\\IAR\\arm\\inc\\c\\stdlib.h"



  
  typedef void _Atexfun(void);
  
#line 304 "F:\\IAR\\arm\\inc\\c\\stdlib.h"


                 
    #pragma inline=no_body
    double atof(const char *_S)
    {       
      return (__iar_Stod(_S, 0, 0));
    }

    #pragma inline=no_body
    int atoi(const char *_S)
    {       
      return ((int)__iar_Stoul(_S, 0, 10));
    }

    #pragma inline=no_body
    long atol(const char *_S)
    {       
      return ((long)__iar_Stoul(_S, 0, 10));
    }



        #pragma language=save
        #pragma language=extended
        #pragma inline=no_body
        long long atoll(const char *_S)
        {       



            return ((long long)__iar_Stoull(_S, 0, 10));

        }
        #pragma language=restore



    #pragma inline=no_body
    double strtod(const char * _S, char ** _Endptr)
    {       
      return (__iar_Stod(_S, _Endptr, 0));
    }


      #pragma inline=no_body
      float strtof(const char * _S, char ** _Endptr)
      {       
        return (__iar_Stof(_S, _Endptr, 0));
      }

      #pragma inline=no_body
      long double strtold(const char * _S, char ** _Endptr)
      {       
        return (__iar_Stold(_S, _Endptr, 0));
      }


    #pragma inline=no_body
    long strtol(const char * _S, char ** _Endptr, 
                int _Base)
    {       
      return (__iar_Stolx(_S, _Endptr, _Base, 0));
    }

    #pragma inline=no_body
    unsigned long strtoul(const char * _S, char ** _Endptr, 
                          int _Base)
    {       
      return (__iar_Stoul(_S, _Endptr, _Base));
    }



        #pragma language=save
        #pragma language=extended
        #pragma inline=no_body
        long long strtoll(const char * _S, char ** _Endptr,
                          int _Base)
        {       



            return (__iar_Stoll(_S, _Endptr, _Base));

        }

        #pragma inline=no_body
        unsigned long long strtoull(const char * _S, 
                                    char ** _Endptr, int _Base)
        {       



            return (__iar_Stoull(_S, _Endptr, _Base));

        }
        #pragma language=restore





  #pragma inline=no_body
  int abs(int i)
  {       
    return (i < 0 ? -i : i);
  }

  #pragma inline=no_body
  long labs(long i)
  {       
    return (i < 0 ? -i : i);
  }



      #pragma language=save
      #pragma language=extended
      #pragma inline=no_body
      long long llabs(long long i)
      {       
        return (i < 0 ? -i : i);
      }
      #pragma language=restore



#line 465 "F:\\IAR\\arm\\inc\\c\\stdlib.h"




#line 494 "F:\\IAR\\arm\\inc\\c\\stdlib.h"




 
#line 163 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\string.h"
 
 




  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 11 "F:\\IAR\\arm\\inc\\c\\string.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\ysizet.h"
 
 

#line 30 "F:\\IAR\\arm\\inc\\c\\ysizet.h"







#line 13 "F:\\IAR\\arm\\inc\\c\\string.h"

#line 1 "F:\\IAR\\arm\\inc\\c\\DLib_Product_string.h"








 





  #pragma system_include




  
  

  





 


  




 



#line 47 "F:\\IAR\\arm\\inc\\c\\DLib_Product_string.h"



  


 


  #pragma inline=forced_no_body
  __intrinsic __nounwind void * memcpy(void * _D, const void * _S, size_t _N)
  {
    __aeabi_memcpy(_D, _S, _N);
    return _D;
  }


  #pragma inline=forced_no_body
  __intrinsic __nounwind void * memmove(void * _D, const void * _S, size_t _N)
  {
    __aeabi_memmove(_D, _S, _N);
    return _D;
  }


  #pragma inline=forced_no_body
  __intrinsic __nounwind void * memset(void * _D, int _C, size_t _N)
  {
    __aeabi_memset(_D, _N, _C);
    return _D;
  }

  
  



#line 16 "F:\\IAR\\arm\\inc\\c\\string.h"



                 




                 

_Pragma("function_effects = no_state, no_write(1,2), always_returns")   __intrinsic __nounwind int        memcmp(const void *, const void *,
                                                size_t);
_Pragma("function_effects = no_state, no_read(1), no_write(2), returns 1, always_returns") __intrinsic __nounwind void *     memcpy(void *, 
                                                const void *, size_t);
_Pragma("function_effects = no_state, no_read(1), no_write(2), returns 1, always_returns") __intrinsic __nounwind void *     memmove(void *, const void *, size_t);
_Pragma("function_effects = no_state, no_read(1), returns 1, always_returns")    __intrinsic __nounwind void *     memset(void *, int, size_t);
_Pragma("function_effects = no_state, no_write(2), returns 1, always_returns")    __intrinsic __nounwind char *     strcat(char *, 
                                                const char *);
_Pragma("function_effects = no_state, no_write(1,2), always_returns")   __intrinsic __nounwind int        strcmp(const char *, const char *);
_Pragma("function_effects = no_write(1,2), always_returns")     __intrinsic __nounwind int        strcoll(const char *, const char *);
_Pragma("function_effects = no_state, no_read(1), no_write(2), returns 1, always_returns") __intrinsic __nounwind char *     strcpy(char *, 
                                                const char *);
_Pragma("function_effects = no_state, no_write(1,2), always_returns")   __intrinsic __nounwind size_t     strcspn(const char *, const char *);
                 __intrinsic __nounwind char *     strerror(int);
_Pragma("function_effects = no_state, no_write(1), always_returns")      __intrinsic __nounwind size_t     strlen(const char *);
_Pragma("function_effects = no_state, no_write(2), returns 1, always_returns")    __intrinsic __nounwind char *     strncat(char *, 
                                                 const char *, size_t);
_Pragma("function_effects = no_state, no_write(1,2), always_returns")   __intrinsic __nounwind int        strncmp(const char *, const char *, 
                                                 size_t);
_Pragma("function_effects = no_state, no_read(1), no_write(2), returns 1, always_returns") __intrinsic __nounwind char *     strncpy(char *, 
                                                 const char *, size_t);
_Pragma("function_effects = no_state, no_write(1,2), always_returns")   __intrinsic __nounwind size_t     strspn(const char *, const char *);
_Pragma("function_effects = no_write(2), always_returns")        __intrinsic __nounwind char *     strtok(char *, 
                                                const char *);
_Pragma("function_effects = no_write(2), always_returns")        __intrinsic __nounwind size_t     strxfrm(char *, 
                                                 const char *, size_t);


  _Pragma("function_effects = no_write(1), always_returns")      __intrinsic __nounwind char *   strdup(const char *);
  _Pragma("function_effects = no_write(1,2), always_returns")   __intrinsic __nounwind int      strcasecmp(const char *, const char *);
  _Pragma("function_effects = no_write(1,2), always_returns")   __intrinsic __nounwind int      strncasecmp(const char *, const char *, 
                                                   size_t);
  _Pragma("function_effects = no_state, no_write(2), always_returns")    __intrinsic __nounwind char *   strtok_r(char *, const char *, char **);
  _Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind size_t   strnlen(char const *, size_t);




#line 81 "F:\\IAR\\arm\\inc\\c\\string.h"
  _Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind void *memchr(const void *_S, int _C, size_t _N);
  _Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind char *strchr(const char *_S, int _C);
  _Pragma("function_effects = no_state, no_write(1,2), always_returns") __intrinsic __nounwind char *strpbrk(const char *_S, const char *_P);
  _Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind char *strrchr(const char *_S, int _C);
  _Pragma("function_effects = no_state, no_write(1,2), always_returns") __intrinsic __nounwind char *strstr(const char *_S, const char *_P);




                 


                 

_Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind void *__iar_Memchr(const void *, int, size_t);
_Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind char *__iar_Strchr(const char *, int);
               __intrinsic __nounwind char *__iar_Strerror(int, char *);
_Pragma("function_effects = no_state, no_write(1,2), always_returns") __intrinsic __nounwind char *__iar_Strpbrk(const char *, const char *);
_Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind char *__iar_Strrchr(const char *, int);
_Pragma("function_effects = no_state, no_write(1,2), always_returns") __intrinsic __nounwind char *__iar_Strstr(const char *, const char *);


                 
#line 168 "F:\\IAR\\arm\\inc\\c\\string.h"
                 
    #pragma inline
    void *memchr(const void *_S, int _C, size_t _N)
    {
      return (__iar_Memchr(_S, _C, _N));
    }

    #pragma inline
    char *strchr(const char *_S, int _C)
    {
      return (__iar_Strchr(_S, _C));
    }

    #pragma inline
    char *strpbrk(const char *_S, const char *_P)
    {
      return (__iar_Strpbrk(_S, _P));
    }

    #pragma inline
    char *strrchr(const char *_S, int _C)
    {
      return (__iar_Strrchr(_S, _C));
    }

    #pragma inline
    char *strstr(const char *_S, const char *_P)
    {
      return (__iar_Strstr(_S, _P));
    }


  #pragma inline
  char *strerror(int _Err)
  {
    return (__iar_Strerror(_Err, 0));
  }

#line 451 "F:\\IAR\\arm\\inc\\c\\string.h"






#line 479 "F:\\IAR\\arm\\inc\\c\\string.h"




 
#line 164 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
	#include <stdarg.h>  
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"







 




#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"


 




 



 








 
#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 42 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 52 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 62 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 





 





 





 





 





 





 





 





 





 





 




 





 







 





 






 





 




 




 




 







 




 




 




 






 




 




 




 




 








 
#line 14 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"


















 




#line 1 "F:\\IAR\\arm\\inc\\c\\stdint.h"
 
 




  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 11 "F:\\IAR\\arm\\inc\\c\\stdint.h"



 

  typedef signed char   int8_t;
  typedef unsigned char uint8_t;



  typedef signed short int   int16_t;
  typedef unsigned short int uint16_t;



  typedef signed int   int32_t;
  typedef unsigned int uint32_t;



  #pragma language=save
  #pragma language=extended
  typedef signed long long int   int64_t;
  typedef unsigned long long int uint64_t;
  #pragma language=restore



 
typedef signed char   int_least8_t;
typedef unsigned char uint_least8_t;

typedef signed short int   int_least16_t;
typedef unsigned short int uint_least16_t;

typedef signed int   int_least32_t;
typedef unsigned int uint_least32_t;

 

  #pragma language=save
  #pragma language=extended
  typedef signed long long int int_least64_t;
  #pragma language=restore


  #pragma language=save
  #pragma language=extended
  typedef unsigned long long int uint_least64_t;
  #pragma language=restore




 
typedef signed int   int_fast8_t;
typedef unsigned int uint_fast8_t;

typedef signed int   int_fast16_t;
typedef unsigned int uint_fast16_t;

typedef signed int   int_fast32_t;
typedef unsigned int uint_fast32_t;


  #pragma language=save
  #pragma language=extended
  typedef signed long long int int_fast64_t;
  #pragma language=restore


  #pragma language=save
  #pragma language=extended
  typedef unsigned long long int uint_fast64_t;
  #pragma language=restore


 
#pragma language=save
#pragma language=extended
typedef signed long long int   intmax_t;
typedef unsigned long long int uintmax_t;
#pragma language=restore


 
typedef signed long int   intptr_t;
typedef unsigned long int uintptr_t;

 



typedef int __data_intptr_t; typedef unsigned int __data_uintptr_t;


 






























































































 

































#line 258 "F:\\IAR\\arm\\inc\\c\\stdint.h"




 
#line 25 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"






















		













typedef unsigned int	        uint;
typedef	signed int		        sint;


typedef signed long long        __int64_t;
typedef unsigned long long      __uint64_t;


#line 77 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"





typedef unsigned char           BOOL;


typedef unsigned char           bool;








typedef struct { volatile int counter; } atomic_t;

typedef enum _RTK_STATUS_ {
    _EXIT_SUCCESS = 0,
    _EXIT_FAILURE = 1
}RTK_STATUS, *PRTK_STATUS;

#line 107 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"


typedef void * PVOID;


typedef     uint32_t dma_addr_t;

typedef     void (*proc_t)(void*);

typedef     unsigned int __kernel_size_t;
typedef     int __kernel_ssize_t;

typedef 	__kernel_size_t	SIZE_T;	
typedef	    __kernel_ssize_t	SSIZE_T;

























#line 178 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"







#line 201 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"











 




#line 228 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"

#line 241 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"







 




















































#line 307 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"






#line 319 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"





#line 331 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"

		


		


	


	
#line 348 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"
	
#line 355 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"

#line 363 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"
			









#line 379 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"

#line 386 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"

#line 394 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"








#line 411 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"




typedef unsigned char	BOOLEAN,*PBOOLEAN,boolean;







 








								
								
								
								
								

								
								
#line 449 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"












#line 480 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"







typedef struct _RAM_START_FUNCTION_ {
    void (*RamStartFun) (void);
	void (*RamWakeupFun) (void);
}RAM_START_FUNCTION, *PRAM_START_FUNCTION;

typedef struct _RAM_FUNCTION_START_TABLE_ {
	void (*RamStartFun) (void);
	void (*RamWakeupFun) (void);
	void (*RamPatchFun0) (void);
	void (*RamPatchFun1) (void);
	void (*RamPatchFun2) (void);
	void (*FlashStartFun) (void);
}RAM_FUNCTION_START_TABLE, *PRAM_FUNCTION_START_TABLE;

#line 15 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"

#line 1 "F:\\IAR\\arm\\inc\\c\\stddef.h"
 
 




  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 11 "F:\\IAR\\arm\\inc\\c\\stddef.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\ysizet.h"
 
 

#line 30 "F:\\IAR\\arm\\inc\\c\\ysizet.h"







#line 13 "F:\\IAR\\arm\\inc\\c\\stddef.h"



                 








                 




  typedef _Ptrdifft ptrdiff_t;









#line 49 "F:\\IAR\\arm\\inc\\c\\stddef.h"





 
#line 17 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\app\\monitor\\include\\rtl_trace.h"















 







 




 



 

 
typedef enum {
	MODULE_OS		= 0,   
	MODULE_BOOT		= 1,   
	MODULE_GDMA	= 2,   
	MODULE_GPIO		= 3,   
	MODULE_TIMER	= 4,   
	MODULE_I2C		= 5,   
	MODULE_I2S		= 6,   
	MODULE_PWM		= 7,   
	MODULE_SDIO		= 8,   
	MODULE_SPI		= 9,   
	MODULE_FLASH	= 10,  
	MODULE_UART		= 11,  
	MODULE_USOC		= 12,  
	MODULE_IPSEC	= 13,  
	MODULE_ADC		= 14,  
	MODULE_EFUSE	= 15,  
	MODULE_MONIT	= 16,  
	MODULE_MISC		= 17,  

	MODULE_NUMs            
} MODULE_DEFINE;

 
typedef enum {
	LEVEL_ERROR	= 0,  
	LEVEL_WARN	= 1,  
	LEVEL_INFO		= 2,  
	LEVEL_TRACE	= 3,  
	LEVEL_NUMs		= 4   
} LEVEL_DEFINE;


 



 

 
 
extern uint32_t ConfigDebug[];
 


















 
void LOG_MASK_MODULE(uint32_t module, uint32_t level, uint32_t new_status);
void LOG_MASK(uint32_t config[]);
void LOG_PRINTF(uint32_t module, uint32_t level, uint32_t line, const char*fmt, ...);



 
#line 120 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\app\\monitor\\include\\rtl_trace.h"



 



 



 


 
#line 18 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"

extern uint32_t ConfigDebugClose;
extern uint32_t ConfigDebugErr;
extern uint32_t ConfigDebugInfo;
extern uint32_t ConfigDebugWarn;

extern uint32_t CfgSysDebugErr;
extern uint32_t CfgSysDebugInfo;
extern uint32_t CfgSysDebugWarn;










#line 57 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"

extern  uint32_t DiagPrintf(const char *fmt, ...);
uint32_t DiagSPrintf(uint8_t *buf, const char *fmt, ...);
int prvDiagPrintf(const char *fmt, ...);
int prvDiagSPrintf(char *buf, const char *fmt, ...);






























#line 100 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"








































#line 153 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"

#line 161 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"

typedef enum {
	DBG_CFG_ERR=0,
	DBG_CFG_WARN=1,
	DBG_CFG_INFO=2
} DBG_CFG_TYPE;

typedef struct {
	uint8_t cmd_name[16];
	uint32_t	cmd_type;
} DBG_CFG_CMD;

typedef enum _CONSOLE_OP_STAGE_ {
	ROM_STAGE = 0,
	RAM_STAGE = 1
}CONSOLE_OP_STAGE;

#line 166 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\strproc.h"







 




#line 1 "F:\\IAR\\arm\\inc\\c\\stddef.h"
 
 
#line 39 "F:\\IAR\\arm\\inc\\c\\stddef.h"

#line 49 "F:\\IAR\\arm\\inc\\c\\stddef.h"





 
#line 14 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\strproc.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\va_list.h"







 




#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"


 




 



 








 
#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 42 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 52 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 62 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 





 





 





 





 





 





 





 





 





 





 




 





 







 





 






 





 




 




 




 







 




 




 




 






 




 




 




 




 








 
#line 14 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\va_list.h"


#line 36 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\va_list.h"

#line 15 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\strproc.h"

#line 24 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\strproc.h"

extern  SIZE_T _strlen(const char *s);
extern  int _strcmp(const char *cs, const char *ct);
extern  char *_strncpy(char *dest, const char *src, size_t count);
extern  char *_strcpy(char *dest, const char *src);
extern  size_t _strlen(const char *s);
extern  size_t _strnlen(const char *s, size_t count);
extern  int _strncmp(const char *cs, const char *ct, size_t count);
extern  int _sscanf(const char *buf, const char *fmt, ...);
extern  char *_strsep(char **s, const char *ct);
extern  char *skip_spaces(const char *str);
extern  int skip_atoi(const char **s);
extern  int _vsscanf(const char *buf, const char *fmt, va_list args);
extern  unsigned long long simple_strtoull(const char *cp, char **endp, unsigned int base);
extern  long simple_strtol(const char *cp, char **endp, unsigned int base);
extern  long long simple_strtoll(const char *cp, char **endp, unsigned int base);
extern  unsigned long simple_strtoul(const char *cp, char **endp, unsigned int base);
extern  const char *_parse_integer_fixup_radix(const char *s, unsigned int *base);
extern  unsigned int _parse_integer(const char *s, unsigned int base, unsigned long long *p);
extern  uint64_t div_u64(uint64_t dividend, uint32_t divisor);
extern  int64_t div_s64(int64_t dividend, int32_t divisor);
extern  uint64_t div_u64_rem(uint64_t dividend, uint32_t divisor, uint32_t *remainder);
extern  int64_t div_s64_rem(int64_t dividend, int32_t divisor, int32_t *remainder);
extern  char *_strpbrk(const char *cs, const char *ct);
extern  char *_strchr(const char *s, int c);


extern  void
prvStrCpy(
      uint8_t  *pDES,
      const uint8_t  *pSRC
);

extern  uint32_t
prvStrLen(
      const   uint8_t  *pSRC
);

extern   uint8_t
prvStrCmp(
      const   uint8_t  *string1,
      const   uint8_t  *string2
);

extern  uint8_t*
StrUpr(
      uint8_t  *string
);

extern  int prvAtoi(
	 const char * s
);

extern   char * prvStrStr(
	 const char * str1, 
	 const char * str2
);

extern  char* prvStrtok(
	 char *str, 
	 const char* delim
);





 
static inline char _tolower(const char c)
{
    return c | 0x20;
}

 
static inline int isodigit(const char c)
{
    return c >= '0' && c <= '7';
}
#line 108 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\strproc.h"

#line 167 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\memproc.h"







 






 
extern  void *_memset( void *s, int c, SIZE_T n );
extern  void *_memcpy( void *s1, const void *s2, SIZE_T n );
extern  int _memcmp( const void *av, const void *bv, SIZE_T len );



#line 168 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\std_lib\\include\\rtl_lib.h"




 
 








extern int __rtl_errno;


void init_rom_libgloss_ram_map(void);






extern int rtl_printf( const char* fmt, ...);
extern int rtl_vprintf(const char *fmt, va_list ap);
extern int rtl_sprintf(char* str, const char* fmt, ...);
extern int rtl_snprintf(char* str, size_t size, const char* fmt, ...);
extern int rtl_vsnprintf(char *str, size_t size, const char *fmt, va_list ap);





extern void * rtl_memchr(const void * src_void , int c , size_t length);
extern int rtl_memcmp(const void * m1 , const void * m2 , size_t n);
extern void * rtl_memcpy(void * dst0 , const void * src0 , size_t len0);
extern void * rtl_memmove( void * dst_void , const void * src_void , size_t length);
extern void * rtl_memset(void * m , int c , size_t n);
extern char * rtl_strcat(char * s1 , const char * s2);
extern char * rtl_strchr(const char *s1 , int i);
extern int rtl_strcmp(const char *s1 ,	const char *s2);
extern char* rtl_strcpy(char *dst0 , const char *src0);
extern size_t rtl_strlen(const char *str);
extern char * rtl_strncat(char * s1 , const char * s2 , size_t n);
extern int rtl_strncmp(const char *s1 , const char *s2 , size_t n);
extern char * rtl_strncpy(char * dst0 , const char * src0 , size_t count);
extern char * rtl_strstr(const char *searchee , const char *lookfor);
extern char * rtl_strsep(char **source_ptr , const char *delim);
extern char * rtl_strtok(char * s , const char * delim);






extern double rtl_fabs(double);
extern float rtl_fabsf(float a);
extern float rtl_cos_f32(float a);
extern float rtl_sin_f32(float a);

extern float rtl_fadd(float a, float b);
extern float rtl_fsub(float a, float b);
extern float rtl_fmul(float a, float b);
extern float rtl_fdiv(float a, float b);

extern int rtl_fcmplt(float a, float b);
extern int rtl_fcmpgt(float a, float b);








extern double rtl_ftod(float f);

extern double rtl_ddiv(double a, double b);






typedef union
{
  float value;
  uint32_t 	word;
} ieee_float_shape_type;

 

#line 100 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\std_lib\\include\\rtl_lib.h"

 

#line 109 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\std_lib\\include\\rtl_lib.h"

static inline
float rtl_nanf(void)
{
	float x;

	do { ieee_float_shape_type sf_u; sf_u . word = (0x7fc00000); (x) = sf_u . value; } while (0);
	return x;
}






extern int rtl_sscanf_patch_test(void);
extern int rtl_lib_test( uint16_t argc,  uint8_t *argv[]);
extern int rtl_math_test( uint16_t argc,  uint8_t *argv[]);
extern int rtl_string_test( uint16_t argc,  uint8_t *argv[]);
















#line 171 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\std_lib\\libc\\rom\\string\\rom_libc_string.h"




 





#line 27 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\std_lib\\libc\\rom\\string\\rom_libc_string.h"





extern  void * __rtl_memchr_v1_00(const void * src_void , int c , size_t length);
extern  int __rtl_memcmp_v1_00(const void * m1 , const void * m2 , size_t n);
extern  void * __rtl_memcpy_v1_00(void *  dst0 , const void *  src0 , size_t len0);
extern  void * __rtl_memmove_v1_00( void * dst_void , const void * src_void , size_t length);
extern  void * __rtl_memset_v1_00(void * m , int c , size_t n);
extern  char * __rtl_strcat_v1_00(char * s1 , const char * s2);
extern  char * __rtl_strchr_v1_00(const char *s1 , int i);
extern  int __rtl_strcmp_v1_00(const char *s1 ,	const char *s2);
extern  char* __rtl_strcpy_v1_00(char *dst0 , const char *src0);
extern  size_t __rtl_strlen_v1_00(const char *str);
extern  char * __rtl_strncat_v1_00(char * s1 , const char * s2 , size_t n);
extern  int __rtl_strncmp_v1_00(const char *s1 , const char *s2 , size_t n);
extern  char * __rtl_strncpy_v1_00(char * dst0 , const char * src0 , size_t count);
extern  char * __rtl_strstr_v1_00(const char *searchee , const char *lookfor);
extern  char * __rtl_strsep_v1_00(register char **source_ptr , register const char *delim);
extern  char * __rtl_strtok_v1_00(register char * s , register const char * delim);

#line 172 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"


#line 196 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
	
#line 218 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
	
#line 227 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
	



	
#line 240 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
	
	
	






extern void *pvPortMalloc( size_t xWantedSize );
extern void vPortFree( void *pv );
#line 259 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"


#line 14 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\utilities\\xml.c"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"































































 






 
#line 1 "F:\\IAR\\arm\\inc\\c\\stddef.h"
 
 
#line 39 "F:\\IAR\\arm\\inc\\c\\stddef.h"

#line 49 "F:\\IAR\\arm\\inc\\c\\stddef.h"





 
#line 73 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"













 
#line 1 "F:\\IAR\\arm\\inc\\c\\stdint.h"
 
 
#line 235 "F:\\IAR\\arm\\inc\\c\\stdint.h"

#line 258 "F:\\IAR\\arm\\inc\\c\\stdint.h"




 
#line 88 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"





 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"


































































 

#line 1 "F:\\IAR\\arm\\inc\\c\\stdint.h"
 
 
#line 235 "F:\\IAR\\arm\\inc\\c\\stdint.h"

#line 258 "F:\\IAR\\arm\\inc\\c\\stdint.h"




 
#line 73 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"
extern uint32_t SystemCoreClock; 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"


 




 



 








 
#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"



 
#line 42 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"



 
#line 52 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"



 
#line 62 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"



 





 





 





 





 





 





 





 





 





 





 




 





 







 





 






 





 




 




 




 







 




 




 




 






 




 




 




 




 








 
#line 76 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"











 

#line 108 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"






#line 127 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"







extern void freertos_pre_sleep_processing(unsigned int *expected_idle_time);
extern void freertos_post_sleep_processing(unsigned int *expected_idle_time);
extern int  freertos_ready_to_sleep();

 


 


 




 






                                                        



 





 
#line 176 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"

 
#line 184 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"



 





 




 


 





#line 95 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"

 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\projdefs.h"































































 







 
typedef void (*TaskFunction_t)( void * );

 










 








#line 98 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"

 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\portable.h"































































 



 







 










































































































































































#line 254 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\portable.h"

#line 262 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\portable.h"







#line 276 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\portable.h"











































 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\portable\\IAR\\ARM_CM4F\\portmacro.h"































































 

















 

 
#line 92 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\portable\\IAR\\ARM_CM4F\\portmacro.h"

typedef uint32_t StackType_t;
typedef long BaseType_t;
typedef unsigned long UBaseType_t;





	typedef uint32_t TickType_t;


 

 



 

 
extern void vPortYield( void );





 

 






	 




	 



	 

#line 1 "F:\\IAR\\arm\\inc\\c\\intrinsics.h"








 




#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 15 "F:\\IAR\\arm\\inc\\c\\intrinsics.h"


  #pragma system_include




 





 









#pragma language=save
#pragma language=extended

__intrinsic __nounwind void    __no_operation(void);

__intrinsic __nounwind void    __disable_interrupt(void);
__intrinsic __nounwind void    __enable_interrupt(void);

typedef unsigned long __istate_t;

__intrinsic __nounwind __istate_t __get_interrupt_state(void);
__intrinsic __nounwind void __set_interrupt_state(__istate_t);



 
__intrinsic __nounwind unsigned long __get_PSR( void );
__intrinsic __nounwind unsigned long __get_IPSR( void );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __get_MSP( void );
__intrinsic __nounwind void          __set_MSP( unsigned long );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __get_PSP( void );
__intrinsic __nounwind void          __set_PSP( unsigned long );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __get_PRIMASK( void );
__intrinsic __nounwind void          __set_PRIMASK( unsigned long );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __get_CONTROL( void );
__intrinsic __nounwind void          __set_CONTROL( unsigned long );



 
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __get_FAULTMASK( void );
__intrinsic __nounwind void          __set_FAULTMASK(unsigned long);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __get_BASEPRI( void );
__intrinsic __nounwind void          __set_BASEPRI( unsigned long );

#line 80 "F:\\IAR\\arm\\inc\\c\\intrinsics.h"

__intrinsic __nounwind void __disable_fiq(void);
__intrinsic __nounwind void __enable_fiq(void);


 

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SWP( unsigned long, volatile unsigned long * );
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned char __SWPB( unsigned char, volatile unsigned char * );

typedef unsigned long __ul;





 
__intrinsic __nounwind void          __MCR( unsigned __constrange(0,15) coproc, unsigned __constrange(0,8) opcode_1, __ul src,
                                 unsigned __constrange(0,15) CRn, unsigned __constrange(0,15) CRm, unsigned __constrange(0,8) opcode_2 );
__intrinsic __nounwind unsigned long __MRC( unsigned __constrange(0,15) coproc, unsigned __constrange(0,8) opcode_1,
                                 unsigned __constrange(0,15) CRn, unsigned __constrange(0,15) CRm, unsigned __constrange(0,8) opcode_2 );
__intrinsic __nounwind void          __MCR2( unsigned __constrange(0,15) coproc, unsigned __constrange(0,8) opcode_1, __ul src,
                                  unsigned __constrange(0,15) CRn, unsigned __constrange(0,15) CRm, unsigned __constrange(0,8) opcode_2 );
__intrinsic __nounwind unsigned long __MRC2( unsigned __constrange(0,15) coproc, unsigned __constrange(0,8) opcode_1,
                                  unsigned __constrange(0,15) CRn, unsigned __constrange(0,15) CRm, unsigned __constrange(0,8) opcode_2 );

 
__intrinsic __nounwind void __LDC( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src);
__intrinsic __nounwind void __LDCL( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src);
__intrinsic __nounwind void __LDC2( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src);
__intrinsic __nounwind void __LDC2L( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src);

 
__intrinsic __nounwind void __STC( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst);
__intrinsic __nounwind void __STCL( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst);
__intrinsic __nounwind void __STC2( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst);
__intrinsic __nounwind void __STC2L( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst);

 
__intrinsic __nounwind void __LDC_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src,
                              unsigned __constrange(0,255) option);

__intrinsic __nounwind void __LDCL_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src,
                               unsigned __constrange(0,255) option);

__intrinsic __nounwind void __LDC2_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src,
                               unsigned __constrange(0,255) option);

__intrinsic __nounwind void __LDC2L_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src,
                                unsigned __constrange(0,255) option);

 
__intrinsic __nounwind void __STC_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst,
                              unsigned __constrange(0,255) option);

__intrinsic __nounwind void __STCL_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst,
                               unsigned __constrange(0,255) option);

__intrinsic __nounwind void __STC2_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst,
                               unsigned __constrange(0,255) option);

__intrinsic __nounwind void __STC2L_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst,
                                unsigned __constrange(0,255) option);


 
__intrinsic __nounwind unsigned long __get_APSR( void );
__intrinsic __nounwind void          __set_APSR( unsigned long );






 
__intrinsic __nounwind unsigned long __get_FPSCR( void );
__intrinsic __nounwind void __set_FPSCR( unsigned long );

 
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned char __CLZ( unsigned long );

 

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind signed long __QADD( signed long, signed long );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind signed long __QDADD( signed long, signed long );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind signed long __QSUB( signed long, signed long );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind signed long __QDSUB( signed long, signed long );

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind signed long __QDOUBLE( signed long );

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind int         __QFlag( void );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind void __reset_Q_flag( void );


_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind int         __QCFlag( void );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind void __reset_QC_flag( void );

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind signed long __SMUL( signed short, signed short );

 
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __REV( unsigned long );
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind signed long __REVSH( short );

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __REV16( unsigned long );
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __RBIT( unsigned long );

_Pragma("function_effects = no_state, no_write(1), always_returns") __intrinsic __nounwind unsigned char  __LDREXB( volatile unsigned char const * );
_Pragma("function_effects = no_state, no_write(1), always_returns") __intrinsic __nounwind unsigned short __LDREXH( volatile unsigned short const * );
_Pragma("function_effects = no_state, no_write(1), always_returns") __intrinsic __nounwind unsigned long  __LDREX ( volatile unsigned long const * );
_Pragma("function_effects = no_state, no_write(1), always_returns") __intrinsic __nounwind unsigned long long __LDREXD( volatile unsigned long long const * );

_Pragma("function_effects = no_state, no_read(2), always_returns") __intrinsic __nounwind unsigned long  __STREXB( unsigned char, volatile unsigned char * );
_Pragma("function_effects = no_state, no_read(2), always_returns") __intrinsic __nounwind unsigned long  __STREXH( unsigned short, volatile unsigned short * );
_Pragma("function_effects = no_state, no_read(2), always_returns") __intrinsic __nounwind unsigned long  __STREX ( unsigned long, volatile unsigned long * );
_Pragma("function_effects = no_state, no_read(2), always_returns") __intrinsic __nounwind unsigned long  __STREXD( unsigned long long, volatile unsigned long long * );

__intrinsic __nounwind void __CLREX( void );

__intrinsic __nounwind void __SEV( void );
__intrinsic __nounwind void __WFE( void );
__intrinsic __nounwind void __WFI( void );
__intrinsic __nounwind void __YIELD( void );

__intrinsic __nounwind void __PLI( volatile void const * );
__intrinsic __nounwind void __PLD( volatile void const * );
__intrinsic __nounwind void __PLDW( volatile void const * );

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind   signed long __SSAT     (unsigned long val,
                                      unsigned int __constrange( 1, 32 ) sat );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __USAT     (unsigned long val,
                                      unsigned int __constrange( 0, 31 ) sat );




 
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SEL( unsigned long op1, unsigned long op2 );

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SADD8    (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SADD16   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SSUB8    (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SSUB16   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SADDSUBX (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SSUBADDX (unsigned long pair1, unsigned long pair2);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHADD8   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHADD16  (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHSUB8   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHSUB16  (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHADDSUBX(unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHSUBADDX(unsigned long pair1, unsigned long pair2);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QADD8    (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QADD16   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QSUB8    (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QSUB16   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QADDSUBX (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QSUBADDX (unsigned long pair1, unsigned long pair2);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UADD8    (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UADD16   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __USUB8    (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __USUB16   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UADDSUBX (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __USUBADDX (unsigned long pair1, unsigned long pair2);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHADD8   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHADD16  (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHSUB8   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHSUB16  (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHADDSUBX(unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHSUBADDX(unsigned long pair1, unsigned long pair2);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQADD8   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQADD16  (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQSUB8   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQSUB16  (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQADDSUBX(unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQSUBADDX(unsigned long pair1, unsigned long pair2);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __USAD8(unsigned long x, unsigned long y );
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __USADA8(unsigned long x, unsigned long y,
                                   unsigned long acc );

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SSAT16   (unsigned long pair,
                                      unsigned int __constrange( 1, 16 ) sat );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __USAT16   (unsigned long pair,
                                      unsigned int __constrange( 0, 15 ) sat );

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMUAD (unsigned long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMUSD (unsigned long x, unsigned long y);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMUADX(unsigned long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMUSDX(unsigned long x, unsigned long y);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLAD (unsigned long x, unsigned long y, long sum);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLSD (unsigned long x, unsigned long y, long sum);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLADX(unsigned long x, unsigned long y, long sum);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLSDX(unsigned long x, unsigned long y, long sum);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLALD (unsigned long pair1,
                                 unsigned long pair2,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLALDX(unsigned long pair1,
                                 unsigned long pair2,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLSLD (unsigned long pair1,
                                 unsigned long pair2,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLSLDX(unsigned long pair1,
                                 unsigned long pair2,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __PKHBT(unsigned long x,
                                  unsigned long y,
                                  unsigned __constrange(0,31) count);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __PKHTB(unsigned long x,
                                  unsigned long y,
                                  unsigned __constrange(0,32) count);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLABB(unsigned long x, unsigned long y, long acc);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLABT(unsigned long x, unsigned long y, long acc);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLATB(unsigned long x, unsigned long y, long acc);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLATT(unsigned long x, unsigned long y, long acc);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLAWB(long x, unsigned long y, long acc);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLAWT(long x, unsigned long y, long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMMLA (long x, long y, long acc);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMMLAR(long x, long y, long acc);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMMLS (long x, long y, long acc);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMMLSR(long x, long y, long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMMUL (long x, long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMMULR(long x, long y);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMULBB(unsigned long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMULBT(unsigned long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMULTB(unsigned long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMULTT(unsigned long x, unsigned long y);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMULWB(long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMULWT(long x, unsigned long y);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SXTAB (long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SXTAH (long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UXTAB (unsigned long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UXTAH (unsigned long x, unsigned long y);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long long __UMAAL(unsigned long x,
                                       unsigned long y,
                                       unsigned long a,
                                       unsigned long b);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLALBB(unsigned long x,
                                 unsigned long y,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLALBT(unsigned long x,
                                 unsigned long y,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLALTB(unsigned long x,
                                 unsigned long y,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLALTT(unsigned long x,
                                 unsigned long y,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UXTB16(unsigned long x);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UXTAB16(unsigned long acc, unsigned long x);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SXTB16(unsigned long x);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SXTAB16(unsigned long acc, unsigned long x);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SASX(unsigned long, unsigned long) ;
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SSAX(unsigned long, unsigned long) ;
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHASX(unsigned long, unsigned long) ;
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHSAX(unsigned long, unsigned long) ;
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QASX(unsigned long, unsigned long) ;
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QSAX(unsigned long, unsigned long) ;

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UASX(unsigned long, unsigned long) ;
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __USAX(unsigned long, unsigned long) ;
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHASX(unsigned long, unsigned long) ;
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHSAX(unsigned long, unsigned long) ;
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQASX(unsigned long, unsigned long) ;
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQSAX(unsigned long, unsigned long) ;


 
__intrinsic __nounwind void __DMB(void);
__intrinsic __nounwind void __DSB(void);
__intrinsic __nounwind void __ISB(void);

 
__intrinsic __nounwind unsigned long __TT(unsigned long);
__intrinsic __nounwind unsigned long __TTT(unsigned long);
__intrinsic __nounwind unsigned long __TTA(unsigned long);
__intrinsic __nounwind unsigned long __TTAT(unsigned long);




__intrinsic __nounwind unsigned long __get_LR(void);
__intrinsic __nounwind void __set_LR(unsigned long);

__intrinsic __nounwind unsigned long __get_SP(void);
__intrinsic __nounwind void __set_SP(unsigned long);

#pragma language=restore










#line 140 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\portable\\IAR\\ARM_CM4F\\portmacro.h"



 

 
extern void vPortEnterCritical( void );
extern void vPortExitCritical( void );
extern uint32_t ulPortSetInterruptMask( void );
extern void vPortClearInterruptMask( uint32_t ulNewMask );

#line 157 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\portable\\IAR\\ARM_CM4F\\portmacro.h"
 

 

	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );



 



 


 






 




 
#pragma diag_suppress=Pe191
#pragma diag_suppress=Pa082







#line 322 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\portable.h"






























#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\mpu_wrappers.h"































































 





 
#line 144 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\mpu_wrappers.h"










#line 353 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\portable.h"






 



	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) ;


 
typedef struct HeapRegion
{
	uint8_t *pucStartAddress;
	size_t xSizeInBytes;
} HeapRegion_t;











 
void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions );




 
void *pvPortMalloc( size_t xSize ) ;
void vPortFree( void *pv ) ;
void vPortInitialiseBlocks( void ) ;
size_t xPortGetFreeHeapSize( void ) ;
size_t xPortGetMinimumEverFreeHeapSize( void ) ;




 
BaseType_t xPortStartScheduler( void ) ;





 
void vPortEndScheduler( void ) ;







 











#line 101 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"





 















































































































































#line 256 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"

 


























































 

	
 




	
 




	
 




	
 














	
 




	



 




	


 




	


 




	


 







 





























































































































































































































#line 633 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"






























































































 




#line 748 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"

	
 












#line 15 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\utilities\\xml.c"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\utilities\\xml.h"



struct xml_node {
	char *name;
	char *text;
	char *prefix;
	char *uri;
	char *attr;
	struct xml_node *parent;
	struct xml_node *child;
	struct xml_node *prev;
	struct xml_node *next;
};

struct xml_node_set {
	int count;
	struct xml_node **node;
};

void xml_free(void *buf);
int xml_doc_name(char *doc_buf, int doc_len, char **doc_prefix, char **doc_name, char **doc_uri);
struct xml_node *xml_parse_doc(char *doc_buf, int doc_len, char *prefix, char *doc_name, char *uri);
struct xml_node *xml_parse(char *doc_buf, int doc_len);
struct xml_node *xml_new_element(char *prefix, char *name, char *uri);
struct xml_node *xml_new_text(char *text);
int xml_is_element(struct xml_node *node);
int xml_is_text(struct xml_node *node);
struct xml_node* xml_copy_tree(struct xml_node *root);
void xml_delete_tree(struct xml_node *root);
void xml_add_child(struct xml_node *node, struct xml_node *child);
void xml_clear_child(struct xml_node *node);
struct xml_node* xml_text_child(struct xml_node *node);
void xml_set_text(struct xml_node *node, char *text);
struct xml_node_set* xml_find_element(struct xml_node *root, char *name);
struct xml_node_set* xml_find_path(struct xml_node *root, char *path);
void xml_delete_set(struct xml_node_set *node_set);
char *xml_dump_tree(struct xml_node *root);
char *xml_dump_tree_ex(struct xml_node *root, char *prolog, int new_line, int space);
void xml_set_attribute(struct xml_node *node, char *attr, char *value);
char *xml_get_attribute(struct xml_node *node, char *attr);

#line 16 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\utilities\\xml.c"

static struct xml_node *_xml_new_element(char *prefix, char *name, char *uri, char *attr);

char *xml_strstr(const char *str1, const char *str2) {
	char *a, *b;

	


 

	b = (char *)str2;
	if (*b == 0) {
		return (char *)str1;
	}
	for ( ; *str1 != 0; str1 += 1) {
		if (*str1 != *b) {
			continue;
		}
		a = (char *)str1;
		while (1) {
			if (*b == 0) {
				return (char *)str1;
			}
			if (*a++ != *b++) {
				break;
			}
		}
		b = (char *)str2;
	}
	return (char *) 0;
}

static void *xml_malloc(unsigned int size)
{
	return pvPortMalloc(size);
}

void xml_free(void *buf)
{
	vPortFree(buf);
}

static char *str_strip(char *str, unsigned int str_len)
{ 
	char *front, *rear;
	char *strip = 0;
	int strip_len;

	if(!str || (str_len <= 0))
		return 0;

	for(front = str; front < (str + str_len); front ++)
		if(*front != ' ') break;
	
	if(front == (str + str_len))
		return 0;
	
	for(rear = (str + str_len - 1); rear >= front; rear --)
		if(*rear != ' ') break;

	if(front == rear) {
		strip_len = 1;
		strip = (char *) xml_malloc(strip_len + 1);
		_memcpy(strip, front, strip_len);
		strip[strip_len] = '\0';
	}
	else {
		strip_len = rear + 1 - front;
		strip = (char *) xml_malloc(strip_len + 1);
		_memcpy(strip, front, strip_len);
		strip[strip_len] = '\0';
	}

	return strip;
}





 
static void _parse_tag(char *tag, char **prefix, char **name, char **uri, char **attr)
{
	char *prefix_char, *ns_tag, *ns_front;
	int have_prefix = 0;
	int have_uri = 0;

	prefix_char = _strchr(tag, ':');

	if(prefix_char) {
		char *tag_sep = _strchr(tag, ' ');

		if(!tag_sep)
			have_prefix = 1;
		else if(prefix_char < tag_sep)
			have_prefix = 1;
	}

	if(have_prefix) {
		*prefix = str_strip(tag, prefix_char - tag);
		ns_tag = (char *) xml_malloc(prvStrLen((const unsigned char *) " xmlns:") + prvStrLen((const unsigned char *) *prefix) + 1);
		rtl_sprintf(ns_tag, " xmlns:%s", *prefix);
		ns_front = xml_strstr(tag, ns_tag);
		xml_free(ns_tag);
	}
	else {
		*prefix = 0;
		ns_tag = " xmlns";
		ns_front = xml_strstr(tag, ns_tag);
	}

	if(ns_front)
		have_uri = 1;

	if(have_prefix && have_uri) {
		char *uri_front, *uri_rear, *tag_sep, ns_sep;
		int uri_len;

		tag_sep = _strchr(prefix_char + 1, ' ');
		*name = str_strip(prefix_char + 1, tag_sep - (prefix_char + 1));

		if(attr)
			*attr = str_strip(tag_sep, tag + prvStrLen((const unsigned char *) tag) - tag_sep);

		if(*(_strchr(ns_front, '=') + 1) == '\'')
			ns_sep = '\'';
		else
			ns_sep = '\"';

		uri_front = _strchr(ns_front, ns_sep) + 1;
		uri_rear = _strchr(uri_front, ns_sep);
		uri_len = uri_rear - uri_front;
		*uri = (char *) xml_malloc(uri_len + 1);
		_memcpy(*uri, uri_front, uri_len);
		(*uri)[uri_len] = '\0';
	}
	else if(have_prefix) {
		char *tag_sep;

		*uri = 0;
		tag_sep = _strchr(prefix_char + 1, ' ');

		if(tag_sep) {
			*name = str_strip(prefix_char + 1, tag_sep - (prefix_char + 1));

			if(attr)
				*attr = str_strip(tag_sep, tag + prvStrLen((const unsigned char *) tag) - tag_sep);
		}
		else {
			*name = str_strip(prefix_char + 1, tag + prvStrLen((const unsigned char *) tag) - (prefix_char + 1));

			if(attr)
				*attr = 0;
		}
	}
	else if(have_uri) {
		char *uri_front, *uri_rear, *tag_sep, ns_sep;
		int uri_len;

		tag_sep = _strchr(tag, ' ');
		*name = str_strip(tag, tag_sep - tag);

		if(attr)
			*attr = str_strip(tag_sep, tag + prvStrLen((const unsigned char *) tag) - tag_sep);

		if(*(_strchr(ns_front, '=') + 1) == '\'')
			ns_sep = '\'';
		else
			ns_sep = '\"';

		uri_front = _strchr(ns_front, ns_sep) + 1;
		uri_rear = _strchr(uri_front, ns_sep);
		uri_len = uri_rear - uri_front;
		*uri = (char *) xml_malloc(uri_len + 1);
		_memcpy(*uri, uri_front, uri_len);
		(*uri)[uri_len] = '\0';
	}
	else {
		char *tag_sep;

		*uri = 0;
		tag_sep = _strchr(tag, ' ');

		if(tag_sep) {
			*name = str_strip(tag, tag_sep - tag);

			if(attr)
				*attr = str_strip(tag_sep, tag + prvStrLen((const unsigned char *) tag) - tag_sep);
		}
		else {
			*name = str_strip(tag, prvStrLen((const unsigned char *) tag));

			if(attr)
				*attr = 0;
		}
	}
}

static void parse_tag(char *tag, char **prefix, char **name, char **uri)
{
	_parse_tag(tag, prefix, name, uri, 0);
}

int xml_doc_name(char *doc_buf, int doc_len, char **doc_prefix, char **doc_name, char **doc_uri)
{
	char *xml_buf, *cur_pos, *tag_front, *tag_rear;
	char *start_tag, *end_tag1, *end_tag2;
	int tag_len, ret = -1;

	xml_buf = (char *) xml_malloc(doc_len + 1);
	_memcpy(xml_buf, doc_buf, doc_len);
	xml_buf[doc_len] = '\0';

	cur_pos = xml_buf;

	while(cur_pos < (xml_buf + doc_len)) {
		if((tag_front = _strchr(cur_pos, '<')) != 0) {
			tag_front ++;

			if((tag_rear = _strchr(tag_front, '>')) != 0) {
				char *prefix = 0, *name = 0, *uri = 0;

				
				if(*(tag_rear - 1) == '/') {
					tag_len = tag_rear - 1 - tag_front;
					start_tag = (char *) xml_malloc(tag_len + 1);
					_memcpy(start_tag, tag_front, tag_len);
					start_tag[tag_len] = '\0';
					parse_tag(start_tag, &prefix, &name, &uri);
					xml_free(start_tag);
					*doc_name = name;
					*doc_prefix = prefix;
					*doc_uri = uri;
					ret = 0;
					cur_pos = xml_buf + doc_len;
				}
				
				else {
					tag_len = tag_rear - tag_front;
					start_tag = (char *) xml_malloc(tag_len + 1);
					_memcpy(start_tag, tag_front, tag_len);
					start_tag[tag_len] = '\0';
					parse_tag(start_tag, &prefix, &name, &uri);
					xml_free(start_tag);

					if(prefix) {
						end_tag1 = (char *) xml_malloc(prvStrLen((const unsigned char *) prefix) + prvStrLen((const unsigned char *) name) + 5);
						rtl_sprintf(end_tag1, "</%s:%s>", prefix, name);
						end_tag2 = (char *) xml_malloc(prvStrLen((const unsigned char *) prefix) + prvStrLen((const unsigned char *) name) + 5);
						rtl_sprintf(end_tag2, "</%s:%s ", prefix, name);
					}
					else {
						end_tag1 = (char *) xml_malloc(prvStrLen((const unsigned char *) name) + 4);
						rtl_sprintf(end_tag1, "</%s>", name);
						end_tag2 = (char *) xml_malloc(prvStrLen((const unsigned char *) name) + 4);
						rtl_sprintf(end_tag2, "</%s ", name);
					}

					if(xml_strstr(tag_rear + 1, end_tag1) || xml_strstr(tag_rear + 1, end_tag2)) {
						*doc_name = name;
						*doc_prefix = prefix;
						*doc_uri = uri;
						ret = 0;
						cur_pos = xml_buf + doc_len;
					}
					else {
						xml_free(name);
						if(prefix) xml_free(prefix);
						if(uri)	xml_free(uri);
						cur_pos = tag_rear + 1;
					}

					xml_free(end_tag1);
					xml_free(end_tag2);
				}
			}
			else {
				cur_pos = xml_buf + doc_len;
			}
		}
		else {
			cur_pos = xml_buf + doc_len;
		}
	}

	xml_free(xml_buf);
	
	return ret;
}

struct xml_node *_xml_parse_doc(char *doc_buf, int doc_len, struct xml_node *root)
{
	char *xml_buf, *cur_pos;

	xml_buf = (char *) xml_malloc(doc_len + 1);
	_memcpy(xml_buf, doc_buf, doc_len);
	xml_buf[doc_len] = '\0';

	cur_pos = xml_buf;

	while(cur_pos < (xml_buf + doc_len)) {
		char *tag_front, *tag_rear;
		struct xml_node *node;
		
		if((tag_front = _strchr(cur_pos, '<')) != 0) {
			tag_front ++;

			if((tag_rear = _strchr(tag_front, '>')) != 0) {
				char *doc_front, *doc_rear, *start_tag, *end_tag1, *end_tag2;
				char *prefix = 0, *name = 0, *uri = 0, *attr = 0;
				int tag_len;

				
				if(*(tag_rear - 1) == '/') {
					doc_front = tag_rear + 1;
					tag_len = tag_rear - 1 - tag_front;
					start_tag = (char *) xml_malloc(tag_len + 1);
					_memcpy(start_tag, tag_front, tag_len);
					start_tag[tag_len] = '\0';
					_parse_tag(start_tag, &prefix, &name, &uri, &attr);
					node = _xml_new_element(prefix, name, uri, attr);

					if(root) {
						xml_add_child(root, node);
						cur_pos = doc_front;
					}
					else {
						root = node;
						cur_pos = xml_buf + doc_len;
					}
				}
				
				else {
					doc_front = tag_rear + 1;
					tag_len = tag_rear - tag_front;
					start_tag = (char *) xml_malloc(tag_len + 1);
					_memcpy(start_tag, tag_front, tag_len);
					start_tag[tag_len] = '\0';
					_parse_tag(start_tag, &prefix, &name, &uri, &attr);

					if(prefix) {
						end_tag1 = (char *) xml_malloc(prvStrLen((const unsigned char *) prefix) + prvStrLen((const unsigned char *) name) + 5);
						rtl_sprintf(end_tag1, "</%s:%s>", prefix, name);
						end_tag2 = (char *) xml_malloc(prvStrLen((const unsigned char *) prefix) + prvStrLen((const unsigned char *) name) + 5);
						rtl_sprintf(end_tag2, "</%s:%s ", prefix, name);
					}
					else {
						end_tag1 = (char *) xml_malloc(prvStrLen((const unsigned char *) name) + 4);
						rtl_sprintf(end_tag1, "</%s>", name);
						end_tag2 = (char *) xml_malloc(prvStrLen((const unsigned char *) name) + 4);
						rtl_sprintf(end_tag2, "</%s ", name);
					}

					if(xml_strstr(doc_front, end_tag1))
						doc_rear = xml_strstr(doc_front, end_tag1);
					else if(xml_strstr(doc_front, end_tag2))
						doc_rear = xml_strstr(doc_front, end_tag2);
					else
						doc_rear = 0;

					if(doc_rear) {
						node = _xml_new_element(prefix, name, uri, attr);

						if(root) {
							xml_add_child(root, node);
							_xml_parse_doc(doc_front, doc_rear - doc_front, node);
							cur_pos = _strchr(doc_rear, '>') + 1;
						}
						else {
							root = node;
							_xml_parse_doc(doc_front, doc_rear - doc_front, node);
							cur_pos = xml_buf + doc_len;
						}
					}
					else {
						cur_pos = doc_front;
					}

					xml_free(end_tag1);
					xml_free(end_tag2);
				}

				xml_free(start_tag);
				xml_free(name);
				if(prefix) xml_free(prefix);
				if(uri) xml_free(uri);
				if(attr) xml_free(attr);
			}
			else {
				if(root && !root->child && (prvStrLen((const unsigned char *) cur_pos) > 0)) {
					node = xml_new_text(cur_pos);
					xml_add_child(root, node);
				}

				cur_pos = xml_buf + doc_len;
			}
		}
		else {
			if(root && !root->child && (prvStrLen((const unsigned char *) cur_pos) > 0)) {
				node = xml_new_text(cur_pos);
				xml_add_child(root, node);
			}

			cur_pos = xml_buf + doc_len;
		}
	}

	xml_free(xml_buf);

	return root;
}

 
struct xml_node *xml_parse_doc(char *doc_buf, int doc_len, char *doc_prefix, char *doc_name, char *doc_uri)
{
	struct xml_node *root = 0;
	char *xml_buf, *start_tag, *end_tag, *empty_tag, *front, *rear;

	xml_buf = (char *) xml_malloc(doc_len + 1);
	_memcpy(xml_buf, doc_buf, doc_len);
	xml_buf[doc_len] = '\0';

	if(doc_prefix && doc_uri) {
		start_tag = (char *) xml_malloc(2 * prvStrLen((const unsigned char *) doc_prefix) + prvStrLen((const unsigned char *) doc_name) + prvStrLen((const unsigned char *) doc_uri) + 14);
		rtl_sprintf(start_tag, "<%s:%s xmlns:%s=\"%s\">", doc_prefix, doc_name, doc_prefix, doc_uri);
		empty_tag = (char *) xml_malloc(2 * prvStrLen((const unsigned char *) doc_prefix) + prvStrLen((const unsigned char *) doc_name) + prvStrLen((const unsigned char *) doc_uri) + 15);
		rtl_sprintf(empty_tag, "<%s:%s xmlns:%s=\"%s\"/>", doc_prefix, doc_name, doc_prefix, doc_uri);

	}
	else if(doc_prefix) {
		start_tag = (char *) xml_malloc(prvStrLen((const unsigned char *) doc_prefix) + prvStrLen((const unsigned char *) doc_name) + 4);
		rtl_sprintf(start_tag, "<%s:%s>", doc_prefix, doc_name);
		empty_tag = (char *) xml_malloc(prvStrLen((const unsigned char *) doc_prefix) + prvStrLen((const unsigned char *) doc_name) + 5);
		rtl_sprintf(empty_tag, "<%s:%s/>", doc_prefix, doc_name);
	}
	else if(doc_uri) {
		start_tag = (char *) xml_malloc(prvStrLen((const unsigned char *) doc_name) + prvStrLen((const unsigned char *) doc_uri) + 12);
		rtl_sprintf(start_tag, "<%s xmlns=\"%s\">", doc_name, doc_uri);
		empty_tag = (char *) xml_malloc(prvStrLen((const unsigned char *) doc_name) + prvStrLen((const unsigned char *) doc_uri) + 13);
		rtl_sprintf(empty_tag, "<%s xmlns=\"%s\"/>", doc_name, doc_uri);
	}
	else {
		start_tag = (char *) xml_malloc(prvStrLen((const unsigned char *) doc_name) + 3);
		rtl_sprintf(start_tag, "<%s>", doc_name);
		empty_tag = (char *) xml_malloc(prvStrLen((const unsigned char *) doc_name) + 4);
		rtl_sprintf(empty_tag, "<%s/>", doc_name);
	}

	if(doc_prefix) {
		end_tag = (char *) xml_malloc(prvStrLen((const unsigned char *) doc_prefix) + prvStrLen((const unsigned char *) doc_name) + 5);
		rtl_sprintf(end_tag, "</%s:%s>", doc_prefix, doc_name);
	}
	else {
		end_tag = (char *) xml_malloc(prvStrLen((const unsigned char *) doc_name) + 4);
		rtl_sprintf(end_tag, "</%s>", doc_name);
	}
	
	
	if((front = xml_strstr(xml_buf, start_tag)) != 0) {
		front += prvStrLen((const unsigned char *) start_tag);

		if((rear = xml_strstr(front, end_tag)) != 0) {
			int xml_len = rear - front;

			root = xml_new_element(doc_prefix, doc_name, doc_uri);
			_xml_parse_doc(front, xml_len, root);
		}
	}
	
	else if((front = xml_strstr(xml_buf, empty_tag)) != 0) {
			root = xml_new_element(doc_prefix, doc_name, doc_uri);
	}

	xml_free(start_tag);
	xml_free(end_tag);
	xml_free(empty_tag);
	xml_free(xml_buf);

	return root;
}

struct xml_node *xml_parse(char *doc_buf, int doc_len)
{
	char *proc_inst, *comment, *pos, *prolog_end;

	 
	pos = doc_buf;
	while(pos < (doc_buf + doc_len)) {
		if((proc_inst = xml_strstr(pos, "<?")) != 0) {
			pos = _strchr(proc_inst, '>') + 1;
		}
		else {
			proc_inst = pos;
			break;
		}
	}
	pos = doc_buf;
	while(pos < (doc_buf + doc_len)) {
		if((comment = xml_strstr(pos, "<!")) != 0) {
			pos = _strchr(comment, '>') + 1;
		}
		else {
			comment = pos;
			break;
		}
	}
	if(proc_inst > comment)
		prolog_end = proc_inst;
	else
		prolog_end = comment;

	return _xml_parse_doc(prolog_end, doc_buf + doc_len - prolog_end, 0);
}

static struct xml_node *xml_new_node(void)
{
	struct xml_node *node;

	node = (struct xml_node *) xml_malloc(sizeof(struct xml_node));
	_memset(node, 0, sizeof(struct xml_node));

	return node;
}

static struct xml_node *_xml_new_element(char *prefix, char *name, char *uri, char *attr)
{
	struct xml_node *node;

	node = xml_new_node();
	node->name = (char *) xml_malloc(prvStrLen((const unsigned char *) name) + 1);
	_strcpy(node ->name, name);
	
	if(prefix) {
		node->prefix = (char *) xml_malloc(prvStrLen((const unsigned char *) prefix) + 1);
		_strcpy(node ->prefix, prefix);
	}

	if(uri) {
		node->uri = (char *) xml_malloc(prvStrLen((const unsigned char *) uri) + 1);
		_strcpy(node ->uri, uri);
	}

	if(attr) {
		node->attr = (char *) xml_malloc(prvStrLen((const unsigned char *) attr) + 1);
		_strcpy(node ->attr, attr);
	}

	return node;	
}

struct xml_node *xml_new_element(char *prefix, char *name, char *uri)
{
	struct xml_node *node;
	char *attr = 0;

	if(prefix && uri) {
		attr = (char *) xml_malloc(prvStrLen((const unsigned char *) prefix) + prvStrLen((const unsigned char *) uri) + 10);
		rtl_sprintf(attr, "xmlns:%s=\"%s\"", prefix, uri);
	}
	else if(uri) {
		attr = (char *) xml_malloc(prvStrLen((const unsigned char *) uri) + 9);
		rtl_sprintf(attr, "xmlns=\"%s\"", uri);
	}

	node = _xml_new_element(prefix, name, uri, attr);

	if(attr)
		xml_free(attr);

	return node;
}

struct xml_node *xml_new_text(char *text)
{
	struct xml_node *node;
	char *text_buf;

	text_buf = (char *) xml_malloc(prvStrLen((const unsigned char *) text) + 1);
	_strcpy(text_buf, text);
	node = xml_new_node();
	node->text = text_buf;

	return node;
}

int xml_is_element(struct xml_node *node)
{
	int ret = 0;

	if((node->name != 0) && (node->text == 0))
		ret = 1;

	return ret;
}

int xml_is_text(struct xml_node *node)
{
	int ret = 0;

	if((node->name == 0) && (node->text != 0))
		ret = 1;

	return ret;
}

static void _xml_copy_tree(struct xml_node *root, struct xml_node *parent)
{
	struct xml_node *copy = 0;

	if(xml_is_text(root)) {
		copy = xml_new_text(root->text);
	}
	else if(xml_is_element(root)) {
		struct xml_node *child = root->child;

		copy = _xml_new_element(root->prefix, root->name, root->uri, root->attr);

		while(child) {
			_xml_copy_tree(child, copy);
			child = child->next;
		}
	}

	if(copy)
		xml_add_child(parent, copy);
}

struct xml_node* xml_copy_tree(struct xml_node *root)
{
	struct xml_node *copy = 0;

	if(xml_is_text(root)) {
		copy = xml_new_text(root->text);
	}
	else if(xml_is_element(root)) {
		struct xml_node *child = root->child;

		copy = _xml_new_element(root->prefix, root->name, root->uri, root->attr);

		while(child) {
			_xml_copy_tree(child, copy);
			child = child->next;
		}
	}

	return copy;
}

void xml_delete_tree(struct xml_node *root)
{
	if(root->name)
		xml_free(root->name);

	if(root->text)
		xml_free(root->text);

	if(root->prefix)
		xml_free(root->prefix);

	if(root->uri)
		xml_free(root->uri);

	if(root->attr)
		xml_free(root->attr);

	while(root->child)
		xml_delete_tree(root->child);

	if(root->prev) {
		root->prev->next = root->next;

		if(root->next)
			root->next->prev = root->prev;
	}
	else if(root->parent) {
		root->parent->child = root->next;

		if(root->next)
			root->next->prev = 0;
	}

	xml_free(root);
}

void xml_add_child(struct xml_node *node, struct xml_node *child)
{
	if(xml_is_element(node)) {
		if(node->child) {
			struct xml_node *last_child = node->child;

			while(last_child->next != 0)
				last_child = last_child->next;

			last_child->next = child;
			child->prev = last_child;
		}
		else {
			node->child = child;
		}

		child->parent = node;
	}
}

void xml_clear_child(struct xml_node *node)
{
	while(node->child)
		xml_delete_tree(node->child);
}

struct xml_node* xml_text_child(struct xml_node *node)
{
	struct xml_node *child = 0;

	if(node->child) {
		if(xml_is_text(node->child))
			child = node->child;
	}

	return child;
}

void xml_set_text(struct xml_node *node, char *text)
{
	if(xml_is_text(node)) {
		char *text_buf = (char *) xml_malloc(prvStrLen((const unsigned char *) text) + 1);
		_strcpy(text_buf, text);
		xml_free(node->text);
		node->text = text_buf;
	}
}

static void _xml_element_count(struct xml_node *root, char *name, int *count)
{
	if(xml_is_element(root)) {
		struct xml_node *child = root->child;

		if(prvStrCmp((const unsigned char *) root->name, (const unsigned char *) name) == 0) {
			(*count) ++;
		}

		while(child) {
			_xml_element_count(child, name, count);
			child = child->next;
		}
	}
}

static int xml_element_count(struct xml_node *root, char *name)
{
	int count = 0;

	_xml_element_count(root, name, &count);

	return count;
}

static void _xml_find_element(struct xml_node *root, char *name, struct xml_node_set *node_set)
{
	if(xml_is_element(root)) {
		struct xml_node *child = root->child;

		if(prvStrCmp((const unsigned char *) root->name, (const unsigned char *) name) == 0) {
			node_set->node[node_set->count] = root;
			node_set->count ++;
		}

		while(child) {
			_xml_find_element(child, name, node_set);
			child = child->next;
		}
	}
}

struct xml_node_set* xml_find_element(struct xml_node *root, char *name)
{
	struct xml_node_set *node_set = 0;
	int node_count;

	node_set = (struct xml_node_set *) xml_malloc(sizeof(struct xml_node_set));
	node_set->count = 0;
	node_count = xml_element_count(root, name);

	if(node_count)
		node_set->node = (struct xml_node **) xml_malloc(node_count * sizeof(struct xml_node *));
	else
		node_set->node = 0;

	_xml_find_element(root, name, node_set);

	return node_set;
}

static void _xml_path_count(struct xml_node *root, char *path, int *count)
{
	if(xml_is_element(root)) {
		char *front = 0, *rear = 0;

		if((front = _strchr(path, '/')) != 0) {
			int prefix_len, name_len;
			char *prefix, *name, *prefix_char;
			int prefix_matched = 0, name_matched = 0;

			front ++;
			prefix_char = _strchr(front, ':');

			if((rear = _strchr(front, '/')) != 0) {
				if(prefix_char && (prefix_char < rear)) {
					prefix_len = prefix_char - front;
					prefix = (char *) xml_malloc(prefix_len + 1);
					_memcpy(prefix, front, prefix_len);
					prefix[prefix_len] = '\0';

					name_len = rear - (prefix_char + 1);
					name = (char *) xml_malloc(name_len + 1);
					_memcpy(name, prefix_char + 1, name_len);
					name[name_len] = '\0';
				}
				else {
					prefix = 0;
					name_len = rear - front;
					name = (char *) xml_malloc(name_len + 1);
					_memcpy(name, front, name_len);
					name[name_len] = '\0';
				}

				if((!prefix && !root->prefix) ||
				   (prefix && root->prefix && (prvStrCmp((const unsigned char *) root->prefix, (const unsigned char *) prefix) == 0)))
					prefix_matched = 1;
				else
					prefix_matched = 0;

				if(prvStrCmp((const unsigned char *) root->name, (const unsigned char *) name) == 0)
					name_matched = 1;
				else
					name_matched = 0;

				if(prefix_matched && name_matched) {
					struct xml_node *child = root->child;

					while(child) {
						_xml_path_count(child, rear, count);
						child = child->next;
					}
				}
			}
			else {
				if(prefix_char) {
					prefix_len = prefix_char - front;
					prefix = (char *) xml_malloc(prefix_len + 1);
					_memcpy(prefix, front, prefix_len);
					prefix[prefix_len] = '\0';

					name_len = prvStrLen((const unsigned char *) path) - (prefix_char + 1 - path);
					name = (char *) xml_malloc(name_len + 1);
					_memcpy(name, prefix_char + 1, name_len);
					name[name_len] = '\0';
				}
				else {
					prefix = 0;
					name_len = prvStrLen((const unsigned char *) path) - (front - path);
					name = (char *) xml_malloc(name_len + 1);
					_memcpy(name, front, name_len);
					name[name_len] = '\0';
				}

				if((!prefix && !root->prefix) ||
				   (prefix && root->prefix && (prvStrCmp((const unsigned char *) root->prefix, (const unsigned char *) prefix) == 0)))
					prefix_matched = 1;
				else
					prefix_matched = 0;

				if(prvStrCmp((const unsigned char *) root->name, (const unsigned char *) name) == 0)
					name_matched = 1;
				else
					name_matched = 0;

				if(prefix_matched && name_matched)
					(*count) ++;
			}

			if(prefix) xml_free(prefix);
			xml_free(name);
		}
	}
}

static int xml_path_count(struct xml_node *root, char *path)
{
	int count = 0;

	_xml_path_count(root, path, &count);

	return count;
}

static void _xml_find_path(struct xml_node *root, char *path, struct xml_node_set *node_set)
{
	if(xml_is_element(root)) {
		char *front = 0, *rear = 0;

		if((front = _strchr(path, '/')) != 0) {
			int prefix_len, name_len;
			char *prefix, *name, *prefix_char;
			int prefix_matched = 0, name_matched = 0;

			front ++;
			prefix_char = _strchr(front, ':');

			if((rear = _strchr(front, '/')) != 0) {
				if(prefix_char && (prefix_char < rear)) {
					prefix_len = prefix_char - front;
					prefix = (char *) xml_malloc(prefix_len + 1);
					_memcpy(prefix, front, prefix_len);
					prefix[prefix_len] = '\0';

					name_len = rear - (prefix_char + 1);
					name = (char *) xml_malloc(name_len + 1);
					_memcpy(name, prefix_char + 1, name_len);
					name[name_len] = '\0';
				}
				else {
					prefix = 0;
					name_len = rear - front;
					name = (char *) xml_malloc(name_len + 1);
					_memcpy(name, front, name_len);
					name[name_len] = '\0';
				}

				if((!prefix && !root->prefix) ||
				   (prefix && root->prefix && (prvStrCmp((const unsigned char *) root->prefix, (const unsigned char *) prefix) == 0)))
					prefix_matched = 1;
				else
					prefix_matched = 0;

				if(prvStrCmp((const unsigned char *) root->name, (const unsigned char *) name) == 0)
					name_matched = 1;
				else
					name_matched = 0;

				if(prefix_matched && name_matched) {
					struct xml_node *child = root->child;

					while(child) {
						_xml_find_path(child, rear, node_set);
						child = child->next;
					}
				}
			}
			else {
				if(prefix_char) {
					prefix_len = prefix_char - front;
					prefix = (char *) xml_malloc(prefix_len + 1);
					_memcpy(prefix, front, prefix_len);
					prefix[prefix_len] = '\0';

					name_len = prvStrLen((const unsigned char *) path) - (prefix_char + 1 - path);
					name = (char *) xml_malloc(name_len + 1);
					_memcpy(name, prefix_char + 1, name_len);
					name[name_len] = '\0';
				}
				else {
					prefix = 0;
					name_len = prvStrLen((const unsigned char *) path) - (front - path);
					name = (char *) xml_malloc(name_len + 1);
					_memcpy(name, front, name_len);
					name[name_len] = '\0';
				}

				if((!prefix && !root->prefix) ||
				   (prefix && root->prefix && (prvStrCmp((const unsigned char *) root->prefix, (const unsigned char *) prefix) == 0)))
					prefix_matched = 1;
				else
					prefix_matched = 0;

				if(prvStrCmp((const unsigned char *) root->name, (const unsigned char *) name) == 0)
					name_matched = 1;
				else
					name_matched = 0;

				if(prefix_matched && name_matched) {
					node_set->node[node_set->count] = root;
					node_set->count ++;
				}
			}

			if(prefix) xml_free(prefix);
			xml_free(name);
		}
	}
}

struct xml_node_set* xml_find_path(struct xml_node *root, char *path)
{
	struct xml_node_set *node_set = 0;
	int node_count;

	node_set = (struct xml_node_set *) xml_malloc(sizeof(struct xml_node_set));
	node_set->count = 0;
	node_count = xml_path_count(root, path);

	if(node_count)
		node_set->node = (struct xml_node **) xml_malloc(node_count * sizeof(struct xml_node *));
	else
		node_set->node = 0;

	_xml_find_path(root, path, node_set);

	return node_set;
}

void xml_delete_set(struct xml_node_set *node_set)
{
	if(node_set->node)
		xml_free(node_set->node);

	xml_free(node_set);
}

static int xml_tree_size(struct xml_node *root, int level, int space)
{
	int size = 0;
	int next_level = (level)?(level + 1):0;

	if(xml_is_text(root)) {
		size += prvStrLen((const unsigned char *) root->text);
	}
	else if(xml_is_element(root)) {
		int start_size, end_size;
		struct xml_node *child = root->child;
		int is_element_child = 0;

		if(root->prefix && root->attr)
			 
			start_size = prvStrLen((const unsigned char *) root->prefix) + prvStrLen((const unsigned char *) root->name) + prvStrLen((const unsigned char *) root->attr) + 4;
		else if(root->prefix)
			 
			start_size = prvStrLen((const unsigned char *) root->prefix) + prvStrLen((const unsigned char *) root->name) + 3;
		else if(root->attr)
			 
			start_size = prvStrLen((const unsigned char *) root->name) + prvStrLen((const unsigned char *) root->attr) + 3;
		else
			 
			start_size = prvStrLen((const unsigned char *) root->name) + 2;

		size += start_size;

		while(child) {
			if(((is_element_child = xml_is_element(child)) == 1) && level) {
				size ++;  
				size += (level * space);  
			}

			size += xml_tree_size(child, next_level, space);
			child = child->next;
		}

		if(is_element_child && level) {
			size ++;  
			size += ((level - 1) * space);  
		}

		if(root->prefix)
			 
			end_size = prvStrLen((const unsigned char *) root->prefix) + prvStrLen((const unsigned char *) root->name) + 4;
		else
			 
			end_size = prvStrLen((const unsigned char *) root->name) + 3;

		size += end_size;
	}

	return size;
}

static void _xml_dump_tree(struct xml_node *root, char *xml_buf, int level, int space)
{
	int next_level = (level)?(level + 1):0;

	if(xml_is_text(root)) {
		__rtl_strcat_v1_00(xml_buf, root->text);
	}
	else if(xml_is_element(root)) {
		struct xml_node *child = root->child;
		int is_element_child = 0;

		if(root->prefix && root->attr) {
			__rtl_strcat_v1_00(xml_buf, "<");
			__rtl_strcat_v1_00(xml_buf, root->prefix);
			__rtl_strcat_v1_00(xml_buf, ":");
			__rtl_strcat_v1_00(xml_buf, root->name);
			__rtl_strcat_v1_00(xml_buf, " ");
			__rtl_strcat_v1_00(xml_buf, root->attr);
			__rtl_strcat_v1_00(xml_buf, ">");
		}
		else if(root->prefix) {
			__rtl_strcat_v1_00(xml_buf, "<");
			__rtl_strcat_v1_00(xml_buf, root->prefix);
			__rtl_strcat_v1_00(xml_buf, ":");
			__rtl_strcat_v1_00(xml_buf, root->name);
			__rtl_strcat_v1_00(xml_buf, ">");
		}
		else if(root->attr) {
			__rtl_strcat_v1_00(xml_buf, "<");
			__rtl_strcat_v1_00(xml_buf, root->name);
			__rtl_strcat_v1_00(xml_buf, " ");
			__rtl_strcat_v1_00(xml_buf, root->attr);
			__rtl_strcat_v1_00(xml_buf, ">");
		}
		else {
			__rtl_strcat_v1_00(xml_buf, "<");
			__rtl_strcat_v1_00(xml_buf, root->name);
			__rtl_strcat_v1_00(xml_buf, ">");
		}

		while(child) {
			if(((is_element_child = xml_is_element(child)) == 1) && level) {
				char space_buf[11];
				int i;

				__rtl_strcat_v1_00(xml_buf, "\n");
				_memset(space_buf, ' ', sizeof(space_buf));
				space_buf[space] = '\0';

				for(i = 0; i < level; i ++)
					__rtl_strcat_v1_00(xml_buf, space_buf);
			}

			_xml_dump_tree(child, xml_buf, next_level, space);
			child = child->next;
		}

		if(is_element_child && level) {
			char space_buf[11];
			int i;

			__rtl_strcat_v1_00(xml_buf, "\n");
			_memset(space_buf, ' ', sizeof(space_buf));
			space_buf[space] = '\0';

			for(i = 0; i < (level - 1); i ++)
				__rtl_strcat_v1_00(xml_buf, space_buf);
		}

		if(root->prefix) {
			__rtl_strcat_v1_00(xml_buf, "</");
			__rtl_strcat_v1_00(xml_buf, root->prefix);
			__rtl_strcat_v1_00(xml_buf, ":");
			__rtl_strcat_v1_00(xml_buf, root->name);
			__rtl_strcat_v1_00(xml_buf, ">");
		}
		else {
			__rtl_strcat_v1_00(xml_buf, "</");
			__rtl_strcat_v1_00(xml_buf, root->name);
			__rtl_strcat_v1_00(xml_buf, ">");
		}
	}
}

char *xml_dump_tree(struct xml_node *root)
{
	int xml_size;
	char *xml_buf;

	xml_size = xml_tree_size(root, 0, 0);
	xml_buf = (char *) xml_malloc(xml_size + 1);
	_memset(xml_buf, 0, xml_size + 1);
	_xml_dump_tree(root, xml_buf, 0, 0);

	return xml_buf;
}

char *xml_dump_tree_ex(struct xml_node *root, char *prolog, int new_line, int space)
{
	int xml_size;
	char *xml_buf;

	 
	if(space > 10)
		space = 10;

	xml_size = xml_tree_size(root, 1, space);

	if(prolog && new_line) {
		xml_buf = (char *) xml_malloc(prvStrLen((const unsigned char *) prolog) + xml_size + 2);
		_memset(xml_buf, 0, prvStrLen((const unsigned char *) prolog) + xml_size + 2);
		rtl_sprintf(xml_buf, "%s\n", prolog);
		_xml_dump_tree(root, xml_buf + prvStrLen((const unsigned char *) prolog), new_line, space);
	}
	else if(prolog) {
		xml_buf = (char *) xml_malloc(prvStrLen((const unsigned char *) prolog) + xml_size + 1);
		_memset(xml_buf, 0, prvStrLen((const unsigned char *) prolog) + xml_size + 1);
		_strcpy(xml_buf, prolog);
		_xml_dump_tree(root, xml_buf + prvStrLen((const unsigned char *) prolog), new_line, space);
	}
	else {
		xml_buf = (char *) xml_malloc(xml_size + 1);
		_memset(xml_buf, 0, xml_size + 1);
		_xml_dump_tree(root, xml_buf, new_line, space);
	}

	return xml_buf;
}

void xml_set_attribute(struct xml_node *node, char *attr, char *value)
{
	char *ns_tag, *new_attr;

	if(node->prefix) {
		ns_tag = (char *) xml_malloc(prvStrLen((const unsigned char *) "xmlns:") + prvStrLen((const unsigned char *) node ->prefix) + 1);
		rtl_sprintf(ns_tag, "xmlns:%s", node->prefix);

		if(prvStrCmp((const unsigned char *) ns_tag, (const unsigned char *) attr) == 0) {
			if(node->uri) xml_free(node->uri);
			node->uri = (char *) xml_malloc(prvStrLen((const unsigned char *) value) + 1);
			_strcpy(node ->uri, value);
		}

		xml_free(ns_tag);
	}
	else {
		ns_tag = "xmlns";

		if(prvStrCmp((const unsigned char *) ns_tag, (const unsigned char *) attr) == 0) {
			if(node->uri) xml_free(node->uri);
			node->uri = (char *) xml_malloc(prvStrLen((const unsigned char *) value) + 1);
			_strcpy(node ->uri, value);
		}
	}

	 
	new_attr = (char *) xml_malloc(prvStrLen((const unsigned char *) attr) + prvStrLen((const unsigned char *) value) + 4);

	if(_strchr(value, '\"'))
		rtl_sprintf(new_attr, "%s=\'%s\'", attr, value);
	else
		rtl_sprintf(new_attr, "%s=\"%s\"", attr, value);

	if(node->attr) {
		char *attr1, *attr2, *attr_pos, *all_attr, *attr_p1 = 0, *attr_p2 = 0;
		int attr_existed = 0;

		attr1 = (char *) xml_malloc(prvStrLen((const unsigned char *) attr) + 4);
		rtl_sprintf(attr1, " %s=\'", attr);
		attr2 = (char *) xml_malloc(prvStrLen((const unsigned char *) attr) + 4);
		rtl_sprintf(attr2, " %s=\"", attr);

		if(((attr_pos = xml_strstr(node->attr, attr1)) != 0) ||
		   (xml_strstr(node->attr, attr1 + 1) == node->attr)) {
			attr_existed = 1;

			if(attr_pos) {
				attr_p1 = str_strip(node->attr, attr_pos - node->attr);
				attr_p2 = str_strip(_strchr(attr_pos + prvStrLen((const unsigned char *) attr1), '\'') + 1,
				                    node->attr + prvStrLen((const unsigned char *) node ->attr) - (_strchr(attr_pos + prvStrLen((const unsigned char *) attr1), '\'') + 1));
			}
			else {
				attr_p1 = 0;
				attr_p2 = str_strip(_strchr(node ->attr + prvStrLen((const unsigned char *) attr1) - 1, '\'') + 1,
				                    node->attr + prvStrLen((const unsigned char *) node ->attr) - (_strchr(node ->attr + prvStrLen((const unsigned char *) attr1) - 1, '\'') + 1));
			}
		}
		else if(((attr_pos = xml_strstr(node->attr, attr2)) != 0) ||
		        (xml_strstr(node->attr, attr2 + 1) == node->attr)) {
			attr_existed = 1;

			if(attr_pos) {
				attr_p1 = str_strip(node->attr, attr_pos - node->attr);
				attr_p2 = str_strip(_strchr(attr_pos + prvStrLen((const unsigned char *) attr2), '\"') + 1,
				                    node->attr + prvStrLen((const unsigned char *) node ->attr) - (_strchr(attr_pos + prvStrLen((const unsigned char *) attr2), '\"') + 1));
			}
			else {
				attr_p1 = 0;
				attr_p2 = str_strip(_strchr(node ->attr + prvStrLen((const unsigned char *) attr2) - 1, '\"') + 1,
				                    node->attr + prvStrLen((const unsigned char *) node ->attr) - (_strchr(node ->attr + prvStrLen((const unsigned char *) attr2) - 1, '\"') + 1));
			}
		}

		if(attr_p1 && attr_p2) {
			all_attr = (char *) xml_malloc(prvStrLen((const unsigned char *) attr_p1) + prvStrLen((const unsigned char *) new_attr) + prvStrLen((const unsigned char *) attr_p2) + 3);
			rtl_sprintf(all_attr, "%s %s %s", attr_p1, new_attr, attr_p2);
		}
		else if(attr_p1) {
			all_attr = (char *) xml_malloc(prvStrLen((const unsigned char *) attr_p1) + prvStrLen((const unsigned char *) new_attr) + 2);
			rtl_sprintf(all_attr, "%s %s", attr_p1, new_attr);
		}
		else if(attr_p2) {
			all_attr = (char *) xml_malloc(prvStrLen((const unsigned char *) new_attr) + prvStrLen((const unsigned char *) attr_p2) + 2);
			rtl_sprintf(all_attr, "%s %s", new_attr, attr_p2);
		}
		else if(attr_existed) {
			all_attr = (char *) xml_malloc(prvStrLen((const unsigned char *) new_attr) + 1);
			rtl_sprintf(all_attr, "%s", new_attr);
		}
		else {
			all_attr = (char *) xml_malloc(prvStrLen((const unsigned char *) node ->attr) + prvStrLen((const unsigned char *) new_attr) + 2);
			rtl_sprintf(all_attr, "%s %s", node->attr, new_attr);
		}

		xml_free(attr1);
		xml_free(attr2);
		if(attr_p1) xml_free(attr_p1);
		if(attr_p2) xml_free(attr_p2);
		xml_free(new_attr);
		xml_free(node->attr);
		node->attr = all_attr;
	}
	else {
		node->attr = new_attr;
	}
}

char *xml_get_attribute(struct xml_node *node, char *attr)
{
	char *value = 0;

	if(node->attr) {
		 
		char *value_front, *value_rear, *attr1, *attr2, *attr_pos;
		int value_len;

		attr1 = (char *) xml_malloc(prvStrLen((const unsigned char *) attr) + 4);
		rtl_sprintf(attr1, " %s=\'", attr);
		attr2 = (char *) xml_malloc(prvStrLen((const unsigned char *) attr) + 4);
		rtl_sprintf(attr2, " %s=\"", attr);

		if(((attr_pos = xml_strstr(node->attr, attr1)) != 0) ||
		   (xml_strstr(node->attr, attr1 + 1) == node->attr)) {
			if(attr_pos)
				value_front = attr_pos + prvStrLen((const unsigned char *) attr1);
			else
				value_front = node->attr + prvStrLen((const unsigned char *) attr1) - 1;

			value_rear = _strchr(value_front, '\'');
			value_len = value_rear - value_front;
			value = (char *) xml_malloc(value_len + 1);
			_memcpy(value, value_front, value_len);
			value[value_len] = '\0';
		}
		else if(((attr_pos = xml_strstr(node->attr, attr2)) != 0) ||
		        (xml_strstr(node->attr, attr2 + 1) == node->attr)) {
			if(attr_pos)
				value_front = attr_pos + prvStrLen((const unsigned char *) attr2);
			else
				value_front = node->attr + prvStrLen((const unsigned char *) attr2) - 1;

			value_rear = _strchr(value_front, '\"');
			value_len = value_rear - value_front;
			value = (char *) xml_malloc(value_len + 1);
			_memcpy(value, value_front, value_len);
			value[value_len] = '\0';
		}

		xml_free(attr1);
		xml_free(attr2);
	}

	return value;
}

