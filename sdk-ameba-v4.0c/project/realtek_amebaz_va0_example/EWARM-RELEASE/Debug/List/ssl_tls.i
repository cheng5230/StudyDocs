#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"























 







 

#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl/config.h"



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\section_config.h"







 




#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"


















 




#line 1 "F:\\IAR\\arm\\inc\\c\\stdint.h"
 
 




  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"















 

#line 103 "F:\\IAR\\arm\\inc\\c\\ycheck.h"









#line 11 "F:\\IAR\\arm\\inc\\c\\stdint.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\yvals.h"
 
 





  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 12 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 









  


                 




















 


   
#line 59 "F:\\IAR\\arm\\inc\\c\\yvals.h"





#line 70 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 
#line 1 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"



























 





  #pragma system_include


 
#line 1 "F:\\IAR\\arm\\INC\\c\\DLib_Config_Normal.h"
 
 





  #pragma system_include


 

#line 40 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"
   
#line 47 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"

 
#line 1 "F:\\IAR\\arm\\inc\\c\\DLib_Product.h"




   #pragma system_include







 




 


 



 



 


 




 
#line 45 "F:\\IAR\\arm\\inc\\c\\DLib_Product.h"

 


 


 






 




 


 


 
#line 99 "F:\\IAR\\arm\\inc\\c\\DLib_Product.h"







#line 51 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"











 












 
























 













 























































































































 






 














 
























 


















 
















 








 















 

#line 351 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"













 













 












 














 












 












 












 












 

















 

















 






















 















 








 














 

#line 566 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"












 












 












 












 












 












 












 












 












 










 







 












 







 








 



















































 
















 




#line 812 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"





 

#line 826 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"


   
#line 836 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"

#line 844 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"
  







 









 








 







 






 

#line 899 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"




 







 






 















 

   
#line 943 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"









 

  #pragma language = save 
  #pragma language = extended





  #pragma language = restore










 








 







 
#line 997 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"





 







#line 73 "F:\\IAR\\arm\\inc\\c\\yvals.h"











                 




















 
#line 147 "F:\\IAR\\arm\\inc\\c\\yvals.h"





                 


 




 
 
#line 170 "F:\\IAR\\arm\\inc\\c\\yvals.h"

 




 






 






 
#line 233 "F:\\IAR\\arm\\inc\\c\\yvals.h"











                 
#line 292 "F:\\IAR\\arm\\inc\\c\\yvals.h"









#line 308 "F:\\IAR\\arm\\inc\\c\\yvals.h"








#line 1 "F:\\IAR\\arm\\inc\\c\\xencoding_limits.h"
 
 





  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 12 "F:\\IAR\\arm\\inc\\c\\xencoding_limits.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\yvals.h"
 
 

#line 711 "F:\\IAR\\arm\\inc\\c\\yvals.h"




 
#line 13 "F:\\IAR\\arm\\inc\\c\\xencoding_limits.h"

                                 


#line 24 "F:\\IAR\\arm\\inc\\c\\xencoding_limits.h"




#line 42 "F:\\IAR\\arm\\inc\\c\\xencoding_limits.h"

                                 














#line 317 "F:\\IAR\\arm\\inc\\c\\yvals.h"



                 

                 
#line 335 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 
#line 360 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 
                 




#line 382 "F:\\IAR\\arm\\inc\\c\\yvals.h"


                 

                                 







  #pragma language=save
  #pragma language=extended
  typedef long long _Longlong;
  typedef unsigned long long _ULonglong;
  #pragma language=restore
#line 405 "F:\\IAR\\arm\\inc\\c\\yvals.h"






  typedef unsigned short int _Wchart;
  typedef unsigned short int _Wintt;


#line 424 "F:\\IAR\\arm\\inc\\c\\yvals.h"

#line 432 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 


typedef signed int  _Ptrdifft;
typedef unsigned int     _Sizet;

 


                 







 
  typedef struct __va_list
  {
    char  *_Ap;
  } __va_list;

  typedef __va_list __Va_list;





__intrinsic __nounwind void __iar_Atexit(void (*)(void));



  typedef struct
  {        
    unsigned int _Wchar;
    unsigned int _State;
  } _Mbstatet;
#line 481 "F:\\IAR\\arm\\inc\\c\\yvals.h"










typedef struct
{        

  _Longlong _Off;     



  _Mbstatet _Wstate;
} _Fpost;







                 

#line 1 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"













 





  #pragma system_include






 






















































































 

 



#line 157 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"

  
 

   





  


#line 176 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"





#line 187 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"





  #pragma language=save 
  #pragma language=extended
  __intrinsic __nounwind void __iar_dlib_perthread_initialize(void  *);
  __intrinsic __nounwind void  *__iar_dlib_perthread_allocate(void);
  __intrinsic __nounwind void __iar_dlib_perthread_destroy(void);
  __intrinsic __nounwind void __iar_dlib_perthread_deallocate(void  *);









  #pragma segment = "__DLIB_PERTHREAD" 
  #pragma segment = "__DLIB_PERTHREAD_init" 


























#line 242 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"

   
  void  *__iar_dlib_perthread_access(void  *);
  #pragma language=restore



























     
  









   






  





  
  typedef void *__iar_Rmtx;
  

  
  __intrinsic __nounwind void __iar_system_Mtxinit(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_system_Mtxdst(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_system_Mtxlock(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_system_Mtxunlock(__iar_Rmtx *m);

  __intrinsic __nounwind void __iar_file_Mtxinit(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_file_Mtxdst(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_file_Mtxlock(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_file_Mtxunlock(__iar_Rmtx *m);

  
 
  __intrinsic __nounwind void __iar_clearlocks(void);


#line 323 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"

  





  

#line 341 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"

  typedef unsigned _Once_t;



  













#line 510 "F:\\IAR\\arm\\inc\\c\\yvals.h"

#line 520 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 
#line 528 "F:\\IAR\\arm\\inc\\c\\yvals.h"


                 

  
  
    
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock_Locale(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock_Malloc(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock_Stream(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock_Debug(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock_StaticGuard(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock(unsigned int);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock_Locale(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock_Malloc(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock_Stream(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock_Debug(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock_StaticGuard(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock(unsigned int);

  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Initdynamicfilelock(__iar_Rmtx *);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Dstdynamicfilelock(__iar_Rmtx *);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Lockdynamicfilelock(__iar_Rmtx *);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlockdynamicfilelock(__iar_Rmtx *);
  
  
#line 568 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 
#line 576 "F:\\IAR\\arm\\inc\\c\\yvals.h"

#line 694 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 





#line 709 "F:\\IAR\\arm\\inc\\c\\yvals.h"






 
#line 12 "F:\\IAR\\arm\\inc\\c\\stdint.h"


 

  typedef signed char   int8_t;
  typedef unsigned char uint8_t;



  typedef signed short int   int16_t;
  typedef unsigned short int uint16_t;



  typedef signed int   int32_t;
  typedef unsigned int uint32_t;



  #pragma language=save
  #pragma language=extended
  typedef signed long long int   int64_t;
  typedef unsigned long long int uint64_t;
  #pragma language=restore



 
typedef signed char   int_least8_t;
typedef unsigned char uint_least8_t;

typedef signed short int   int_least16_t;
typedef unsigned short int uint_least16_t;

typedef signed int   int_least32_t;
typedef unsigned int uint_least32_t;

 

  #pragma language=save
  #pragma language=extended
  typedef signed long long int int_least64_t;
  #pragma language=restore


  #pragma language=save
  #pragma language=extended
  typedef unsigned long long int uint_least64_t;
  #pragma language=restore




 
typedef signed int   int_fast8_t;
typedef unsigned int uint_fast8_t;

typedef signed int   int_fast16_t;
typedef unsigned int uint_fast16_t;

typedef signed int   int_fast32_t;
typedef unsigned int uint_fast32_t;


  #pragma language=save
  #pragma language=extended
  typedef signed long long int int_fast64_t;
  #pragma language=restore


  #pragma language=save
  #pragma language=extended
  typedef unsigned long long int uint_fast64_t;
  #pragma language=restore


 
#pragma language=save
#pragma language=extended
typedef signed long long int   intmax_t;
typedef unsigned long long int uintmax_t;
#pragma language=restore


 
typedef signed long int   intptr_t;
typedef unsigned long int uintptr_t;

 



typedef int __data_intptr_t; typedef unsigned int __data_uintptr_t;


 






























































































 

































#line 258 "F:\\IAR\\arm\\inc\\c\\stdint.h"




 
#line 25 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"






















		













typedef unsigned int	        uint;
typedef	signed int		        sint;


typedef signed long long        __int64_t;
typedef unsigned long long      __uint64_t;


#line 77 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"





typedef unsigned char           BOOL;


typedef unsigned char           bool;








typedef struct { volatile int counter; } atomic_t;

typedef enum _RTK_STATUS_ {
    _EXIT_SUCCESS = 0,
    _EXIT_FAILURE = 1
}RTK_STATUS, *PRTK_STATUS;

#line 107 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"


typedef void * PVOID;


typedef     uint32_t dma_addr_t;

typedef     void (*proc_t)(void*);

typedef     unsigned int __kernel_size_t;
typedef     int __kernel_ssize_t;

typedef 	__kernel_size_t	SIZE_T;	
typedef	    __kernel_ssize_t	SSIZE_T;

























#line 178 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"







#line 201 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"











 




#line 228 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"

#line 241 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"







 




















































#line 307 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"






#line 319 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"





#line 331 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"

		


		


	


	
#line 348 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"
	
#line 355 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"

#line 363 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"
			









#line 379 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"

#line 386 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"

#line 394 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"








#line 411 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"




typedef unsigned char	BOOLEAN,*PBOOLEAN,boolean;







 








								
								
								
								
								

								
								
#line 449 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"












#line 480 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"







typedef struct _RAM_START_FUNCTION_ {
    void (*RamStartFun) (void);
	void (*RamWakeupFun) (void);
}RAM_START_FUNCTION, *PRAM_START_FUNCTION;

typedef struct _RAM_FUNCTION_START_TABLE_ {
	void (*RamStartFun) (void);
	void (*RamWakeupFun) (void);
	void (*RamPatchFun0) (void);
	void (*RamPatchFun1) (void);
	void (*RamPatchFun2) (void);
	void (*FlashStartFun) (void);
}RAM_FUNCTION_START_TABLE, *PRAM_FUNCTION_START_TABLE;

#line 14 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\section_config.h"

#line 21 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\section_config.h"






















        

















    






#line 84 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\section_config.h"





























        





        

#line 127 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\section_config.h"





 



#line 6 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl/config.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\ssl\\ssl_ram_map\\rom\\rom_ssl_ram_map.h"





struct _rom_ssl_ram_map {
	 
	void *(*ssl_malloc)(unsigned int sz);
	void (*ssl_free)(void *);
	int (*ssl_printf)(const char *, ...);

	
	int (*hw_crypto_aes_ecb_init)(const uint8_t* key, const uint32_t keylen);
	int (*hw_crypto_aes_ecb_decrypt)(
		const uint8_t* message, 	const uint32_t msglen, 
		const uint8_t* iv, 		const uint32_t ivlen, 
		uint8_t* pResult);
	int (*hw_crypto_aes_ecb_encrypt)(
		const uint8_t* message, 	const uint32_t msglen, 
		const uint8_t* iv, 		const uint32_t ivlen, 
		uint8_t* pResult);
	int (*hw_crypto_aes_cbc_init)(const uint8_t* key, 	const uint32_t keylen);
	int (*hw_crypto_aes_cbc_decrypt)(
		const uint8_t* message, 	const uint32_t msglen, 
		const uint8_t* iv, 		const uint32_t ivlen, 
		uint8_t* pResult);
	int (*hw_crypto_aes_cbc_encrypt)(
		const uint8_t* message, 	const uint32_t msglen, 
		const uint8_t* iv, 		const uint32_t ivlen, 
		uint8_t* pResult);

	
	int (*hw_crypto_des_cbc_init)(const uint8_t* key, const uint32_t keylen);
	int (*hw_crypto_des_cbc_decrypt)(
		const uint8_t* message, 	const uint32_t msglen, 
		const uint8_t* iv, 		const uint32_t ivlen, 
		uint8_t* pResult);
	int (*hw_crypto_des_cbc_encrypt)(
		const uint8_t* message, 	const uint32_t msglen, 
		const uint8_t* iv, 		const uint32_t ivlen, 
		uint8_t* pResult);
	int (*hw_crypto_3des_cbc_init)(const uint8_t* key, const uint32_t keylen);
	int (*hw_crypto_3des_cbc_decrypt)(
		const uint8_t* message, 	const uint32_t msglen, 
		const uint8_t* iv, 		const uint32_t ivlen, 
		uint8_t* pResult);
	int (*hw_crypto_3des_cbc_encrypt)(
		const uint8_t* message, 	const uint32_t msglen, 
		const uint8_t* iv, 		const uint32_t ivlen, 
		uint8_t* pResult);

	 
	uint32_t use_hw_crypto_func;
};

extern struct _rom_ssl_ram_map rom_ssl_ram_map;

#line 7 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl/config.h"





#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform\\platform_stdlib.h"





 









#line 22 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform\\platform_stdlib.h"

#line 150 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform\\platform_stdlib.h"

#line 1 "F:\\IAR\\arm\\inc\\c\\stdio.h"
 
 




  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 11 "F:\\IAR\\arm\\inc\\c\\stdio.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\ysizet.h"
 
 





  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 12 "F:\\IAR\\arm\\inc\\c\\ysizet.h"



                 




typedef _Sizet size_t;




typedef unsigned int __data_size_t;











#line 13 "F:\\IAR\\arm\\inc\\c\\stdio.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\ystdio.h"
 
 




  #pragma system_include







#line 58 "F:\\IAR\\arm\\inc\\c\\ystdio.h"
  

 

__intrinsic __nounwind int remove(const char *);
__intrinsic __nounwind int rename(const char *, const char *);














 
#line 14 "F:\\IAR\\arm\\inc\\c\\stdio.h"



 
#pragma rtmodel="__dlib_file_descriptor","0"

                 








#line 66 "F:\\IAR\\arm\\inc\\c\\stdio.h"

#line 88 "F:\\IAR\\arm\\inc\\c\\stdio.h"

#line 99 "F:\\IAR\\arm\\inc\\c\\stdio.h"










                 
typedef _Fpost fpos_t;

                 
#pragma language=save
#pragma language=extended

#line 125 "F:\\IAR\\arm\\inc\\c\\stdio.h"

#line 177 "F:\\IAR\\arm\\inc\\c\\stdio.h"


              
_Pragma("function_effects = no_read(1), always_returns")    __intrinsic __nounwind char * __gets(char *, int);
_Pragma("function_effects = no_read(1), always_returns")    __intrinsic __nounwind char * gets(char *);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind void perror(const char *);
_Pragma("function_effects = no_write(1), always_returns")    _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int printf(const char *, ...);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind int puts(const char *);
_Pragma("function_effects = no_write(1), always_returns")    _Pragma("__scanf_args") _Pragma("library_default_requirements _Scanf = unknown")  __intrinsic __nounwind int scanf(const char *, ...);
_Pragma("function_effects = no_read(1), no_write(2), always_returns") _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int sprintf(char *, 
                                                 const char *, ...);
_Pragma("function_effects = no_write(1,2), always_returns") _Pragma("__scanf_args") _Pragma("library_default_requirements _Scanf = unknown")  __intrinsic __nounwind int sscanf(const char *, 
                                                const char *, ...);
             __intrinsic __nounwind char * tmpnam(char *);
              
             __intrinsic __nounwind int __ungetchar(int);
_Pragma("function_effects = no_write(1), always_returns")    _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int vprintf(const char *,
                                                 __Va_list);

  _Pragma("function_effects = no_write(1), always_returns")    _Pragma("__scanf_args") _Pragma("library_default_requirements _Scanf = unknown")  __intrinsic __nounwind int vscanf(const char *, 
                                                  __Va_list);
  _Pragma("function_effects = no_write(1,2), always_returns") _Pragma("__scanf_args") _Pragma("library_default_requirements _Scanf = unknown")  __intrinsic __nounwind int vsscanf(const char *, 
                                                   const char *, 
                                                   __Va_list);

_Pragma("function_effects = no_read(1), no_write(2), always_returns")  _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int vsprintf(char *, 
                                                   const char *,
                                                   __Va_list);
               
_Pragma("function_effects = no_write(1), always_returns")      __intrinsic __nounwind size_t __write_array(const void *, size_t, size_t);

  _Pragma("function_effects = no_read(1), no_write(3), always_returns") _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int snprintf(char *, size_t, 
                                                    const char *, ...);
  _Pragma("function_effects = no_read(1), no_write(3), always_returns") _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int vsnprintf(char *, size_t,
                                                     const char *, 
                                                     __Va_list);


              __intrinsic __nounwind int getchar(void);
              __intrinsic __nounwind int putchar(int);



#pragma language=restore

#line 238 "F:\\IAR\\arm\\inc\\c\\stdio.h"




#line 292 "F:\\IAR\\arm\\inc\\c\\stdio.h"




 
#line 162 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform\\platform_stdlib.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\stdlib.h"
 
 





  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 12 "F:\\IAR\\arm\\inc\\c\\stdlib.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\ysizet.h"
 
 

#line 30 "F:\\IAR\\arm\\inc\\c\\ysizet.h"







#line 14 "F:\\IAR\\arm\\inc\\c\\stdlib.h"


 
#pragma rtmodel="__dlib_full_locale_support",   "0"





extern int __aeabi_MB_CUR_MAX(void);


#line 34 "F:\\IAR\\arm\\inc\\c\\stdlib.h"





                 













                 


  typedef _Wchart wchar_t;


typedef struct
{        
  int quot;
  int rem;
} div_t;

typedef struct
{        
  long quot;
  long rem;
} ldiv_t;



    #pragma language=save
    #pragma language=extended
    typedef struct
    {      
      _Longlong quot;
      _Longlong rem;
    } lldiv_t;
    #pragma language=restore



                 
  
__intrinsic __nounwind int atexit(void (*)(void));

  __intrinsic __noreturn __nounwind void _Exit(int) ;

__intrinsic __noreturn __nounwind void exit(int) ;
__intrinsic __nounwind char * getenv(const char *);
__intrinsic __nounwind int system(const char *);



             __intrinsic __noreturn __nounwind void abort(void) ;
_Pragma("function_effects = no_state, always_returns")     __intrinsic __nounwind int abs(int);
             __intrinsic __nounwind void * calloc(size_t, size_t);
_Pragma("function_effects = no_state, always_returns")     __intrinsic __nounwind div_t div(int, int);
             __intrinsic __nounwind void free(void *);
_Pragma("function_effects = no_state, always_returns")     __intrinsic __nounwind long labs(long);
_Pragma("function_effects = no_state, always_returns")     __intrinsic __nounwind ldiv_t ldiv(long, long);


    #pragma language=save
    #pragma language=extended
    _Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long llabs(long long);
    _Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind lldiv_t lldiv(long long, long long);
    #pragma language=restore


             __intrinsic __nounwind void * malloc(size_t);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind int mblen(const char *, size_t);
_Pragma("function_effects = no_read(1), no_write(2), always_returns") __intrinsic __nounwind size_t mbstowcs(wchar_t *, 
                                          const char *, size_t);
_Pragma("function_effects = no_read(1), no_write(2), always_returns") __intrinsic __nounwind int mbtowc(wchar_t *, const char *, 
                                     size_t);
             __intrinsic __nounwind int rand(void);
             __intrinsic __nounwind void srand(unsigned int);
             __intrinsic __nounwind void * realloc(void *, size_t);
_Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long strtol(const char *, 
                                      char **, int);
_Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind unsigned long strtoul(const char *, char **, int);
_Pragma("function_effects = no_read(1), no_write(2), always_returns") __intrinsic __nounwind size_t wcstombs(char *, 
                                          const wchar_t *, size_t);
_Pragma("function_effects = no_read(1), always_returns")    __intrinsic __nounwind int wctomb(char *, wchar_t);


    #pragma language=save
    #pragma language=extended
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long long strtoll(const char *, char **, int);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind unsigned long long strtoull(const char *, 
                                                          char **, int);
    #pragma language=restore





#line 188 "F:\\IAR\\arm\\inc\\c\\stdlib.h"



    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind unsigned long __iar_Stoul(const char *, char **, 
                                                        int);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind float         __iar_Stof(const char *, char **, long);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind double        __iar_Stod(const char *, char **, long);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long double   __iar_Stold(const char *, char **, 
                                                          long);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long          __iar_Stolx(const char *, char **, int, 
                                                        int *);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind unsigned long __iar_Stoulx(const char *, char **,
                                                         int, int *);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind float         __iar_Stofx(const char *, char **, 
                                                        long, int *);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind double        __iar_Stodx(const char *, char **, 
                                                        long, int *);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long double   __iar_Stoldx(const char *, char **, 
                                                         long, int *);

      #pragma language=save
      #pragma language=extended
      _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind _Longlong   __iar_Stoll(const char *, char **, 
                                                        int);
      _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind _ULonglong   __iar_Stoull(const char *, char **, 
                                                          int);
      _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind _Longlong    __iar_Stollx(const char *, char **, 
                                                          int, int *);
      _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind _ULonglong   __iar_Stoullx(const char *, char **, 
                                                           int, int *);
      #pragma language=restore








typedef int _Cmpfun(const void *, const void *);

_Pragma("function_effects = no_write(1,2), always_returns") __intrinsic void * bsearch(const void *, 
                                                   const void *, size_t,
                                                   size_t, _Cmpfun *);
             __intrinsic void qsort(void *, size_t, size_t, 
                                               _Cmpfun *);
             __intrinsic void __qsortbbl(void *, size_t, size_t, 
                                                    _Cmpfun *);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind double atof(const char *);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind int atoi(const char *);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind long atol(const char *);


    #pragma language=save
    #pragma language=extended
    _Pragma("function_effects = no_write(1), always_returns") __intrinsic __nounwind long long atoll(const char *);
    #pragma language=restore

  _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind float strtof(const char *, 
                                         char **);
  _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long double strtold(const char *, char **);

_Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind double strtod(const char *, 
                                        char **);
                                        

                                        
               __intrinsic __nounwind size_t __iar_Mbcurmax(void);

  _Pragma("function_effects = no_state, always_returns")     __intrinsic __nounwind int __iar_DLib_library_version(void);

  


#line 276 "F:\\IAR\\arm\\inc\\c\\stdlib.h"



  
  typedef void _Atexfun(void);
  
#line 304 "F:\\IAR\\arm\\inc\\c\\stdlib.h"


                 
    #pragma inline=no_body
    double atof(const char *_S)
    {       
      return (__iar_Stod(_S, 0, 0));
    }

    #pragma inline=no_body
    int atoi(const char *_S)
    {       
      return ((int)__iar_Stoul(_S, 0, 10));
    }

    #pragma inline=no_body
    long atol(const char *_S)
    {       
      return ((long)__iar_Stoul(_S, 0, 10));
    }



        #pragma language=save
        #pragma language=extended
        #pragma inline=no_body
        long long atoll(const char *_S)
        {       



            return ((long long)__iar_Stoull(_S, 0, 10));

        }
        #pragma language=restore



    #pragma inline=no_body
    double strtod(const char * _S, char ** _Endptr)
    {       
      return (__iar_Stod(_S, _Endptr, 0));
    }


      #pragma inline=no_body
      float strtof(const char * _S, char ** _Endptr)
      {       
        return (__iar_Stof(_S, _Endptr, 0));
      }

      #pragma inline=no_body
      long double strtold(const char * _S, char ** _Endptr)
      {       
        return (__iar_Stold(_S, _Endptr, 0));
      }


    #pragma inline=no_body
    long strtol(const char * _S, char ** _Endptr, 
                int _Base)
    {       
      return (__iar_Stolx(_S, _Endptr, _Base, 0));
    }

    #pragma inline=no_body
    unsigned long strtoul(const char * _S, char ** _Endptr, 
                          int _Base)
    {       
      return (__iar_Stoul(_S, _Endptr, _Base));
    }



        #pragma language=save
        #pragma language=extended
        #pragma inline=no_body
        long long strtoll(const char * _S, char ** _Endptr,
                          int _Base)
        {       



            return (__iar_Stoll(_S, _Endptr, _Base));

        }

        #pragma inline=no_body
        unsigned long long strtoull(const char * _S, 
                                    char ** _Endptr, int _Base)
        {       



            return (__iar_Stoull(_S, _Endptr, _Base));

        }
        #pragma language=restore





  #pragma inline=no_body
  int abs(int i)
  {       
    return (i < 0 ? -i : i);
  }

  #pragma inline=no_body
  long labs(long i)
  {       
    return (i < 0 ? -i : i);
  }



      #pragma language=save
      #pragma language=extended
      #pragma inline=no_body
      long long llabs(long long i)
      {       
        return (i < 0 ? -i : i);
      }
      #pragma language=restore



#line 465 "F:\\IAR\\arm\\inc\\c\\stdlib.h"




#line 494 "F:\\IAR\\arm\\inc\\c\\stdlib.h"




 
#line 163 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform\\platform_stdlib.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\string.h"
 
 




  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 11 "F:\\IAR\\arm\\inc\\c\\string.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\ysizet.h"
 
 

#line 30 "F:\\IAR\\arm\\inc\\c\\ysizet.h"







#line 13 "F:\\IAR\\arm\\inc\\c\\string.h"

#line 1 "F:\\IAR\\arm\\inc\\c\\DLib_Product_string.h"








 





  #pragma system_include




  
  

  





 


  




 



#line 47 "F:\\IAR\\arm\\inc\\c\\DLib_Product_string.h"



  


 


  #pragma inline=forced_no_body
  __intrinsic __nounwind void * memcpy(void * _D, const void * _S, size_t _N)
  {
    __aeabi_memcpy(_D, _S, _N);
    return _D;
  }


  #pragma inline=forced_no_body
  __intrinsic __nounwind void * memmove(void * _D, const void * _S, size_t _N)
  {
    __aeabi_memmove(_D, _S, _N);
    return _D;
  }


  #pragma inline=forced_no_body
  __intrinsic __nounwind void * memset(void * _D, int _C, size_t _N)
  {
    __aeabi_memset(_D, _N, _C);
    return _D;
  }

  
  



#line 16 "F:\\IAR\\arm\\inc\\c\\string.h"



                 




                 

_Pragma("function_effects = no_state, no_write(1,2), always_returns")   __intrinsic __nounwind int        memcmp(const void *, const void *,
                                                size_t);
_Pragma("function_effects = no_state, no_read(1), no_write(2), returns 1, always_returns") __intrinsic __nounwind void *     memcpy(void *, 
                                                const void *, size_t);
_Pragma("function_effects = no_state, no_read(1), no_write(2), returns 1, always_returns") __intrinsic __nounwind void *     memmove(void *, const void *, size_t);
_Pragma("function_effects = no_state, no_read(1), returns 1, always_returns")    __intrinsic __nounwind void *     memset(void *, int, size_t);
_Pragma("function_effects = no_state, no_write(2), returns 1, always_returns")    __intrinsic __nounwind char *     strcat(char *, 
                                                const char *);
_Pragma("function_effects = no_state, no_write(1,2), always_returns")   __intrinsic __nounwind int        strcmp(const char *, const char *);
_Pragma("function_effects = no_write(1,2), always_returns")     __intrinsic __nounwind int        strcoll(const char *, const char *);
_Pragma("function_effects = no_state, no_read(1), no_write(2), returns 1, always_returns") __intrinsic __nounwind char *     strcpy(char *, 
                                                const char *);
_Pragma("function_effects = no_state, no_write(1,2), always_returns")   __intrinsic __nounwind size_t     strcspn(const char *, const char *);
                 __intrinsic __nounwind char *     strerror(int);
_Pragma("function_effects = no_state, no_write(1), always_returns")      __intrinsic __nounwind size_t     strlen(const char *);
_Pragma("function_effects = no_state, no_write(2), returns 1, always_returns")    __intrinsic __nounwind char *     strncat(char *, 
                                                 const char *, size_t);
_Pragma("function_effects = no_state, no_write(1,2), always_returns")   __intrinsic __nounwind int        strncmp(const char *, const char *, 
                                                 size_t);
_Pragma("function_effects = no_state, no_read(1), no_write(2), returns 1, always_returns") __intrinsic __nounwind char *     strncpy(char *, 
                                                 const char *, size_t);
_Pragma("function_effects = no_state, no_write(1,2), always_returns")   __intrinsic __nounwind size_t     strspn(const char *, const char *);
_Pragma("function_effects = no_write(2), always_returns")        __intrinsic __nounwind char *     strtok(char *, 
                                                const char *);
_Pragma("function_effects = no_write(2), always_returns")        __intrinsic __nounwind size_t     strxfrm(char *, 
                                                 const char *, size_t);


  _Pragma("function_effects = no_write(1), always_returns")      __intrinsic __nounwind char *   strdup(const char *);
  _Pragma("function_effects = no_write(1,2), always_returns")   __intrinsic __nounwind int      strcasecmp(const char *, const char *);
  _Pragma("function_effects = no_write(1,2), always_returns")   __intrinsic __nounwind int      strncasecmp(const char *, const char *, 
                                                   size_t);
  _Pragma("function_effects = no_state, no_write(2), always_returns")    __intrinsic __nounwind char *   strtok_r(char *, const char *, char **);
  _Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind size_t   strnlen(char const *, size_t);




#line 81 "F:\\IAR\\arm\\inc\\c\\string.h"
  _Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind void *memchr(const void *_S, int _C, size_t _N);
  _Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind char *strchr(const char *_S, int _C);
  _Pragma("function_effects = no_state, no_write(1,2), always_returns") __intrinsic __nounwind char *strpbrk(const char *_S, const char *_P);
  _Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind char *strrchr(const char *_S, int _C);
  _Pragma("function_effects = no_state, no_write(1,2), always_returns") __intrinsic __nounwind char *strstr(const char *_S, const char *_P);




                 


                 

_Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind void *__iar_Memchr(const void *, int, size_t);
_Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind char *__iar_Strchr(const char *, int);
               __intrinsic __nounwind char *__iar_Strerror(int, char *);
_Pragma("function_effects = no_state, no_write(1,2), always_returns") __intrinsic __nounwind char *__iar_Strpbrk(const char *, const char *);
_Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind char *__iar_Strrchr(const char *, int);
_Pragma("function_effects = no_state, no_write(1,2), always_returns") __intrinsic __nounwind char *__iar_Strstr(const char *, const char *);


                 
#line 168 "F:\\IAR\\arm\\inc\\c\\string.h"
                 
    #pragma inline
    void *memchr(const void *_S, int _C, size_t _N)
    {
      return (__iar_Memchr(_S, _C, _N));
    }

    #pragma inline
    char *strchr(const char *_S, int _C)
    {
      return (__iar_Strchr(_S, _C));
    }

    #pragma inline
    char *strpbrk(const char *_S, const char *_P)
    {
      return (__iar_Strpbrk(_S, _P));
    }

    #pragma inline
    char *strrchr(const char *_S, int _C)
    {
      return (__iar_Strrchr(_S, _C));
    }

    #pragma inline
    char *strstr(const char *_S, const char *_P)
    {
      return (__iar_Strstr(_S, _P));
    }


  #pragma inline
  char *strerror(int _Err)
  {
    return (__iar_Strerror(_Err, 0));
  }

#line 451 "F:\\IAR\\arm\\inc\\c\\string.h"






#line 479 "F:\\IAR\\arm\\inc\\c\\string.h"




 
#line 164 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform\\platform_stdlib.h"
	#include <stdarg.h>  
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"







 




#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"


 




 



 








 
#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 42 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 52 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 62 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 





 





 





 





 





 





 





 





 





 





 




 





 







 





 






 





 




 




 




 







 




 




 




 






 




 




 




 




 








 
#line 14 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"


#line 1 "F:\\IAR\\arm\\inc\\c\\stddef.h"
 
 




  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 11 "F:\\IAR\\arm\\inc\\c\\stddef.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\ysizet.h"
 
 

#line 30 "F:\\IAR\\arm\\inc\\c\\ysizet.h"







#line 13 "F:\\IAR\\arm\\inc\\c\\stddef.h"



                 








                 




  typedef _Ptrdifft ptrdiff_t;









#line 49 "F:\\IAR\\arm\\inc\\c\\stddef.h"





 
#line 17 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\app\\monitor\\include\\rtl_trace.h"















 







 




 



 

 
typedef enum {
	MODULE_OS		= 0,   
	MODULE_BOOT		= 1,   
	MODULE_GDMA	= 2,   
	MODULE_GPIO		= 3,   
	MODULE_TIMER	= 4,   
	MODULE_I2C		= 5,   
	MODULE_I2S		= 6,   
	MODULE_PWM		= 7,   
	MODULE_SDIO		= 8,   
	MODULE_SPI		= 9,   
	MODULE_FLASH	= 10,  
	MODULE_UART		= 11,  
	MODULE_USOC		= 12,  
	MODULE_IPSEC	= 13,  
	MODULE_ADC		= 14,  
	MODULE_EFUSE	= 15,  
	MODULE_MONIT	= 16,  
	MODULE_MISC		= 17,  

	MODULE_NUMs            
} MODULE_DEFINE;

 
typedef enum {
	LEVEL_ERROR	= 0,  
	LEVEL_WARN	= 1,  
	LEVEL_INFO		= 2,  
	LEVEL_TRACE	= 3,  
	LEVEL_NUMs		= 4   
} LEVEL_DEFINE;


 



 

 
 
extern uint32_t ConfigDebug[];
 


















 
void LOG_MASK_MODULE(uint32_t module, uint32_t level, uint32_t new_status);
void LOG_MASK(uint32_t config[]);
void LOG_PRINTF(uint32_t module, uint32_t level, uint32_t line, const char*fmt, ...);



 
#line 120 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\app\\monitor\\include\\rtl_trace.h"



 



 



 


 
#line 18 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"

extern uint32_t ConfigDebugClose;
extern uint32_t ConfigDebugErr;
extern uint32_t ConfigDebugInfo;
extern uint32_t ConfigDebugWarn;

extern uint32_t CfgSysDebugErr;
extern uint32_t CfgSysDebugInfo;
extern uint32_t CfgSysDebugWarn;










#line 57 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"

extern  uint32_t DiagPrintf(const char *fmt, ...);
uint32_t DiagSPrintf(uint8_t *buf, const char *fmt, ...);
int prvDiagPrintf(const char *fmt, ...);
int prvDiagSPrintf(char *buf, const char *fmt, ...);






























#line 100 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"








































#line 153 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"

#line 161 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"

typedef enum {
	DBG_CFG_ERR=0,
	DBG_CFG_WARN=1,
	DBG_CFG_INFO=2
} DBG_CFG_TYPE;

typedef struct {
	uint8_t cmd_name[16];
	uint32_t	cmd_type;
} DBG_CFG_CMD;

typedef enum _CONSOLE_OP_STAGE_ {
	ROM_STAGE = 0,
	RAM_STAGE = 1
}CONSOLE_OP_STAGE;

#line 166 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform\\platform_stdlib.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\strproc.h"







 




#line 1 "F:\\IAR\\arm\\inc\\c\\stddef.h"
 
 
#line 39 "F:\\IAR\\arm\\inc\\c\\stddef.h"

#line 49 "F:\\IAR\\arm\\inc\\c\\stddef.h"





 
#line 14 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\strproc.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\va_list.h"







 




#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"


 




 



 








 
#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 42 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 52 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 62 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 





 





 





 





 





 





 





 





 





 





 




 





 







 





 






 





 




 




 




 







 




 




 




 






 




 




 




 




 








 
#line 14 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\va_list.h"


#line 36 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\va_list.h"

#line 15 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\strproc.h"

#line 24 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\strproc.h"

extern  SIZE_T _strlen(const char *s);
extern  int _strcmp(const char *cs, const char *ct);
extern  char *_strncpy(char *dest, const char *src, size_t count);
extern  char *_strcpy(char *dest, const char *src);
extern  size_t _strlen(const char *s);
extern  size_t _strnlen(const char *s, size_t count);
extern  int _strncmp(const char *cs, const char *ct, size_t count);
extern  int _sscanf(const char *buf, const char *fmt, ...);
extern  char *_strsep(char **s, const char *ct);
extern  char *skip_spaces(const char *str);
extern  int skip_atoi(const char **s);
extern  int _vsscanf(const char *buf, const char *fmt, va_list args);
extern  unsigned long long simple_strtoull(const char *cp, char **endp, unsigned int base);
extern  long simple_strtol(const char *cp, char **endp, unsigned int base);
extern  long long simple_strtoll(const char *cp, char **endp, unsigned int base);
extern  unsigned long simple_strtoul(const char *cp, char **endp, unsigned int base);
extern  const char *_parse_integer_fixup_radix(const char *s, unsigned int *base);
extern  unsigned int _parse_integer(const char *s, unsigned int base, unsigned long long *p);
extern  uint64_t div_u64(uint64_t dividend, uint32_t divisor);
extern  int64_t div_s64(int64_t dividend, int32_t divisor);
extern  uint64_t div_u64_rem(uint64_t dividend, uint32_t divisor, uint32_t *remainder);
extern  int64_t div_s64_rem(int64_t dividend, int32_t divisor, int32_t *remainder);
extern  char *_strpbrk(const char *cs, const char *ct);
extern  char *_strchr(const char *s, int c);


extern  void
prvStrCpy(
      uint8_t  *pDES,
      const uint8_t  *pSRC
);

extern  uint32_t
prvStrLen(
      const   uint8_t  *pSRC
);

extern   uint8_t
prvStrCmp(
      const   uint8_t  *string1,
      const   uint8_t  *string2
);

extern  uint8_t*
StrUpr(
      uint8_t  *string
);

extern  int prvAtoi(
	 const char * s
);

extern   char * prvStrStr(
	 const char * str1, 
	 const char * str2
);

extern  char* prvStrtok(
	 char *str, 
	 const char* delim
);





 
static inline char _tolower(const char c)
{
    return c | 0x20;
}

 
static inline int isodigit(const char c)
{
    return c >= '0' && c <= '7';
}
#line 108 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\strproc.h"

#line 167 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform\\platform_stdlib.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\memproc.h"







 






 
extern  void *_memset( void *s, int c, SIZE_T n );
extern  void *_memcpy( void *s1, const void *s2, SIZE_T n );
extern  int _memcmp( const void *av, const void *bv, SIZE_T len );



#line 168 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform\\platform_stdlib.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\std_lib\\include\\rtl_lib.h"




 
 








extern int __rtl_errno;


void init_rom_libgloss_ram_map(void);






extern int rtl_printf( const char* fmt, ...);
extern int rtl_vprintf(const char *fmt, va_list ap);
extern int rtl_sprintf(char* str, const char* fmt, ...);
extern int rtl_snprintf(char* str, size_t size, const char* fmt, ...);
extern int rtl_vsnprintf(char *str, size_t size, const char *fmt, va_list ap);





extern void * rtl_memchr(const void * src_void , int c , size_t length);
extern int rtl_memcmp(const void * m1 , const void * m2 , size_t n);
extern void * rtl_memcpy(void * dst0 , const void * src0 , size_t len0);
extern void * rtl_memmove( void * dst_void , const void * src_void , size_t length);
extern void * rtl_memset(void * m , int c , size_t n);
extern char * rtl_strcat(char * s1 , const char * s2);
extern char * rtl_strchr(const char *s1 , int i);
extern int rtl_strcmp(const char *s1 ,	const char *s2);
extern char* rtl_strcpy(char *dst0 , const char *src0);
extern size_t rtl_strlen(const char *str);
extern char * rtl_strncat(char * s1 , const char * s2 , size_t n);
extern int rtl_strncmp(const char *s1 , const char *s2 , size_t n);
extern char * rtl_strncpy(char * dst0 , const char * src0 , size_t count);
extern char * rtl_strstr(const char *searchee , const char *lookfor);
extern char * rtl_strsep(char **source_ptr , const char *delim);
extern char * rtl_strtok(char * s , const char * delim);






extern double rtl_fabs(double);
extern float rtl_fabsf(float a);
extern float rtl_cos_f32(float a);
extern float rtl_sin_f32(float a);

extern float rtl_fadd(float a, float b);
extern float rtl_fsub(float a, float b);
extern float rtl_fmul(float a, float b);
extern float rtl_fdiv(float a, float b);

extern int rtl_fcmplt(float a, float b);
extern int rtl_fcmpgt(float a, float b);








extern double rtl_ftod(float f);

extern double rtl_ddiv(double a, double b);






typedef union
{
  float value;
  uint32_t 	word;
} ieee_float_shape_type;

 

#line 100 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\std_lib\\include\\rtl_lib.h"

 

#line 109 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\std_lib\\include\\rtl_lib.h"

static inline
float rtl_nanf(void)
{
	float x;

	do { ieee_float_shape_type sf_u; sf_u . word = (0x7fc00000); (x) = sf_u . value; } while (0);
	return x;
}






extern int rtl_sscanf_patch_test(void);
extern int rtl_lib_test( uint16_t argc,  uint8_t *argv[]);
extern int rtl_math_test( uint16_t argc,  uint8_t *argv[]);
extern int rtl_string_test( uint16_t argc,  uint8_t *argv[]);
















#line 171 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform\\platform_stdlib.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\std_lib\\libc\\rom\\string\\rom_libc_string.h"




 





#line 27 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\std_lib\\libc\\rom\\string\\rom_libc_string.h"





extern  void * __rtl_memchr_v1_00(const void * src_void , int c , size_t length);
extern  int __rtl_memcmp_v1_00(const void * m1 , const void * m2 , size_t n);
extern  void * __rtl_memcpy_v1_00(void *  dst0 , const void *  src0 , size_t len0);
extern  void * __rtl_memmove_v1_00( void * dst_void , const void * src_void , size_t length);
extern  void * __rtl_memset_v1_00(void * m , int c , size_t n);
extern  char * __rtl_strcat_v1_00(char * s1 , const char * s2);
extern  char * __rtl_strchr_v1_00(const char *s1 , int i);
extern  int __rtl_strcmp_v1_00(const char *s1 ,	const char *s2);
extern  char* __rtl_strcpy_v1_00(char *dst0 , const char *src0);
extern  size_t __rtl_strlen_v1_00(const char *str);
extern  char * __rtl_strncat_v1_00(char * s1 , const char * s2 , size_t n);
extern  int __rtl_strncmp_v1_00(const char *s1 , const char *s2 , size_t n);
extern  char * __rtl_strncpy_v1_00(char * dst0 , const char * src0 , size_t count);
extern  char * __rtl_strstr_v1_00(const char *searchee , const char *lookfor);
extern  char * __rtl_strsep_v1_00(register char **source_ptr , register const char *delim);
extern  char * __rtl_strtok_v1_00(register char * s , register const char * delim);

#line 172 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform\\platform_stdlib.h"


#line 196 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform\\platform_stdlib.h"
	
#line 218 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform\\platform_stdlib.h"
	
#line 227 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform\\platform_stdlib.h"
	



	
#line 240 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform\\platform_stdlib.h"
	
	
	






extern void *pvPortMalloc( size_t xWantedSize );
extern void vPortFree( void *pv );
#line 259 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform\\platform_stdlib.h"


#line 21 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl/config.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl/config_rsa.h"





























 












 







 








 







 















 








 








 











 

















 


















 
















 


 







 











 

















 





















 






 






 






 
































 











 

















 












 









 
#line 350 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl/config_rsa.h"













 













 





















 























 



















 
























 



























 

























 
























 























 























 























 













 













 














 








 






 












 










 















 












 











 










 










 









 






 













 















 









 









 









 








 











 











 











 











 









 












 








 








 













 










 










 












 









 









 













 












 









 



















 

 






 












 










































































 






















 













 













 











 















 








 






















































 













 













 











 













 













 

























 













 















 














 












 













 











 













 






















 













 











 











 











 














 





 















 










 






















 













 













 

















 















 















 














 













 












 














 















 












 










 

















 















 

















 















 











 













 













 















 




















 











 










 
















 















 













 













 












 












 












 









 


 














 

 



 






 





 




 



 


 






 



 


















 


 


 

#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\check_config.h"

























 




 
























#line 62 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\check_config.h"





#line 81 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\check_config.h"

#line 99 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\check_config.h"












































































































































































#line 277 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\check_config.h"

#line 284 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\check_config.h"















































 




#line 2183 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl/config_rsa.h"

#line 22 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl/config.h"
#line 36 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"






#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl/debug.h"

























 



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"



#line 11 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"

#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl/debug.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"

























 



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"



#line 11 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"

#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\net.h"

























 



#line 1 "F:\\IAR\\arm\\inc\\c\\string.h"
 
 
#line 456 "F:\\IAR\\arm\\inc\\c\\string.h"

#line 479 "F:\\IAR\\arm\\inc\\c\\string.h"




 
#line 31 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\net.h"

#line 43 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\net.h"


















 
int net_connect( int *fd, const char *host, int port );













 
int net_bind( int *fd, const char *bind_ip, int port );












 
int net_accept( int bind_fd, int *client_fd, void *client_ip );







 
int net_set_block( int fd );







 
int net_set_nonblock( int fd );








 
void net_usleep( unsigned long usec );












 
int net_recv( void *ctx, unsigned char *buf, size_t len );












 
int net_send( void *ctx, const unsigned char *buf, size_t len );





 
void net_close( int fd );





#line 36 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\bignum.h"

























 



#line 1 "F:\\IAR\\arm\\inc\\c\\stdio.h"
 
 
#line 241 "F:\\IAR\\arm\\inc\\c\\stdio.h"

#line 292 "F:\\IAR\\arm\\inc\\c\\stdio.h"




 
#line 31 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\bignum.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\string.h"
 
 
#line 456 "F:\\IAR\\arm\\inc\\c\\string.h"

#line 479 "F:\\IAR\\arm\\inc\\c\\string.h"




 
#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\bignum.h"

#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"



#line 11 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"

#line 35 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\bignum.h"




#line 1 "F:\\IAR\\arm\\inc\\c\\inttypes.h"
 
 




  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 11 "F:\\IAR\\arm\\inc\\c\\inttypes.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\stdint.h"
 
 
#line 235 "F:\\IAR\\arm\\inc\\c\\stdint.h"

#line 258 "F:\\IAR\\arm\\inc\\c\\stdint.h"




 
#line 12 "F:\\IAR\\arm\\inc\\c\\inttypes.h"



                 
typedef struct
{        
  intmax_t quot;
  intmax_t rem;
} imaxdiv_t;

                 
_Pragma("function_effects = no_state, write_errno, always_returns")    __intrinsic __nounwind intmax_t imaxabs(intmax_t);
_Pragma("function_effects = no_state, write_errno, always_returns")    __intrinsic __nounwind imaxdiv_t imaxdiv(intmax_t, intmax_t);

_Pragma("function_effects = no_state, write_errno, no_write(1), always_returns") __intrinsic __nounwind intmax_t strtoimax(const char *, 
                                            char **, int);
_Pragma("function_effects = no_state, write_errno, no_write(1), always_returns") __intrinsic __nounwind uintmax_t strtoumax(const char *, 
                                             char **, int);
_Pragma("function_effects = no_state, write_errno, no_write(1), always_returns") __intrinsic __nounwind intmax_t wcstoimax(const _Wchart *, 
                                            _Wchart **, int);
_Pragma("function_effects = no_state, write_errno, no_write(1), always_returns") __intrinsic __nounwind uintmax_t wcstoumax(const _Wchart *, 
                                             _Wchart **, int);


          



                 
#line 67 "F:\\IAR\\arm\\inc\\c\\inttypes.h"

#line 94 "F:\\IAR\\arm\\inc\\c\\inttypes.h"

#line 121 "F:\\IAR\\arm\\inc\\c\\inttypes.h"

#line 148 "F:\\IAR\\arm\\inc\\c\\inttypes.h"

#line 175 "F:\\IAR\\arm\\inc\\c\\inttypes.h"

#line 202 "F:\\IAR\\arm\\inc\\c\\inttypes.h"

                 
#line 230 "F:\\IAR\\arm\\inc\\c\\inttypes.h"

#line 257 "F:\\IAR\\arm\\inc\\c\\inttypes.h"

#line 284 "F:\\IAR\\arm\\inc\\c\\inttypes.h"

#line 311 "F:\\IAR\\arm\\inc\\c\\inttypes.h"

#line 338 "F:\\IAR\\arm\\inc\\c\\inttypes.h"

#line 365 "F:\\IAR\\arm\\inc\\c\\inttypes.h"



#line 386 "F:\\IAR\\arm\\inc\\c\\inttypes.h"




#line 403 "F:\\IAR\\arm\\inc\\c\\inttypes.h"




 
#line 54 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\bignum.h"


#line 64 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\bignum.h"





 











 










 






















 






 
#line 135 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\bignum.h"
  


 
#line 159 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\bignum.h"
       typedef  int32_t t_sint;
       typedef uint32_t t_uint;





           typedef unsigned long long t_udbl;
#line 174 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\bignum.h"

 








 
typedef struct
{
    int s;               
    size_t n;            
    t_uint *p;           
}
mpi;





 
void mpi_init( mpi *X );





 
void mpi_free( mpi *X );









 
int mpi_grow( mpi *X, size_t nblimbs );









 
int mpi_shrink( mpi *X, size_t nblimbs );









 
int mpi_copy( mpi *X, const mpi *Y );






 
void mpi_swap( mpi *X, mpi *Y );

















 
int mpi_safe_cond_assign( mpi *X, const mpi *Y, unsigned char assign );

















 
int mpi_safe_cond_swap( mpi *X, mpi *Y, unsigned char assign );









 
int mpi_lset( mpi *X, t_sint z );








 
int mpi_get_bit( const mpi *X, size_t pos );














 
int mpi_set_bit( mpi *X, size_t pos, unsigned char val );








 
size_t mpi_lsb( const mpi *X );








 
size_t mpi_msb( const mpi *X );





 
size_t mpi_size( const mpi *X );









 
int mpi_read_string( mpi *X, int radix, const char *s );















 
int mpi_write_string( const mpi *X, int radix, char *s, size_t *slen );

#line 406 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\bignum.h"










 
int mpi_read_binary( mpi *X, const unsigned char *buf, size_t buflen );












 
int mpi_write_binary( const mpi *X, unsigned char *buf, size_t buflen );









 
int mpi_shift_l( mpi *X, size_t count );









 
int mpi_shift_r( mpi *X, size_t count );










 
int mpi_cmp_abs( const mpi *X, const mpi *Y );










 
int mpi_cmp_mpi( const mpi *X, const mpi *Y );










 
int mpi_cmp_int( const mpi *X, t_sint z );










 
int mpi_add_abs( mpi *X, const mpi *A, const mpi *B );










 
int mpi_sub_abs( mpi *X, const mpi *A, const mpi *B );










 
int mpi_add_mpi( mpi *X, const mpi *A, const mpi *B );










 
int mpi_sub_mpi( mpi *X, const mpi *A, const mpi *B );










 
int mpi_add_int( mpi *X, const mpi *A, t_sint b );










 
int mpi_sub_int( mpi *X, const mpi *A, t_sint b );










 
int mpi_mul_mpi( mpi *X, const mpi *A, const mpi *B );













 
int mpi_mul_int( mpi *X, const mpi *A, t_sint b );














 
int mpi_div_mpi( mpi *Q, mpi *R, const mpi *A, const mpi *B );














 
int mpi_div_int( mpi *Q, mpi *R, const mpi *A, t_sint b );












 
int mpi_mod_mpi( mpi *R, const mpi *A, const mpi *B );












 
int mpi_mod_int( t_uint *r, const mpi *A, t_sint b );


















 
int mpi_exp_mod( mpi *X, const mpi *A, const mpi *E, const mpi *N, mpi *_RR );











 
int mpi_fill_random( mpi *X, size_t size,
                     int (*f_rng)(void *, unsigned char *, size_t),
                     void *p_rng );










 
int mpi_gcd( mpi *G, const mpi *A, const mpi *B );












 
int mpi_inv_mod( mpi *X, const mpi *A, const mpi *N );











 
int mpi_is_prime( mpi *X,
                  int (*f_rng)(void *, unsigned char *, size_t),
                  void *p_rng );














 
int mpi_gen_prime( mpi *X, size_t nbits, int dh_flag,
                   int (*f_rng)(void *, unsigned char *, size_t),
                   void *p_rng );





 
int mpi_self_test( int verbose );





#line 37 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ecp.h"

























 







 
#line 43 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ecp.h"













 
typedef enum
{
    POLARSSL_ECP_DP_NONE = 0,
    POLARSSL_ECP_DP_SECP192R1,       
    POLARSSL_ECP_DP_SECP224R1,       
    POLARSSL_ECP_DP_SECP256R1,       
    POLARSSL_ECP_DP_SECP384R1,       
    POLARSSL_ECP_DP_SECP521R1,       
    POLARSSL_ECP_DP_BP256R1,         
    POLARSSL_ECP_DP_BP384R1,         
    POLARSSL_ECP_DP_BP512R1,         
    POLARSSL_ECP_DP_M221,            
    POLARSSL_ECP_DP_M255,            
    POLARSSL_ECP_DP_M383,            
    POLARSSL_ECP_DP_M511,            
    POLARSSL_ECP_DP_SECP192K1,       
    POLARSSL_ECP_DP_SECP224K1,       
    POLARSSL_ECP_DP_SECP256K1,       
} ecp_group_id;





 




 
typedef struct
{
    ecp_group_id grp_id;     
    uint16_t tls_id;         
    uint16_t size;           
    const char *name;        
} ecp_curve_info;









 
typedef struct
{
    mpi X;           
    mpi Y;           
    mpi Z;           
}
ecp_point;
























 
typedef struct
{
    ecp_group_id id;     
    mpi P;               
    mpi A;               
    mpi B;               
    ecp_point G;         
    mpi N;               
    size_t pbits;        
    size_t nbits;        
    unsigned int h;      
    int (*modp)(mpi *);  
    int (*t_pre)(ecp_point *, void *);   
    int (*t_post)(ecp_point *, void *);  
    void *t_data;                        
    ecp_point *T;        
    size_t T_size;       
}
ecp_group;







 
typedef struct
{
    ecp_group grp;       
    mpi d;               
    ecp_point Q;         
}
ecp_keypair;







 




 


























 














 



 



 





 







 
const ecp_curve_info *ecp_curve_list( void );







 
const ecp_group_id *ecp_grp_id_list( void );







 
const ecp_curve_info *ecp_curve_info_from_grp_id( ecp_group_id grp_id );







 
const ecp_curve_info *ecp_curve_info_from_tls_id( uint16_t tls_id );







 
const ecp_curve_info *ecp_curve_info_from_name( const char *name );



 
void ecp_point_init( ecp_point *pt );



 
void ecp_group_init( ecp_group *grp );



 
void ecp_keypair_init( ecp_keypair *key );



 
void ecp_point_free( ecp_point *pt );



 
void ecp_group_free( ecp_group *grp );



 
void ecp_keypair_free( ecp_keypair *key );









 
int ecp_copy( ecp_point *P, const ecp_point *Q );









 
int ecp_group_copy( ecp_group *dst, const ecp_group *src );








 
int ecp_set_zero( ecp_point *pt );







 
int ecp_is_zero( ecp_point *pt );










 
int ecp_point_read_string( ecp_point *P, int radix,
                           const char *x, const char *y );














 
int ecp_point_write_binary( const ecp_group *grp, const ecp_point *P,
                            int format, size_t *olen,
                            unsigned char *buf, size_t buflen );


















 
int ecp_point_read_binary( const ecp_group *grp, ecp_point *P,
                           const unsigned char *buf, size_t ilen );












 
int ecp_tls_read_point( const ecp_group *grp, ecp_point *pt,
                        const unsigned char **buf, size_t len );














 
int ecp_tls_write_point( const ecp_group *grp, const ecp_point *pt,
                         int format, size_t *olen,
                         unsigned char *buf, size_t blen );















 
int ecp_group_read_string( ecp_group *grp, int radix,
                           const char *p, const char *b,
                           const char *gx, const char *gy, const char *n);













 
int ecp_use_known_dp( ecp_group *grp, ecp_group_id index );











 
int ecp_tls_read_group( ecp_group *grp, const unsigned char **buf, size_t len );











 
int ecp_tls_write_group( const ecp_group *grp, size_t *olen,
                         unsigned char *buf, size_t blen );














 
int ecp_add( const ecp_group *grp, ecp_point *R,
             const ecp_point *P, const ecp_point *Q );














 
int ecp_sub( const ecp_group *grp, ecp_point *R,
             const ecp_point *P, const ecp_point *Q );


























 
int ecp_mul( ecp_group *grp, ecp_point *R,
             const mpi *m, const ecp_point *P,
             int (*f_rng)(void *, unsigned char *, size_t), void *p_rng );





















 
int ecp_check_pubkey( const ecp_group *grp, const ecp_point *pt );













 
int ecp_check_privkey( const ecp_group *grp, const mpi *d );
















 
int ecp_gen_keypair( ecp_group *grp, mpi *d, ecp_point *Q,
                     int (*f_rng)(void *, unsigned char *, size_t),
                     void *p_rng );











 
int ecp_gen_key( ecp_group_id grp_id, ecp_keypair *key,
                int (*f_rng)(void *, unsigned char *, size_t), void *p_rng );

#line 646 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ecp.h"





#line 38 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"

#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl_ciphersuites.h"

























 



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\pk.h"

























 




#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"



#line 11 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"

#line 33 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\pk.h"




#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\md.h"



























 



#line 1 "F:\\IAR\\arm\\inc\\c\\string.h"
 
 
#line 456 "F:\\IAR\\arm\\inc\\c\\string.h"

#line 479 "F:\\IAR\\arm\\inc\\c\\string.h"




 
#line 33 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\md.h"

#line 41 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\md.h"










typedef enum {
    POLARSSL_MD_NONE=0,
    POLARSSL_MD_MD2,
    POLARSSL_MD_MD4,
    POLARSSL_MD_MD5,
    POLARSSL_MD_SHA1,
    POLARSSL_MD_SHA224,
    POLARSSL_MD_SHA256,
    POLARSSL_MD_SHA384,
    POLARSSL_MD_SHA512,
    POLARSSL_MD_RIPEMD160,
} md_type_t;










 
typedef struct {
     
    md_type_t type;

     
    const char * name;

     
    int size;

     
    void (*starts_func)( void *ctx );

     
    void (*update_func)( void *ctx, const unsigned char *input, size_t ilen );

     
    void (*finish_func)( void *ctx, unsigned char *output );

     
    void (*digest_func)( const unsigned char *input, size_t ilen,
                         unsigned char *output );

     
    int (*file_func)( const char *path, unsigned char *output );

     
    void (*hmac_starts_func)( void *ctx, const unsigned char *key,
                              size_t keylen );

     
    void (*hmac_update_func)( void *ctx, const unsigned char *input,
                              size_t ilen );

     
    void (*hmac_finish_func)( void *ctx, unsigned char *output);

     
    void (*hmac_reset_func)( void *ctx );

     
    void (*hmac_func)( const unsigned char *key, size_t keylen,
                       const unsigned char *input, size_t ilen,
                       unsigned char *output );

     
    void * (*ctx_alloc_func)( void );

     
    void (*ctx_free_func)( void *ctx );

     
    void (*process_func)( void *ctx, const unsigned char *input );
} md_info_t;



 
typedef struct {
     
    const md_info_t *md_info;

     
    void *md_ctx;
} md_context_t;











 
const int *md_list( void );









 
const md_info_t *md_info_from_string( const char *md_name );









 
const md_info_t *md_info_from_type( md_type_t md_type );



 
void md_init( md_context_t *ctx );





 
void md_free( md_context_t *ctx );

















 
int md_init_ctx( md_context_t *ctx, const md_info_t *md_info );










 
int md_free_ctx( md_context_t *ctx );







 
static inline unsigned char md_get_size( const md_info_t *md_info )
{
    if( md_info == 0 )
        return( 0 );

    return md_info->size;
}







 
static inline md_type_t md_get_type( const md_info_t *md_info )
{
    if( md_info == 0 )
        return( POLARSSL_MD_NONE );

    return md_info->type;
}







 
static inline const char *md_get_name( const md_info_t *md_info )
{
    if( md_info == 0 )
        return( 0 );

    return md_info->name;
}








 
int md_starts( md_context_t *ctx );










 
int md_update( md_context_t *ctx, const unsigned char *input, size_t ilen );









 
int md_finish( md_context_t *ctx, unsigned char *output );











 
int md( const md_info_t *md_info, const unsigned char *input, size_t ilen,
        unsigned char *output );











 
int md_file( const md_info_t *md_info, const char *path,
             unsigned char *output );










 
int md_hmac_starts( md_context_t *ctx, const unsigned char *key,
                    size_t keylen );










 
int md_hmac_update( md_context_t *ctx, const unsigned char *input,
                    size_t ilen );









 
int md_hmac_finish( md_context_t *ctx, unsigned char *output);








 
int md_hmac_reset( md_context_t *ctx );













 
int md_hmac( const md_info_t *md_info, const unsigned char *key, size_t keylen,
                const unsigned char *input, size_t ilen,
                unsigned char *output );

 
int md_process( md_context_t *ctx, const unsigned char *data );





#line 38 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\pk.h"

#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\rsa.h"

























 



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"



#line 11 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"

#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\rsa.h"













 
#line 55 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\rsa.h"



 














 








 
typedef struct
{
    int ver;                     
    size_t len;                  

    mpi N;                       
    mpi E;                       

    mpi D;                       
    mpi P;                       
    mpi Q;                       
    mpi DP;                      
    mpi DQ;                      
    mpi QP;                      

    mpi RN;                      
    mpi RP;                      
    mpi RQ;                      


    mpi Vi;                      
    mpi Vf;                      


    int padding;                
 
    int hash_id;                


 



}
rsa_context;
























 
void rsa_init( rsa_context *ctx,
               int padding,
               int hash_id);








 
void rsa_set_padding( rsa_context *ctx, int padding, int hash_id);














 
int rsa_gen_key( rsa_context *ctx,
                 int (*f_rng)(void *, unsigned char *, size_t),
                 void *p_rng,
                 unsigned int nbits, int exponent );







 
int rsa_check_pubkey( const rsa_context *ctx );







 
int rsa_check_privkey( const rsa_context *ctx );
















 
int rsa_public( rsa_context *ctx,
                const unsigned char *input,
                unsigned char *output );














 
int rsa_private( rsa_context *ctx,
                 int (*f_rng)(void *, unsigned char *, size_t),
                 void *p_rng,
                 const unsigned char *input,
                 unsigned char *output );



















 
int rsa_pkcs1_encrypt( rsa_context *ctx,
                       int (*f_rng)(void *, unsigned char *, size_t),
                       void *p_rng,
                       int mode, size_t ilen,
                       const unsigned char *input,
                       unsigned char *output );
















 
int rsa_rsaes_pkcs1_v15_encrypt( rsa_context *ctx,
                                 int (*f_rng)(void *, unsigned char *, size_t),
                                 void *p_rng,
                                 int mode, size_t ilen,
                                 const unsigned char *input,
                                 unsigned char *output );



















 
int rsa_rsaes_oaep_encrypt( rsa_context *ctx,
                            int (*f_rng)(void *, unsigned char *, size_t),
                            void *p_rng,
                            int mode,
                            const unsigned char *label, size_t label_len,
                            size_t ilen,
                            const unsigned char *input,
                            unsigned char *output );




















 
int rsa_pkcs1_decrypt( rsa_context *ctx,
                       int (*f_rng)(void *, unsigned char *, size_t),
                       void *p_rng,
                       int mode, size_t *olen,
                       const unsigned char *input,
                       unsigned char *output,
                       size_t output_max_len );


















 
int rsa_rsaes_pkcs1_v15_decrypt( rsa_context *ctx,
                                 int (*f_rng)(void *, unsigned char *, size_t),
                                 void *p_rng,
                                 int mode, size_t *olen,
                                 const unsigned char *input,
                                 unsigned char *output,
                                 size_t output_max_len );




















 
int rsa_rsaes_oaep_decrypt( rsa_context *ctx,
                            int (*f_rng)(void *, unsigned char *, size_t),
                            void *p_rng,
                            int mode,
                            const unsigned char *label, size_t label_len,
                            size_t *olen,
                            const unsigned char *input,
                            unsigned char *output,
                            size_t output_max_len );
























 
int rsa_pkcs1_sign( rsa_context *ctx,
                    int (*f_rng)(void *, unsigned char *, size_t),
                    void *p_rng,
                    int mode,
                    md_type_t md_alg,
                    unsigned int hashlen,
                    const unsigned char *hash,
                    unsigned char *sig );


















 
int rsa_rsassa_pkcs1_v15_sign( rsa_context *ctx,
                               int (*f_rng)(void *, unsigned char *, size_t),
                               void *p_rng,
                               int mode,
                               md_type_t md_alg,
                               unsigned int hashlen,
                               const unsigned char *hash,
                               unsigned char *sig );
























 
int rsa_rsassa_pss_sign( rsa_context *ctx,
                         int (*f_rng)(void *, unsigned char *, size_t),
                         void *p_rng,
                         int mode,
                         md_type_t md_alg,
                         unsigned int hashlen,
                         const unsigned char *hash,
                         unsigned char *sig );























 
int rsa_pkcs1_verify( rsa_context *ctx,
                      int (*f_rng)(void *, unsigned char *, size_t),
                      void *p_rng,
                      int mode,
                      md_type_t md_alg,
                      unsigned int hashlen,
                      const unsigned char *hash,
                      const unsigned char *sig );


















 
int rsa_rsassa_pkcs1_v15_verify( rsa_context *ctx,
                                 int (*f_rng)(void *, unsigned char *, size_t),
                                 void *p_rng,
                                 int mode,
                                 md_type_t md_alg,
                                 unsigned int hashlen,
                                 const unsigned char *hash,
                                 const unsigned char *sig );

























 
int rsa_rsassa_pss_verify( rsa_context *ctx,
                           int (*f_rng)(void *, unsigned char *, size_t),
                           void *p_rng,
                           int mode,
                           md_type_t md_alg,
                           unsigned int hashlen,
                           const unsigned char *hash,
                           const unsigned char *sig );
























 
int rsa_rsassa_pss_verify_ext( rsa_context *ctx,
                               int (*f_rng)(void *, unsigned char *, size_t),
                               void *p_rng,
                               int mode,
                               md_type_t md_alg,
                               unsigned int hashlen,
                               const unsigned char *hash,
                               md_type_t mgf1_hash_id,
                               int expected_salt_len,
                               const unsigned char *sig );









 
int rsa_copy( rsa_context *dst, const rsa_context *src );





 
void rsa_free( rsa_context *ctx );





 
int rsa_self_test( int verbose );







#line 41 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\pk.h"










#line 65 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\pk.h"








 



#line 86 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\pk.h"








 
typedef enum {
    POLARSSL_PK_NONE=0,
    POLARSSL_PK_RSA,
    POLARSSL_PK_ECKEY,
    POLARSSL_PK_ECKEY_DH,
    POLARSSL_PK_ECDSA,
    POLARSSL_PK_RSA_ALT,
    POLARSSL_PK_RSASSA_PSS,
} pk_type_t;




 
typedef struct
{
    md_type_t mgf1_hash_id;
    int expected_salt_len;

} pk_rsassa_pss_options;



 
typedef enum
{
    POLARSSL_PK_DEBUG_NONE = 0,
    POLARSSL_PK_DEBUG_MPI,
    POLARSSL_PK_DEBUG_ECP,
} pk_debug_type;



 
typedef struct
{
    pk_debug_type type;
    const char *name;
    void *value;
} pk_debug_item;

 




 
typedef struct
{
     
    pk_type_t type;

     
    const char *name;

     
    size_t (*get_size)( const void * );

     
    int (*can_do)( pk_type_t type );

     
    int (*verify_func)( void *ctx, md_type_t md_alg,
                        const unsigned char *hash, size_t hash_len,
                        const unsigned char *sig, size_t sig_len );

     
    int (*sign_func)( void *ctx, md_type_t md_alg,
                      const unsigned char *hash, size_t hash_len,
                      unsigned char *sig, size_t *sig_len,
                      int (*f_rng)(void *, unsigned char *, size_t),
                      void *p_rng );

     
    int (*decrypt_func)( void *ctx, const unsigned char *input, size_t ilen,
                         unsigned char *output, size_t *olen, size_t osize,
                         int (*f_rng)(void *, unsigned char *, size_t),
                         void *p_rng );

     
    int (*encrypt_func)( void *ctx, const unsigned char *input, size_t ilen,
                         unsigned char *output, size_t *olen, size_t osize,
                         int (*f_rng)(void *, unsigned char *, size_t),
                         void *p_rng );

     
    void * (*ctx_alloc_func)( void );

     
    void (*ctx_free_func)( void *ctx );

     
    void (*debug_func)( const void *ctx, pk_debug_item *items );

} pk_info_t;



 
typedef struct
{
    const pk_info_t *   pk_info;     
    void *              pk_ctx;      
} pk_context;



 
typedef int (*pk_rsa_alt_decrypt_func)( void *ctx, int mode, size_t *olen,
                    const unsigned char *input, unsigned char *output,
                    size_t output_max_len );
typedef int (*pk_rsa_alt_sign_func)( void *ctx,
                    int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,
                    int mode, md_type_t md_alg, unsigned int hashlen,
                    const unsigned char *hash, unsigned char *sig );
typedef size_t (*pk_rsa_alt_key_len_func)( void *ctx );







 
const pk_info_t *pk_info_from_type( pk_type_t pk_type );



 
void pk_init( pk_context *ctx );



 
void pk_free( pk_context *ctx );














 
int pk_init_ctx( pk_context *ctx, const pk_info_t *info );














 
int pk_init_ctx_rsa_alt( pk_context *ctx, void * key,
                         pk_rsa_alt_decrypt_func decrypt_func,
                         pk_rsa_alt_sign_func sign_func,
                         pk_rsa_alt_key_len_func key_len_func );







 
size_t pk_get_size( const pk_context *ctx );






 
static inline size_t pk_get_len( const pk_context *ctx )
{
    return( ( pk_get_size( ctx ) + 7 ) / 8 );
}









 
int pk_can_do( pk_context *ctx, pk_type_t type );
























 
int pk_verify( pk_context *ctx, md_type_t md_alg,
               const unsigned char *hash, size_t hash_len,
               const unsigned char *sig, size_t sig_len );





























 
int pk_verify_ext( pk_type_t type, const void *options,
                   pk_context *ctx, md_type_t md_alg,
                   const unsigned char *hash, size_t hash_len,
                   const unsigned char *sig, size_t sig_len );























 
int pk_sign( pk_context *ctx, md_type_t md_alg,
             const unsigned char *hash, size_t hash_len,
             unsigned char *sig, size_t *sig_len,
             int (*f_rng)(void *, unsigned char *, size_t), void *p_rng );
















 
int pk_decrypt( pk_context *ctx,
                const unsigned char *input, size_t ilen,
                unsigned char *output, size_t *olen, size_t osize,
                int (*f_rng)(void *, unsigned char *, size_t), void *p_rng );
















 
int pk_encrypt( pk_context *ctx,
                const unsigned char *input, size_t ilen,
                unsigned char *output, size_t *olen, size_t osize,
                int (*f_rng)(void *, unsigned char *, size_t), void *p_rng );








 
int pk_debug( const pk_context *ctx, pk_debug_item *items );







 
const char * pk_get_name( const pk_context *ctx );







 
pk_type_t pk_get_type( const pk_context *ctx );


 
















 
int pk_parse_key( pk_context *ctx,
                  const unsigned char *key, size_t keylen,
                  const unsigned char *pwd, size_t pwdlen );

 














 
int pk_parse_public_key( pk_context *ctx,
                         const unsigned char *key, size_t keylen );

#line 537 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\pk.h"

#line 593 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\pk.h"




 










 
int pk_parse_subpubkey( unsigned char **p, const unsigned char *end,
                        pk_context *pk );


#line 627 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\pk.h"





#line 31 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl_ciphersuites.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\cipher.h"



























 




#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"



#line 11 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"

#line 35 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\cipher.h"












#line 1 "F:\\IAR\\arm\\inc\\c\\string.h"
 
 
#line 456 "F:\\IAR\\arm\\inc\\c\\string.h"

#line 479 "F:\\IAR\\arm\\inc\\c\\string.h"




 
#line 48 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\cipher.h"

#line 56 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\cipher.h"

#line 63 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\cipher.h"








typedef enum {
    POLARSSL_CIPHER_ID_NONE = 0,
    POLARSSL_CIPHER_ID_NULL,
    POLARSSL_CIPHER_ID_AES,
    POLARSSL_CIPHER_ID_DES,
    POLARSSL_CIPHER_ID_3DES,
    POLARSSL_CIPHER_ID_CAMELLIA,
    POLARSSL_CIPHER_ID_BLOWFISH,
    POLARSSL_CIPHER_ID_ARC4,
} cipher_id_t;

typedef enum {
    POLARSSL_CIPHER_NONE = 0,
    POLARSSL_CIPHER_NULL,
    POLARSSL_CIPHER_AES_128_ECB,
    POLARSSL_CIPHER_AES_192_ECB,
    POLARSSL_CIPHER_AES_256_ECB,
    POLARSSL_CIPHER_AES_128_CBC,
    POLARSSL_CIPHER_AES_192_CBC,
    POLARSSL_CIPHER_AES_256_CBC,
    POLARSSL_CIPHER_AES_128_CFB128,
    POLARSSL_CIPHER_AES_192_CFB128,
    POLARSSL_CIPHER_AES_256_CFB128,
    POLARSSL_CIPHER_AES_128_CTR,
    POLARSSL_CIPHER_AES_192_CTR,
    POLARSSL_CIPHER_AES_256_CTR,
    POLARSSL_CIPHER_AES_128_GCM,
    POLARSSL_CIPHER_AES_192_GCM,
    POLARSSL_CIPHER_AES_256_GCM,
    POLARSSL_CIPHER_CAMELLIA_128_ECB,
    POLARSSL_CIPHER_CAMELLIA_192_ECB,
    POLARSSL_CIPHER_CAMELLIA_256_ECB,
    POLARSSL_CIPHER_CAMELLIA_128_CBC,
    POLARSSL_CIPHER_CAMELLIA_192_CBC,
    POLARSSL_CIPHER_CAMELLIA_256_CBC,
    POLARSSL_CIPHER_CAMELLIA_128_CFB128,
    POLARSSL_CIPHER_CAMELLIA_192_CFB128,
    POLARSSL_CIPHER_CAMELLIA_256_CFB128,
    POLARSSL_CIPHER_CAMELLIA_128_CTR,
    POLARSSL_CIPHER_CAMELLIA_192_CTR,
    POLARSSL_CIPHER_CAMELLIA_256_CTR,
    POLARSSL_CIPHER_CAMELLIA_128_GCM,
    POLARSSL_CIPHER_CAMELLIA_192_GCM,
    POLARSSL_CIPHER_CAMELLIA_256_GCM,
    POLARSSL_CIPHER_DES_ECB,
    POLARSSL_CIPHER_DES_CBC,
    POLARSSL_CIPHER_DES_EDE_ECB,
    POLARSSL_CIPHER_DES_EDE_CBC,
    POLARSSL_CIPHER_DES_EDE3_ECB,
    POLARSSL_CIPHER_DES_EDE3_CBC,
    POLARSSL_CIPHER_BLOWFISH_ECB,
    POLARSSL_CIPHER_BLOWFISH_CBC,
    POLARSSL_CIPHER_BLOWFISH_CFB64,
    POLARSSL_CIPHER_BLOWFISH_CTR,
    POLARSSL_CIPHER_ARC4_128,
    POLARSSL_CIPHER_AES_128_CCM,
    POLARSSL_CIPHER_AES_192_CCM,
    POLARSSL_CIPHER_AES_256_CCM,
    POLARSSL_CIPHER_CAMELLIA_128_CCM,
    POLARSSL_CIPHER_CAMELLIA_192_CCM,
    POLARSSL_CIPHER_CAMELLIA_256_CCM,
} cipher_type_t;

typedef enum {
    POLARSSL_MODE_NONE = 0,
    POLARSSL_MODE_ECB,
    POLARSSL_MODE_CBC,
    POLARSSL_MODE_CFB,
    POLARSSL_MODE_OFB,  
    POLARSSL_MODE_CTR,
    POLARSSL_MODE_GCM,
    POLARSSL_MODE_STREAM,
    POLARSSL_MODE_CCM,
} cipher_mode_t;

typedef enum {
    POLARSSL_PADDING_PKCS7 = 0,      
    POLARSSL_PADDING_ONE_AND_ZEROS,  
    POLARSSL_PADDING_ZEROS_AND_LEN,  
    POLARSSL_PADDING_ZEROS,          
    POLARSSL_PADDING_NONE,           
} cipher_padding_t;

typedef enum {
    POLARSSL_OPERATION_NONE = -1,
    POLARSSL_DECRYPT = 0,
    POLARSSL_ENCRYPT,
} operation_t;

enum {
     
    POLARSSL_KEY_LENGTH_NONE = 0,
     
    POLARSSL_KEY_LENGTH_DES  = 64,
     
    POLARSSL_KEY_LENGTH_DES_EDE = 128,
     
    POLARSSL_KEY_LENGTH_DES_EDE3 = 192,
};

 

 




 
typedef struct {

     
    cipher_id_t cipher;

     
    int (*ecb_func)( void *ctx, operation_t mode,
                     const unsigned char *input, unsigned char *output );

     
    int (*cbc_func)( void *ctx, operation_t mode, size_t length,
                     unsigned char *iv, const unsigned char *input,
                     unsigned char *output );

     
    int (*cfb_func)( void *ctx, operation_t mode, size_t length, size_t *iv_off,
                     unsigned char *iv, const unsigned char *input,
                     unsigned char *output );

     
    int (*ctr_func)( void *ctx, size_t length, size_t *nc_off,
                     unsigned char *nonce_counter, unsigned char *stream_block,
                     const unsigned char *input, unsigned char *output );

     
    int (*stream_func)( void *ctx, size_t length,
                        const unsigned char *input, unsigned char *output );

     
    int (*setkey_enc_func)( void *ctx, const unsigned char *key,
                            unsigned int key_length );

     
    int (*setkey_dec_func)( void *ctx, const unsigned char *key,
                            unsigned int key_length);

     
    void * (*ctx_alloc_func)( void );

     
    void (*ctx_free_func)( void *ctx );

} cipher_base_t;



 
typedef struct {
     
    cipher_type_t type;

     
    cipher_mode_t mode;

    
 
    unsigned int key_length;

     
    const char * name;

    
 
    unsigned int iv_size;

     
    int flags;

     
    unsigned int block_size;

     
    const cipher_base_t *base;

} cipher_info_t;



 
typedef struct {
     
    const cipher_info_t *cipher_info;

     
    int key_length;

     
    operation_t operation;

     
    void (*add_padding)( unsigned char *output, size_t olen, size_t data_len );
    int (*get_padding)( unsigned char *input, size_t ilen, size_t *data_len );

     
    unsigned char unprocessed_data[16];

     
    size_t unprocessed_len;

     
    unsigned char iv[16];

     
    size_t iv_size;

     
    void *cipher_ctx;
} cipher_context_t;






 
const int *cipher_list( void );









 
const cipher_info_t *cipher_info_from_string( const char *cipher_name );









 
const cipher_info_t *cipher_info_from_type( const cipher_type_t cipher_type );












 
const cipher_info_t *cipher_info_from_values( const cipher_id_t cipher_id,
                                              int key_length,
                                              const cipher_mode_t mode );



 
void cipher_init( cipher_context_t *ctx );





 
void cipher_free( cipher_context_t *ctx );
















 
int cipher_init_ctx( cipher_context_t *ctx, const cipher_info_t *cipher_info );










 
int cipher_free_ctx( cipher_context_t *ctx );








 
static inline unsigned int cipher_get_block_size( const cipher_context_t *ctx )
{
    if( 0 == ctx || 0 == ctx->cipher_info )
        return 0;

    return ctx->cipher_info->block_size;
}









 
static inline cipher_mode_t cipher_get_cipher_mode( const cipher_context_t *ctx )
{
    if( 0 == ctx || 0 == ctx->cipher_info )
        return POLARSSL_MODE_NONE;

    return ctx->cipher_info->mode;
}









 
static inline int cipher_get_iv_size( const cipher_context_t *ctx )
{
    if( 0 == ctx || 0 == ctx->cipher_info )
        return 0;

    if( ctx->iv_size != 0 )
        return (int) ctx->iv_size;

    return ctx->cipher_info->iv_size;
}








 
static inline cipher_type_t cipher_get_type( const cipher_context_t *ctx )
{
    if( 0 == ctx || 0 == ctx->cipher_info )
        return POLARSSL_CIPHER_NONE;

    return ctx->cipher_info->type;
}







 
static inline const char *cipher_get_name( const cipher_context_t *ctx )
{
    if( 0 == ctx || 0 == ctx->cipher_info )
        return 0;

    return ctx->cipher_info->name;
}









 
static inline int cipher_get_key_size ( const cipher_context_t *ctx )
{
    if( 0 == ctx || 0 == ctx->cipher_info )
        return POLARSSL_KEY_LENGTH_NONE;

    return ctx->cipher_info->key_length;
}









 
static inline operation_t cipher_get_operation( const cipher_context_t *ctx )
{
    if( 0 == ctx || 0 == ctx->cipher_info )
        return POLARSSL_OPERATION_NONE;

    return ctx->operation;
}















 
int cipher_setkey( cipher_context_t *ctx, const unsigned char *key,
                   int key_length, const operation_t operation );













 
int cipher_set_padding_mode( cipher_context_t *ctx, cipher_padding_t mode );














 
int cipher_set_iv( cipher_context_t *ctx,
                   const unsigned char *iv, size_t iv_len );








 
int cipher_reset( cipher_context_t *ctx );

#line 569 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\cipher.h"





























 
int cipher_update( cipher_context_t *ctx, const unsigned char *input,
                   size_t ilen, unsigned char *output, size_t *olen );

















 
int cipher_finish( cipher_context_t *ctx,
                   unsigned char *output, size_t *olen );

#line 651 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\cipher.h"



























 
int cipher_crypt( cipher_context_t *ctx,
                  const unsigned char *iv, size_t iv_len,
                  const unsigned char *input, size_t ilen,
                  unsigned char *output, size_t *olen );

#line 748 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\cipher.h"





 
int cipher_self_test( int verbose );





#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl_ciphersuites.h"








 






















































#line 101 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl_ciphersuites.h"














































#line 155 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl_ciphersuites.h"

#line 164 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl_ciphersuites.h"

#line 174 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl_ciphersuites.h"

#line 183 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl_ciphersuites.h"

#line 196 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl_ciphersuites.h"

#line 203 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl_ciphersuites.h"

#line 212 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl_ciphersuites.h"

#line 229 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl_ciphersuites.h"
 






 
typedef enum {
    POLARSSL_KEY_EXCHANGE_NONE = 0,
    POLARSSL_KEY_EXCHANGE_RSA,
    POLARSSL_KEY_EXCHANGE_DHE_RSA,
    POLARSSL_KEY_EXCHANGE_ECDHE_RSA,
    POLARSSL_KEY_EXCHANGE_ECDHE_ECDSA,
    POLARSSL_KEY_EXCHANGE_PSK,
    POLARSSL_KEY_EXCHANGE_DHE_PSK,
    POLARSSL_KEY_EXCHANGE_RSA_PSK,
    POLARSSL_KEY_EXCHANGE_ECDHE_PSK,
    POLARSSL_KEY_EXCHANGE_ECDH_RSA,
    POLARSSL_KEY_EXCHANGE_ECDH_ECDSA,
} key_exchange_type_t;

typedef struct _ssl_ciphersuite_t ssl_ciphersuite_t;







 
struct _ssl_ciphersuite_t
{
    int id;
    const char * name;

    cipher_type_t cipher;
    md_type_t mac;
    key_exchange_type_t key_exchange;

    int min_major_ver;
    int min_minor_ver;
    int max_major_ver;
    int max_minor_ver;

    unsigned char flags;
};

const int *ssl_list_ciphersuites( void );

const ssl_ciphersuite_t *ssl_ciphersuite_from_string( const char *ciphersuite_name );
const ssl_ciphersuite_t *ssl_ciphersuite_from_id( int ciphersuite_id );


pk_type_t ssl_get_ciphersuite_sig_pk_alg( const ssl_ciphersuite_t *info );


int ssl_ciphersuite_uses_ec( const ssl_ciphersuite_t *info );
int ssl_ciphersuite_uses_psk( const ssl_ciphersuite_t *info );





#line 40 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"

#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\md5.h"

























 



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"



#line 11 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"

#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\md5.h"




#line 1 "F:\\IAR\\arm\\inc\\c\\string.h"
 
 
#line 456 "F:\\IAR\\arm\\inc\\c\\string.h"

#line 479 "F:\\IAR\\arm\\inc\\c\\string.h"




 
#line 37 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\md5.h"

#line 1 "F:\\IAR\\arm\\inc\\c\\inttypes.h"
 
 
#line 389 "F:\\IAR\\arm\\inc\\c\\inttypes.h"

#line 403 "F:\\IAR\\arm\\inc\\c\\inttypes.h"




 
#line 43 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\md5.h"














 
typedef struct
{
    uint32_t total[2];           
    uint32_t state[4];           
    unsigned char buffer[64];    

    unsigned char ipad[64];      
    unsigned char opad[64];      
}
md5_context;





 
void md5_init( md5_context *ctx );





 
void md5_free( md5_context *ctx );





 
void md5_starts( md5_context *ctx );







 
void md5_update( md5_context *ctx, const unsigned char *input, size_t ilen );






 
void md5_finish( md5_context *ctx, unsigned char output[16] );

 
void md5_process( md5_context *ctx, const unsigned char data[64] );



















 
void md5( const unsigned char *input, size_t ilen, unsigned char output[16] );








 
int md5_file( const char *path, unsigned char output[16] );







 
void md5_hmac_starts( md5_context *ctx,
                      const unsigned char *key, size_t keylen );







 
void md5_hmac_update( md5_context *ctx,
                      const unsigned char *input, size_t ilen );






 
void md5_hmac_finish( md5_context *ctx, unsigned char output[16] );





 
void md5_hmac_reset( md5_context *ctx );









 
void md5_hmac( const unsigned char *key, size_t keylen,
               const unsigned char *input, size_t ilen,
               unsigned char output[16] );





 
int md5_self_test( int verbose );





#line 43 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"


#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\sha1.h"

























 



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"



#line 11 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"

#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\sha1.h"




#line 1 "F:\\IAR\\arm\\inc\\c\\string.h"
 
 
#line 456 "F:\\IAR\\arm\\inc\\c\\string.h"

#line 479 "F:\\IAR\\arm\\inc\\c\\string.h"




 
#line 37 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\sha1.h"

#line 1 "F:\\IAR\\arm\\inc\\c\\inttypes.h"
 
 
#line 389 "F:\\IAR\\arm\\inc\\c\\inttypes.h"

#line 403 "F:\\IAR\\arm\\inc\\c\\inttypes.h"




 
#line 43 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\sha1.h"














 
typedef struct
{
    uint32_t total[2];           
    uint32_t state[5];           
    unsigned char buffer[64];    

    unsigned char ipad[64];      
    unsigned char opad[64];      
}
sha1_context;





 
void sha1_init( sha1_context *ctx );





 
void sha1_free( sha1_context *ctx );





 
void sha1_starts( sha1_context *ctx );







 
void sha1_update( sha1_context *ctx, const unsigned char *input, size_t ilen );






 
void sha1_finish( sha1_context *ctx, unsigned char output[20] );

 
void sha1_process( sha1_context *ctx, const unsigned char data[64] );



















 
void sha1( const unsigned char *input, size_t ilen, unsigned char output[20] );








 
int sha1_file( const char *path, unsigned char output[20] );







 
void sha1_hmac_starts( sha1_context *ctx, const unsigned char *key,
                       size_t keylen );







 
void sha1_hmac_update( sha1_context *ctx, const unsigned char *input,
                       size_t ilen );






 
void sha1_hmac_finish( sha1_context *ctx, unsigned char output[20] );





 
void sha1_hmac_reset( sha1_context *ctx );









 
void sha1_hmac( const unsigned char *key, size_t keylen,
                const unsigned char *input, size_t ilen,
                unsigned char output[20] );





 
int sha1_self_test( int verbose );





#line 47 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"


#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\sha256.h"

























 



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"



#line 11 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"

#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\sha256.h"




#line 1 "F:\\IAR\\arm\\inc\\c\\string.h"
 
 
#line 456 "F:\\IAR\\arm\\inc\\c\\string.h"

#line 479 "F:\\IAR\\arm\\inc\\c\\string.h"




 
#line 37 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\sha256.h"

#line 1 "F:\\IAR\\arm\\inc\\c\\inttypes.h"
 
 
#line 389 "F:\\IAR\\arm\\inc\\c\\inttypes.h"

#line 403 "F:\\IAR\\arm\\inc\\c\\inttypes.h"




 
#line 43 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\sha256.h"














 
typedef struct
{
    uint32_t total[2];           
    uint32_t state[8];           
    unsigned char buffer[64];    

    unsigned char ipad[64];      
    unsigned char opad[64];      
    int is224;                   
}
sha256_context;





 
void sha256_init( sha256_context *ctx );





 
void sha256_free( sha256_context *ctx );






 
void sha256_starts( sha256_context *ctx, int is224 );







 
void sha256_update( sha256_context *ctx, const unsigned char *input,
                    size_t ilen );






 
void sha256_finish( sha256_context *ctx, unsigned char output[32] );

 
void sha256_process( sha256_context *ctx, const unsigned char data[64] );




















 
void sha256( const unsigned char *input, size_t ilen,
           unsigned char output[32], int is224 );









 
int sha256_file( const char *path, unsigned char output[32], int is224 );








 
void sha256_hmac_starts( sha256_context *ctx, const unsigned char *key,
                         size_t keylen, int is224 );







 
void sha256_hmac_update( sha256_context *ctx, const unsigned char *input,
                         size_t ilen );






 
void sha256_hmac_finish( sha256_context *ctx, unsigned char output[32] );





 
void sha256_hmac_reset( sha256_context *ctx );










 
void sha256_hmac( const unsigned char *key, size_t keylen,
                  const unsigned char *input, size_t ilen,
                  unsigned char output[32], int is224 );





 
int sha256_self_test( int verbose );





#line 51 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"


#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\sha512.h"

























 



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"



#line 11 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"

#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\sha512.h"




#line 1 "F:\\IAR\\arm\\inc\\c\\string.h"
 
 
#line 456 "F:\\IAR\\arm\\inc\\c\\string.h"

#line 479 "F:\\IAR\\arm\\inc\\c\\string.h"




 
#line 37 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\sha512.h"

#line 1 "F:\\IAR\\arm\\inc\\c\\inttypes.h"
 
 
#line 389 "F:\\IAR\\arm\\inc\\c\\inttypes.h"

#line 403 "F:\\IAR\\arm\\inc\\c\\inttypes.h"




 
#line 43 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\sha512.h"















 
typedef struct
{
    uint64_t total[2];           
    uint64_t state[8];           
    unsigned char buffer[128];   

    unsigned char ipad[128];     
    unsigned char opad[128];     
    int is384;                   
}
sha512_context;





 
void sha512_init( sha512_context *ctx );





 
void sha512_free( sha512_context *ctx );






 
void sha512_starts( sha512_context *ctx, int is384 );







 
void sha512_update( sha512_context *ctx, const unsigned char *input,
                    size_t ilen );






 
void sha512_finish( sha512_context *ctx, unsigned char output[64] );




















 
void sha512( const unsigned char *input, size_t ilen,
             unsigned char output[64], int is384 );









 
int sha512_file( const char *path, unsigned char output[64], int is384 );








 
void sha512_hmac_starts( sha512_context *ctx, const unsigned char *key,
                         size_t keylen, int is384 );







 
void sha512_hmac_update( sha512_context *ctx, const unsigned char *input,
                         size_t ilen );






 
void sha512_hmac_finish( sha512_context *ctx, unsigned char output[64] );





 
void sha512_hmac_reset( sha512_context *ctx );










 
void sha512_hmac( const unsigned char *key, size_t keylen,
                const unsigned char *input, size_t ilen,
                unsigned char output[64], int is384 );





 
int sha512_self_test( int verbose );

 
void sha512_process( sha512_context *ctx, const unsigned char data[128] );





#line 55 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\aes.h"

























 



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"



#line 11 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"

#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\aes.h"







#line 1 "F:\\IAR\\arm\\inc\\c\\string.h"
 
 
#line 456 "F:\\IAR\\arm\\inc\\c\\string.h"

#line 479 "F:\\IAR\\arm\\inc\\c\\string.h"




 
#line 40 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\aes.h"

#line 1 "F:\\IAR\\arm\\inc\\c\\inttypes.h"
 
 
#line 389 "F:\\IAR\\arm\\inc\\c\\inttypes.h"

#line 403 "F:\\IAR\\arm\\inc\\c\\inttypes.h"




 
#line 46 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\aes.h"


 





















 
typedef struct
{
    int nr;                      
    uint32_t *rk;                
    uint32_t buf[68];            

    unsigned char enc_key[32];
    unsigned char dec_key[32];

}
aes_context;





 
void polarssl_aes_init( aes_context *ctx );





 
void aes_free( aes_context *ctx );









 
int aes_setkey_enc( aes_context *ctx, const unsigned char *key,
                    unsigned int keysize );









 
int aes_setkey_dec( aes_context *ctx, const unsigned char *key,
                    unsigned int keysize );










 
int aes_crypt_ecb( aes_context *ctx,
                    int mode,
                    const unsigned char input[16],
                    unsigned char output[16] );















 
int aes_crypt_cbc( aes_context *ctx,
                    int mode,
                    size_t length,
                    unsigned char iv[16],
                    const unsigned char *input,
                    unsigned char *output );



















 
int aes_crypt_cfb128( aes_context *ctx,
                       int mode,
                       size_t length,
                       size_t *iv_off,
                       unsigned char iv[16],
                       const unsigned char *input,
                       unsigned char *output );
















 
int aes_crypt_cfb8( aes_context *ctx,
                    int mode,
                    size_t length,
                    unsigned char iv[16],
                    const unsigned char *input,
                    unsigned char *output );
























 
int aes_crypt_ctr( aes_context *ctx,
                       size_t length,
                       size_t *nc_off,
                       unsigned char nonce_counter[16],
                       unsigned char stream_block[16],
                       const unsigned char *input,
                       unsigned char *output );


















 
int aes_self_test( int verbose );





#line 60 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"


#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\x509_crt.h"

























 



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"



#line 11 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"

#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\x509_crt.h"




#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\x509.h"

























 



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"



#line 11 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"

#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\x509.h"




#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\asn1.h"

























 



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"



#line 11 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"

#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\asn1.h"








#line 1 "F:\\IAR\\arm\\inc\\c\\string.h"
 
 
#line 456 "F:\\IAR\\arm\\inc\\c\\string.h"

#line 479 "F:\\IAR\\arm\\inc\\c\\string.h"




 
#line 41 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\asn1.h"




 







 
#line 61 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\asn1.h"

 











 
#line 94 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\asn1.h"
 
 

 









 











 



 
typedef struct _asn1_buf
{
    int tag;                 
    size_t len;              
    unsigned char *p;        
}
asn1_buf;



 
typedef struct _asn1_bitstring
{
    size_t len;                  
    unsigned char unused_bits;   
    unsigned char *p;            
}
asn1_bitstring;



 
typedef struct _asn1_sequence
{
    asn1_buf buf;                    
    struct _asn1_sequence *next;     
}
asn1_sequence;



 
typedef struct _asn1_named_data
{
    asn1_buf oid;                    
    asn1_buf val;                    
    struct _asn1_named_data *next;   
}
asn1_named_data;












 
int asn1_get_len( unsigned char **p,
                  const unsigned char *end,
                  size_t *len );












 
int asn1_get_tag( unsigned char **p,
                  const unsigned char *end,
                  size_t *len, int tag );










 
int asn1_get_bool( unsigned char **p,
                   const unsigned char *end,
                   int *val );










 
int asn1_get_int( unsigned char **p,
                  const unsigned char *end,
                  int *val );










 
int asn1_get_bitstring( unsigned char **p, const unsigned char *end,
                        asn1_bitstring *bs);











 
int asn1_get_bitstring_null( unsigned char **p, const unsigned char *end,
                             size_t *len );











 
int asn1_get_sequence_of( unsigned char **p,
                          const unsigned char *end,
                          asn1_sequence *cur,
                          int tag);











 
int asn1_get_mpi( unsigned char **p,
                  const unsigned char *end,
                  mpi *X );













 
int asn1_get_alg( unsigned char **p,
                  const unsigned char *end,
                  asn1_buf *alg, asn1_buf *params );












 
int asn1_get_alg_null( unsigned char **p,
                       const unsigned char *end,
                       asn1_buf *alg );










 
asn1_named_data *asn1_find_named_data( asn1_named_data *list,
                                       const char *oid, size_t len );





 
void asn1_free_named_data( asn1_named_data *entry );






 
void asn1_free_named_data_list( asn1_named_data **head );





#line 37 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\x509.h"









 




 
#line 70 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\x509.h"
 




 
#line 87 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\x509.h"
 
 



 
#line 100 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\x509.h"




 

#line 114 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\x509.h"






 
#line 136 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\x509.h"






 









 




 



 
typedef asn1_buf x509_buf;



 
typedef asn1_bitstring x509_bitstring;




 
typedef asn1_named_data x509_name;



 
typedef asn1_sequence x509_sequence;

 
typedef struct _x509_time
{
    int year, mon, day;          
    int hour, min, sec;          
}
x509_time;

 
 











 
int x509_dn_gets( char *buf, size_t size, const x509_name *dn );











 
int x509_serial_gets( char *buf, size_t size, const x509_buf *serial );










 
const char *x509_oid_get_description( x509_buf *oid );











 
int x509_oid_get_numeric_string( char *buf, size_t size, x509_buf *oid );









 
int x509_time_expired( const x509_time *time );









 
int x509_time_future( const x509_time *time );





 
int x509_self_test( int verbose );




 
int x509_get_name( unsigned char **p, const unsigned char *end,
                   x509_name *cur );
int x509_get_alg_null( unsigned char **p, const unsigned char *end,
                       x509_buf *alg );
int x509_get_alg( unsigned char **p, const unsigned char *end,
                  x509_buf *alg, x509_buf *params );





int x509_get_sig( unsigned char **p, const unsigned char *end, x509_buf *sig );
int x509_get_sig_alg( const x509_buf *sig_oid, const x509_buf *sig_params,
                      md_type_t *md_alg, pk_type_t *pk_alg,
                      void **sig_opts );
int x509_get_time( unsigned char **p, const unsigned char *end,
                   x509_time *time );
int x509_get_serial( unsigned char **p, const unsigned char *end,
                     x509_buf *serial );
int x509_get_ext( unsigned char **p, const unsigned char *end,
                  x509_buf *ext, int tag );
int x509_load_file( const char *path, unsigned char **buf, size_t *n );
int x509_sig_alg_gets( char *buf, size_t size, const x509_buf *sig_oid,
                       pk_type_t pk_alg, md_type_t md_alg,
                       const void *sig_opts );
int x509_key_size_helper( char *buf, size_t size, const char *name );
int x509_string_to_names( asn1_named_data **head, const char *name );
int x509_set_extension( asn1_named_data **head, const char *oid, size_t oid_len,
                        int critical, const unsigned char *val,
                        size_t val_len );
int x509_write_extensions( unsigned char **p, unsigned char *start,
                           asn1_named_data *first );
int x509_write_names( unsigned char **p, unsigned char *start,
                      asn1_named_data *first );
int x509_write_sig( unsigned char **p, unsigned char *start,
                    const char *oid, size_t oid_len,
                    unsigned char *sig, size_t size );





#line 37 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\x509_crt.h"

#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\x509_crl.h"

























 



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"



#line 11 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"

#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\x509_crl.h"












 




 




 
typedef struct _x509_crl_entry
{
    x509_buf raw;

    x509_buf serial;

    x509_time revocation_date;

    x509_buf entry_ext;

    struct _x509_crl_entry *next;
}
x509_crl_entry;




 
typedef struct _x509_crl
{
    x509_buf raw;            
    x509_buf tbs;            

    int version;             
    x509_buf sig_oid1;

    x509_buf issuer_raw;     

    x509_name issuer;        

    x509_time this_update;
    x509_time next_update;

    x509_crl_entry entry;    

    x509_buf crl_ext;

    x509_buf sig_oid2;
    x509_buf sig;
    md_type_t sig_md;            
    pk_type_t sig_pk;            
    void *sig_opts;              

    struct _x509_crl *next;
}
x509_crl;










 
int x509_crl_parse( x509_crl *chain, const unsigned char *buf, size_t buflen );

#line 126 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\x509_crl.h"











 
int x509_crl_info( char *buf, size_t size, const char *prefix,
                   const x509_crl *crl );





 
void x509_crl_init( x509_crl *crl );





 
void x509_crl_free( x509_crl *crl );

 
 





#line 39 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\x509_crt.h"




 








 



 
typedef struct _x509_crt
{
    x509_buf raw;                
    x509_buf tbs;                

    int version;                 
    x509_buf serial;             
    x509_buf sig_oid1;           

    x509_buf issuer_raw;         
    x509_buf subject_raw;        

    x509_name issuer;            
    x509_name subject;           

    x509_time valid_from;        
    x509_time valid_to;          

    pk_context pk;               

    x509_buf issuer_id;          
    x509_buf subject_id;         
    x509_buf v3_ext;             
    x509_sequence subject_alt_names;     

    int ext_types;               
    int ca_istrue;               
    int max_pathlen;             

    unsigned char key_usage;     

    x509_sequence ext_key_usage;  

    unsigned char ns_cert_type;  

    x509_buf sig_oid2;           
    x509_buf sig;                
    md_type_t sig_md;            
    pk_type_t sig_pk;            
    void *sig_opts;              

    struct _x509_crt *next;      
}
x509_crt;










 
typedef struct _x509write_cert
{
    int version;
    mpi serial;
    pk_context *subject_key;
    pk_context *issuer_key;
    asn1_named_data *subject;
    asn1_named_data *issuer;
    md_type_t md_alg;
    char not_before[15 + 1];
    char not_after[15 + 1];
    asn1_named_data *extensions;
}
x509write_cert;











 
int x509_crt_parse_der( x509_crt *chain, const unsigned char *buf,
                        size_t buflen );














 
int x509_crt_parse( x509_crt *chain, const unsigned char *buf, size_t buflen );

#line 193 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\x509_crt.h"












 
int x509_crt_info( char *buf, size_t size, const char *prefix,
                   const x509_crt *crt );




































 
int x509_crt_verify( x509_crt *crt,
                     x509_crt *trust_ca,
                     x509_crl *ca_crl,
                     const char *cn, int *flags,
                     int (*f_vrfy)(void *, x509_crt *, int, int *),
                     void *p_vrfy );

#line 271 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\x509_crt.h"

#line 289 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\x509_crt.h"

#line 302 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\x509_crt.h"





 
void x509_crt_init( x509_crt *crt );





 
void x509_crt_free( x509_crt *crt );


 
 

#line 553 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\x509_crt.h"





#line 64 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"



















 
#line 90 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"







#line 104 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"



 
#line 148 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"



 






 


#line 176 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"

 


#line 195 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"


 
#line 204 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"









































 













 




 






 







 
#line 291 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"







#line 304 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"



 





 
#line 321 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"








 





 








#line 372 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"

#line 384 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"



 






















 




 




 
union _ssl_premaster_secret
{

    unsigned char _pms_rsa[48];                          
#line 449 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"
};










 
typedef int (*rsa_decrypt_func)( void *ctx, int mode, size_t *olen,
                        const unsigned char *input, unsigned char *output,
                        size_t output_max_len );
typedef int (*rsa_sign_func)( void *ctx,
                     int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,
                     int mode, md_type_t md_alg, unsigned int hashlen,
                     const unsigned char *hash, unsigned char *sig );
typedef size_t (*rsa_key_len_func)( void *ctx );



 
typedef enum
{
    SSL_HELLO_REQUEST,
    SSL_CLIENT_HELLO,
    SSL_SERVER_HELLO,
    SSL_SERVER_CERTIFICATE,
    SSL_SERVER_KEY_EXCHANGE,
    SSL_CERTIFICATE_REQUEST,
    SSL_SERVER_HELLO_DONE,
    SSL_CLIENT_CERTIFICATE,
    SSL_CLIENT_KEY_EXCHANGE,
    SSL_CERTIFICATE_VERIFY,
    SSL_CLIENT_CHANGE_CIPHER_SPEC,
    SSL_CLIENT_FINISHED,
    SSL_SERVER_CHANGE_CIPHER_SPEC,
    SSL_SERVER_FINISHED,
    SSL_FLUSH_BUFFERS,
    SSL_HANDSHAKE_WRAPUP,
    SSL_HANDSHAKE_OVER,
    SSL_SERVER_NEW_SESSION_TICKET,
}
ssl_states;

typedef struct _ssl_session ssl_session;
typedef struct _ssl_context ssl_context;
typedef struct _ssl_transform ssl_transform;
typedef struct _ssl_handshake_params ssl_handshake_params;

typedef struct _ssl_ticket_keys ssl_ticket_keys;


typedef struct _ssl_key_cert ssl_key_cert;




 
struct _ssl_session
{



    int ciphersuite;             
    int compression;             
    size_t length;               
    unsigned char id[32];        
    unsigned char master[48];    


    x509_crt *peer_cert;         

    int verify_result;           


    unsigned char *ticket;       
    size_t ticket_len;           
    uint32_t ticket_lifetime;    



    unsigned char mfl_code;      



    int trunc_hmac;              

};




 
struct _ssl_transform
{
    

 
    const ssl_ciphersuite_t *ciphersuite_info;
                                         
    unsigned int keylen;                 
    size_t minlen;                       
    size_t ivlen;                        
    size_t fixed_ivlen;                  
    size_t maclen;                       

    unsigned char iv_enc[16];            
    unsigned char iv_dec[16];            


     
    unsigned char mac_enc[48];           
    unsigned char mac_dec[48];           


    md_context_t md_ctx_enc;             
    md_context_t md_ctx_dec;             

    cipher_context_t cipher_ctx_enc;     
    cipher_context_t cipher_ctx_dec;     

    

 




};



 
struct _ssl_handshake_params
{
    

 
    int sig_alg;                         
    int cert_type;                       
    int verify_sig_alg;                  
#line 603 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"
    




 
    ssl_key_cert *key_cert;

    ssl_key_cert *sni_key_cert;          



    

 


       md5_context fin_md5;
      sha1_context fin_sha1;



    sha256_context fin_sha256;


    sha512_context fin_sha512;



    void (*update_checksum)(ssl_context *, const unsigned char *, size_t);
    void (*calc_verify)(ssl_context *, unsigned char *);
    void (*calc_finished)(ssl_context *, unsigned char *, int);
    int  (*tls_prf)(const unsigned char *, size_t, const char *,
                    const unsigned char *, size_t,
                    unsigned char *, size_t);

    size_t pmslen;                       

    unsigned char randbytes[64];         
    unsigned char premaster[sizeof( union _ssl_premaster_secret )];
                                         

    int resume;                          
    int max_major_ver;                   
    int max_minor_ver;                   
    int cli_exts;                        


    int new_session_ticket;              

};




 
struct _ssl_ticket_keys
{
    unsigned char key_name[16];      
    aes_context enc;                 
    aes_context dec;                 
    unsigned char mac_key[16];       
};





 
struct _ssl_key_cert
{
    x509_crt *cert;                  
    pk_context *key;                 
    int key_own_alloc;               
    ssl_key_cert *next;              
};


struct _ssl_context
{
    

 
    int state;                   
    int renegotiation;           
    int renego_records_seen;     

    int major_ver;               
    int minor_ver;               

    int max_major_ver;           
    int max_minor_ver;           
    int min_major_ver;           
    int min_minor_ver;           

    

 
    int  (*f_rng)(void *, unsigned char *, size_t);
    void (*f_dbg)(void *, int, const char *);
    int (*f_recv)(void *, unsigned char *, size_t);
    int (*f_send)(void *, const unsigned char *, size_t);
    int (*f_get_cache)(void *, ssl_session *);
    int (*f_set_cache)(void *, const ssl_session *);

    void *p_rng;                 
    void *p_dbg;                 
    void *p_recv;                
    void *p_send;                
    void *p_get_cache;           
    void *p_set_cache;           
    void *p_hw_data;             


    int (*f_sni)(void *, ssl_context *, const unsigned char *, size_t);
    void *p_sni;                 



    int (*f_vrfy)(void *, x509_crt *, int, int *);
    void *p_vrfy;                







    

 
    ssl_session *session_in;             
    ssl_session *session_out;            
    ssl_session *session;                
    ssl_session *session_negotiate;      

    ssl_handshake_params *handshake;    
 

    

 
    ssl_transform *transform_in;         
    ssl_transform *transform_out;        
    ssl_transform *transform;            
    ssl_transform *transform_negotiate;  

    

 
    unsigned char *in_ctr;       
    unsigned char *in_hdr;       
    unsigned char *in_iv;        
    unsigned char *in_msg;       
    unsigned char *in_offt;      

    int in_msgtype;              
    size_t in_msglen;            
    size_t in_left;              

    size_t in_hslen;             
    int nb_zero;                 
    int record_read;             

    

 
    unsigned char *out_ctr;      
    unsigned char *out_hdr;      
    unsigned char *out_iv;       
    unsigned char *out_msg;      

    int out_msgtype;             
    size_t out_msglen;           
    size_t out_left;             





    unsigned char mfl_code;      


    

 

    ssl_key_cert *key_cert;              

    x509_crt *ca_chain;                  
    x509_crl *ca_crl;                    
    const char *peer_cn;                 


    

 

    ssl_ticket_keys *ticket_keys;        


    

 
    int endpoint;                        
    int authmode;                        
    int client_auth;                     
    int verify_result;                   
    int disable_renegotiation;           
    int allow_legacy_renegotiation;      
    int renego_max_records;              
    const int *ciphersuite_list[4];      




    int trunc_hmac;                      


    int session_tickets;                 
    int ticket_lifetime;                 







#line 840 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"


    

 
    unsigned char *hostname;
    size_t         hostname_len;


#line 856 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"

    

 
    int secure_renegotiation;           
 
    size_t verify_data_len;              
    char own_verify_data[36];            
    char peer_verify_data[36];           
};

#line 885 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"






 
const int *ssl_list_ciphersuites( void );








 
const char *ssl_get_ciphersuite_name( const int ciphersuite_id );








 
int ssl_get_ciphersuite_id( const char *ciphersuite_name );









 
int ssl_init( ssl_context *ssl );










 
int ssl_session_reset( ssl_context *ssl );









 
void ssl_set_endpoint( ssl_context *ssl, int endpoint );























 
void ssl_set_authmode( ssl_context *ssl, int authmode );












 
void ssl_set_verify( ssl_context *ssl,
                     int (*f_vrfy)(void *, x509_crt *, int, int *),
                     void *p_vrfy );








 
void ssl_set_rng( ssl_context *ssl,
                  int (*f_rng)(void *, unsigned char *, size_t),
                  void *p_rng );







 
void ssl_set_dbg( ssl_context *ssl,
                  void (*f_dbg)(void *, int, const char *),
                  void  *p_dbg );









 
void ssl_set_bio( ssl_context *ssl,
        int (*f_recv)(void *, unsigned char *, size_t), void *p_recv,
        int (*f_send)(void *, const unsigned char *, size_t), void *p_send );





































 
void ssl_set_session_cache( ssl_context *ssl,
        int (*f_get_cache)(void *, ssl_session *), void *p_get_cache,
        int (*f_set_cache)(void *, const ssl_session *), void *p_set_cache );














 
int ssl_set_session( ssl_context *ssl, const ssl_session *session );












 
void ssl_set_ciphersuites( ssl_context *ssl, const int *ciphersuites );













 
void ssl_set_ciphersuites_for_version( ssl_context *ssl,
                                       const int *ciphersuites,
                                       int major, int minor );









 
void ssl_set_ca_chain( ssl_context *ssl, x509_crt *ca_chain,
                       x509_crl *ca_crl, const char *peer_cn );


















 
int ssl_set_own_cert( ssl_context *ssl, x509_crt *own_cert,
                       pk_context *pk_key );

















 
int ssl_set_own_cert_rsa( ssl_context *ssl, x509_crt *own_cert,
                          rsa_context *rsa_key );


























 
int ssl_set_own_cert_alt( ssl_context *ssl, x509_crt *own_cert,
                          void *rsa_key,
                          rsa_decrypt_func rsa_decrypt,
                          rsa_sign_func rsa_sign,
                          rsa_key_len_func rsa_key_len );


#line 1240 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"

#line 1266 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"

#line 1288 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"











 
int ssl_set_hostname( ssl_context *ssl, const char *hostname );



















 
void ssl_set_sni( ssl_context *ssl,
                  int (*f_sni)(void *, ssl_context *, const unsigned char *,
                               size_t),
                  void *p_sni );


#line 1350 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\ssl.h"















 
void ssl_set_max_version( ssl_context *ssl, int major, int minor );














 
void ssl_set_min_version( ssl_context *ssl, int major, int minor );
















 
int ssl_set_max_frag_len( ssl_context *ssl, unsigned char mfl_code );













 
int ssl_set_truncated_hmac( ssl_context *ssl, int truncate );


















 
int ssl_set_session_tickets( ssl_context *ssl, int use_tickets );







 
void ssl_set_session_ticket_lifetime( ssl_context *ssl, int lifetime );














 
void ssl_set_renegotiation( ssl_context *ssl, int renegotiation );



























 
void ssl_legacy_renegotiation( ssl_context *ssl, int allow_legacy );

























 
void ssl_set_renegotiation_enforced( ssl_context *ssl, int max_records );







 
size_t ssl_get_bytes_avail( const ssl_context *ssl );











 
int ssl_get_verify_result( const ssl_context *ssl );







 
const char *ssl_get_ciphersuite( const ssl_context *ssl );







 
const char *ssl_get_version( const ssl_context *ssl );















 
const x509_crt *ssl_get_peer_cert( const ssl_context *ssl );

















 
int ssl_get_session( const ssl_context *ssl, ssl_session *session );








 
int ssl_handshake( ssl_context *ssl );












 
int ssl_handshake_step( ssl_context *ssl );










 
int ssl_renegotiate( ssl_context *ssl );










 
int ssl_read( ssl_context *ssl, unsigned char *buf, size_t len );














 
int ssl_write( ssl_context *ssl, const unsigned char *buf, size_t len );










 
int ssl_send_alert_message( ssl_context *ssl,
                            unsigned char level,
                            unsigned char message );




 
int ssl_close_notify( ssl_context *ssl );





 
void ssl_free( ssl_context *ssl );





 
void ssl_session_init( ssl_session *session );






 
void ssl_session_free( ssl_session *session );






 
void ssl_transform_free( ssl_transform *transform );






 
void ssl_handshake_free( ssl_handshake_params *handshake );



 
int ssl_handshake_client_step( ssl_context *ssl );
int ssl_handshake_server_step( ssl_context *ssl );
void ssl_handshake_wrapup( ssl_context *ssl );

int ssl_send_fatal_handshake_failure( ssl_context *ssl );

int ssl_derive_keys( ssl_context *ssl );

int ssl_read_record( ssl_context *ssl );



 
int ssl_fetch_input( ssl_context *ssl, size_t nb_want );

int ssl_write_record( ssl_context *ssl );
int ssl_flush_output( ssl_context *ssl );

int ssl_parse_certificate( ssl_context *ssl );
int ssl_write_certificate( ssl_context *ssl );

int ssl_parse_change_cipher_spec( ssl_context *ssl );
int ssl_write_change_cipher_spec( ssl_context *ssl );

int ssl_parse_finished( ssl_context *ssl );
int ssl_write_finished( ssl_context *ssl );

void ssl_optimize_checksum( ssl_context *ssl,
                            const ssl_ciphersuite_t *ciphersuite_info );






unsigned char ssl_sig_from_pk( pk_context *pk );
pk_type_t ssl_pk_alg_from_sig( unsigned char sig );


md_type_t ssl_md_alg_from_hash( unsigned char hash );






static inline pk_context *ssl_own_key( ssl_context *ssl )
{
    return( ssl->handshake->key_cert == 0 ? 0
            : ssl->handshake->key_cert->key );
}

static inline x509_crt *ssl_own_cert( ssl_context *ssl )
{
    return( ssl->handshake->key_cert == 0 ? 0
            : ssl->handshake->key_cert->cert );
}









 
int ssl_check_cert_usage( const x509_crt *cert,
                          const ssl_ciphersuite_t *ciphersuite,
                          int cert_endpoint );


 
static inline int safer_memcmp( const void *a, const void *b, size_t n )
{
    size_t i;
    const unsigned char *A = (const unsigned char *) a;
    const unsigned char *B = (const unsigned char *) b;
    unsigned char diff = 0;

    for( i = 0; i < n; i++ )
        diff |= A[i] ^ B[i];

    return( diff );
}





#line 36 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl/debug.h"




#line 85 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl/debug.h"

#line 92 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl/debug.h"













 
void debug_set_log_mode( int log_mode );







 
void debug_set_threshold( int threshold );

char *debug_fmt( const char *format, ... );

void debug_print_msg( const ssl_context *ssl, int level,
                      const char *file, int line, const char *text );

void debug_print_ret( const ssl_context *ssl, int level,
                      const char *file, int line,
                      const char *text, int ret );

void debug_print_buf( const ssl_context *ssl, int level,
                      const char *file, int line, const char *text,
                      unsigned char *buf, size_t len );


void debug_print_mpi( const ssl_context *ssl, int level,
                      const char *file, int line,
                      const char *text, const mpi *X );









void debug_print_crt( const ssl_context *ssl, int level,
                      const char *file, int line,
                      const char *text, const x509_crt *crt );






#line 43 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"







#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl/platform.h"

























 



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"



#line 11 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl\\config.h"

#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl/platform.h"




#line 1 "F:\\IAR\\arm\\inc\\c\\stdio.h"
 
 
#line 241 "F:\\IAR\\arm\\inc\\c\\stdio.h"

#line 292 "F:\\IAR\\arm\\inc\\c\\stdio.h"




 
#line 37 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl/platform.h"

#line 44 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl/platform.h"






 

#line 71 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl/platform.h"

 



 
#line 95 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl/platform.h"



 
#line 113 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl/platform.h"



 
#line 125 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\ssl\\polarssl-1.3.8\\include\\polarssl/platform.h"





#line 52 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"





#line 1 "F:\\IAR\\arm\\inc\\c\\stdlib.h"
 
 

#line 468 "F:\\IAR\\arm\\inc\\c\\stdlib.h"

#line 494 "F:\\IAR\\arm\\inc\\c\\stdlib.h"




 
#line 58 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"






 
static void polarssl_zeroize( void *v, size_t n ) {
    volatile unsigned char *p = v; while( n-- ) *p++ = 0;
}









 
static unsigned int mfl_code_to_length[5] =
{
    5120,     
    512,                     
    1024,                    
    2048,                    
    4096,                    
};


static int ssl_session_copy( ssl_session *dst, const ssl_session *src )
{
    ssl_session_free( dst );
    _memcpy(dst, src, sizeof( ssl_session ));


    if( src->peer_cert != 0 )
    {
        int ret;

        dst->peer_cert = (x509_crt *) rom_ssl_ram_map . ssl_malloc( sizeof(x509_crt) );
        if( dst->peer_cert == 0 )
            return( -0x7F00 );

        x509_crt_init( dst->peer_cert );

        if( ( ret = x509_crt_parse_der( dst->peer_cert, src->peer_cert->raw.p,
                                        src->peer_cert->raw.len ) ) != 0 )
        {
            rom_ssl_ram_map . ssl_free( dst->peer_cert );
            dst->peer_cert = 0;
            return( ret );
        }
    }



    if( src->ticket != 0 )
    {
        dst->ticket = (unsigned char *) rom_ssl_ram_map . ssl_malloc( src->ticket_len );
        if( dst->ticket == 0 )
            return( -0x7F00 );

        _memcpy(dst->ticket, src->ticket, src->ticket_len);
    }


    return( 0 );
}

#line 142 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"



 

static int ssl3_prf( const unsigned char *secret, size_t slen,
                     const char *label,
                     const unsigned char *random, size_t rlen,
                     unsigned char *dstbuf, size_t dlen )
{
    size_t i;
    md5_context md5;
    sha1_context sha1;
    unsigned char padding[16];
    unsigned char sha1sum[20];
    ((void)label);

    md5_init(  &md5  );
    sha1_init( &sha1 );

    






 
    for( i = 0; i < dlen / 16; i++ )
    {
        _memset(padding, (unsigned char) ('A' + i), 1 + i);

        sha1_starts( &sha1 );
        sha1_update( &sha1, padding, 1 + i );
        sha1_update( &sha1, secret, slen );
        sha1_update( &sha1, random, rlen );
        sha1_finish( &sha1, sha1sum );

        md5_starts( &md5 );
        md5_update( &md5, secret, slen );
        md5_update( &md5, sha1sum, 20 );
        md5_finish( &md5, dstbuf + i * 16 );
    }

    md5_free(  &md5  );
    sha1_free( &sha1 );

    polarssl_zeroize( padding, sizeof( padding ) );
    polarssl_zeroize( sha1sum, sizeof( sha1sum ) );

    return( 0 );
}



static int tls1_prf( const unsigned char *secret, size_t slen,
                     const char *label,
                     const unsigned char *random, size_t rlen,
                     unsigned char *dstbuf, size_t dlen )
{
    size_t nb, hs;
    size_t i, j, k;
    const unsigned char *S1, *S2;
    unsigned char tmp[128];
    unsigned char h_i[20];

    if( sizeof( tmp ) < 20 + prvStrLen((const unsigned char *) label) + rlen )
        return( -0x7100 );

    hs = ( slen + 1 ) / 2;
    S1 = secret;
    S2 = secret + slen - hs;

    nb = prvStrLen((const unsigned char *) label);
    _memcpy(tmp + 20, label, nb);
    _memcpy(tmp + 20 + nb, random, rlen);
    nb += rlen;

    

 
    md5_hmac( S1, hs, tmp + 20, nb, 4 + tmp );

    for( i = 0; i < dlen; i += 16 )
    {
        md5_hmac( S1, hs, 4 + tmp, 16 + nb, h_i );
        md5_hmac( S1, hs, 4 + tmp, 16,  4 + tmp );

        k = ( i + 16 > dlen ) ? dlen % 16 : 16;

        for( j = 0; j < k; j++ )
            dstbuf[i + j]  = h_i[j];
    }

    

 
    sha1_hmac( S2, hs, tmp + 20, nb, tmp );

    for( i = 0; i < dlen; i += 20 )
    {
        sha1_hmac( S2, hs, tmp, 20 + nb, h_i );
        sha1_hmac( S2, hs, tmp, 20,      tmp );

        k = ( i + 20 > dlen ) ? dlen % 20 : 20;

        for( j = 0; j < k; j++ )
            dstbuf[i + j] = (unsigned char)( dstbuf[i + j] ^ h_i[j] );
    }

    polarssl_zeroize( tmp, sizeof( tmp ) );
    polarssl_zeroize( h_i, sizeof( h_i ) );

    return( 0 );
}




static int tls_prf_sha256( const unsigned char *secret, size_t slen,
                           const char *label,
                           const unsigned char *random, size_t rlen,
                           unsigned char *dstbuf, size_t dlen )
{
    size_t nb;
    size_t i, j, k;
    unsigned char tmp[128];
    unsigned char h_i[32];

    if( sizeof( tmp ) < 32 + prvStrLen((const unsigned char *) label) + rlen )
        return( -0x7100 );

    nb = prvStrLen((const unsigned char *) label);
    _memcpy(tmp + 32, label, nb);
    _memcpy(tmp + 32 + nb, random, rlen);
    nb += rlen;

    

 
    sha256_hmac( secret, slen, tmp + 32, nb, tmp, 0 );

    for( i = 0; i < dlen; i += 32 )
    {
        sha256_hmac( secret, slen, tmp, 32 + nb, h_i, 0 );
        sha256_hmac( secret, slen, tmp, 32,      tmp, 0 );

        k = ( i + 32 > dlen ) ? dlen % 32 : 32;

        for( j = 0; j < k; j++ )
            dstbuf[i + j]  = h_i[j];
    }

    polarssl_zeroize( tmp, sizeof( tmp ) );
    polarssl_zeroize( h_i, sizeof( h_i ) );

    return( 0 );
}



static int tls_prf_sha384( const unsigned char *secret, size_t slen,
                           const char *label,
                           const unsigned char *random, size_t rlen,
                           unsigned char *dstbuf, size_t dlen )
{
    size_t nb;
    size_t i, j, k;
    unsigned char tmp[128];
    unsigned char h_i[48];

    if( sizeof( tmp ) < 48 + prvStrLen((const unsigned char *) label) + rlen )
        return( -0x7100 );

    nb = prvStrLen((const unsigned char *) label);
    _memcpy(tmp + 48, label, nb);
    _memcpy(tmp + 48 + nb, random, rlen);
    nb += rlen;

    

 
    sha512_hmac( secret, slen, tmp + 48, nb, tmp, 1 );

    for( i = 0; i < dlen; i += 48 )
    {
        sha512_hmac( secret, slen, tmp, 48 + nb, h_i, 1 );
        sha512_hmac( secret, slen, tmp, 48,      tmp, 1 );

        k = ( i + 48 > dlen ) ? dlen % 48 : 48;

        for( j = 0; j < k; j++ )
            dstbuf[i + j]  = h_i[j];
    }

    polarssl_zeroize( tmp, sizeof( tmp ) );
    polarssl_zeroize( h_i, sizeof( h_i ) );

    return( 0 );
}



static void ssl_update_checksum_start( ssl_context *, const unsigned char *, size_t );



static void ssl_update_checksum_md5sha1( ssl_context *, const unsigned char *, size_t );



static void ssl_calc_verify_ssl( ssl_context *, unsigned char * );
static void ssl_calc_finished_ssl( ssl_context *, unsigned char *, int );



static void ssl_calc_verify_tls( ssl_context *, unsigned char * );
static void ssl_calc_finished_tls( ssl_context *, unsigned char *, int );




static void ssl_update_checksum_sha256( ssl_context *, const unsigned char *, size_t );
static void ssl_calc_verify_tls_sha256( ssl_context *,unsigned char * );
static void ssl_calc_finished_tls_sha256( ssl_context *,unsigned char *, int );



static void ssl_update_checksum_sha384( ssl_context *, const unsigned char *, size_t );
static void ssl_calc_verify_tls_sha384( ssl_context *, unsigned char * );
static void ssl_calc_finished_tls_sha384( ssl_context *, unsigned char *, int );



int ssl_derive_keys( ssl_context *ssl )
{
    int ret = 0;
    unsigned char tmp[64];
    unsigned char keyblk[256];
    unsigned char *key1;
    unsigned char *key2;
    unsigned char *mac_enc;
    unsigned char *mac_dec;
    size_t iv_copy_len;
    const cipher_info_t *cipher_info;
    const md_info_t *md_info;

    ssl_session *session = ssl->session_negotiate;
    ssl_transform *transform = ssl->transform_negotiate;
    ssl_handshake_params *handshake = ssl->handshake;

    do { } while( 0 );

    cipher_info = cipher_info_from_type( transform->ciphersuite_info->cipher );
    if( cipher_info == 0 )
    {
        do { } while( 0 );

        return( -0x7100 );
    }

    md_info = md_info_from_type( transform->ciphersuite_info->mac );
    if( md_info == 0 )
    {
        do { } while( 0 );

        return( -0x7100 );
    }

    

 

    if( ssl->minor_ver == 0 )
    {
        handshake->tls_prf = ssl3_prf;
        handshake->calc_verify = ssl_calc_verify_ssl;
        handshake->calc_finished = ssl_calc_finished_ssl;
    }
    else


    if( ssl->minor_ver < 3 )
    {
        handshake->tls_prf = tls1_prf;
        handshake->calc_verify = ssl_calc_verify_tls;
        handshake->calc_finished = ssl_calc_finished_tls;
    }
    else



    if( ssl->minor_ver == 3 &&
        transform->ciphersuite_info->mac == POLARSSL_MD_SHA384 )
    {
        handshake->tls_prf = tls_prf_sha384;
        handshake->calc_verify = ssl_calc_verify_tls_sha384;
        handshake->calc_finished = ssl_calc_finished_tls_sha384;
    }
    else


    if( ssl->minor_ver == 3 )
    {
        handshake->tls_prf = tls_prf_sha256;
        handshake->calc_verify = ssl_calc_verify_tls_sha256;
        handshake->calc_finished = ssl_calc_finished_tls_sha256;
    }
    else


    {
        do { } while( 0 );
        return( -0x6C00 );
    }

    








 
    if( handshake->resume == 0 )
    {
        do { } while( 0 );


        handshake->tls_prf( handshake->premaster, handshake->pmslen,
                            "master secret",
                            handshake->randbytes, 64, session->master, 48 );

        polarssl_zeroize( handshake->premaster, sizeof(handshake->premaster) );
    }
    else
        do { } while( 0 );

    

 
    _memcpy(tmp, handshake ->randbytes, 64);
    _memcpy(handshake ->randbytes, tmp + 32, 32);
    _memcpy(handshake ->randbytes + 32, tmp, 32);
    polarssl_zeroize( tmp, sizeof( tmp ) );

    










 
    handshake->tls_prf( session->master, 48, "key expansion",
                        handshake->randbytes, 64, keyblk, 256 );

    do { } while( 0 );

    do { } while( 0 );
    do { } while( 0 );
    do { } while( 0 );

    polarssl_zeroize( handshake->randbytes, sizeof( handshake->randbytes ) );

    

 

    transform->keylen = cipher_info->key_length / 8;

    if( cipher_info->mode == POLARSSL_MODE_GCM ||
        cipher_info->mode == POLARSSL_MODE_CCM )
    {
        transform->maclen = 0;

        transform->ivlen = 12;
        transform->fixed_ivlen = 4;

         
        transform->minlen = transform->ivlen - transform->fixed_ivlen
                            + ( transform->ciphersuite_info->flags &
                                0x02 ? 8 : 16 );
    }
    else
    {
        int ret;

         
        if( ( ret = md_init_ctx( &transform->md_ctx_enc, md_info ) ) != 0 ||
            ( ret = md_init_ctx( &transform->md_ctx_dec, md_info ) ) != 0 )
        {
            do { } while( 0 );
            return( ret );
        }

         
        transform->maclen = md_get_size( md_info );


        



 
        if( session->trunc_hmac == 1 )
            transform->maclen = 10;


         
        transform->ivlen = cipher_info->iv_size;

         
        if( cipher_info->mode == POLARSSL_MODE_STREAM )
            transform->minlen = transform->maclen;
        else
        {
            



 
            transform->minlen = transform->maclen
                                + cipher_info->block_size
                                - transform->maclen % cipher_info->block_size;


            if( ssl->minor_ver == 0 ||
                ssl->minor_ver == 1 )
                ;  
            else


            if( ssl->minor_ver == 2 ||
                ssl->minor_ver == 3 )
            {
                transform->minlen += transform->ivlen;
            }
            else

            {
                do { } while( 0 );
                return( -0x6C00 );
            }
        }
    }

    do { } while( 0 );



    

 
    if( ssl->endpoint == 0 )
    {
        key1 = keyblk + transform->maclen * 2;
        key2 = keyblk + transform->maclen * 2 + transform->keylen;

        mac_enc = keyblk;
        mac_dec = keyblk + transform->maclen;

        

 
        iv_copy_len = ( transform->fixed_ivlen ) ?
                            transform->fixed_ivlen : transform->ivlen;
        _memcpy(transform->iv_enc, key2 + transform->keylen, iv_copy_len);
        _memcpy(transform->iv_dec, key2 + transform->keylen + iv_copy_len, iv_copy_len);

    }
    else
    {
        key1 = keyblk + transform->maclen * 2 + transform->keylen;
        key2 = keyblk + transform->maclen * 2;

        mac_enc = keyblk + transform->maclen;
        mac_dec = keyblk;

        

 
        iv_copy_len = ( transform->fixed_ivlen ) ?
                            transform->fixed_ivlen : transform->ivlen;
        _memcpy(transform->iv_dec, key1 + transform->keylen, iv_copy_len);
        _memcpy(transform->iv_enc, key1 + transform->keylen + iv_copy_len, iv_copy_len);

    }


    if( ssl->minor_ver == 0 )
    {
        if( transform->maclen > sizeof transform->mac_enc )
        {
            do { } while( 0 );
            return( -0x6C00 );
        }

        _memcpy(transform->mac_enc, mac_enc, transform->maclen);
        _memcpy(transform->mac_dec, mac_dec, transform->maclen);
    }
    else



    if( ssl->minor_ver >= 1 )
    {
        md_hmac_starts( &transform->md_ctx_enc, mac_enc, transform->maclen );
        md_hmac_starts( &transform->md_ctx_dec, mac_dec, transform->maclen );
    }
    else

    {
        do { } while( 0 );
        return( -0x6C00 );
    }

#line 683 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"

    if( ( ret = cipher_init_ctx( &transform->cipher_ctx_enc,
                                 cipher_info ) ) != 0 )
    {
        do { } while( 0 );
        return( ret );
    }

    if( ( ret = cipher_init_ctx( &transform->cipher_ctx_dec,
                                 cipher_info ) ) != 0 )
    {
        do { } while( 0 );
        return( ret );
    }

    if( ( ret = cipher_setkey( &transform->cipher_ctx_enc, key1,
                               cipher_info->key_length,
                               POLARSSL_ENCRYPT ) ) != 0 )
    {
        do { } while( 0 );
        return( ret );
    }

    if( ( ret = cipher_setkey( &transform->cipher_ctx_dec, key2,
                               cipher_info->key_length,
                               POLARSSL_DECRYPT ) ) != 0 )
    {
        do { } while( 0 );
        return( ret );
    }


    if( cipher_info->mode == POLARSSL_MODE_CBC )
    {
        if( ( ret = cipher_set_padding_mode( &transform->cipher_ctx_enc,
                                             POLARSSL_PADDING_NONE ) ) != 0 )
        {
            do { } while( 0 );
            return( ret );
        }

        if( ( ret = cipher_set_padding_mode( &transform->cipher_ctx_dec,
                                             POLARSSL_PADDING_NONE ) ) != 0 )
        {
            do { } while( 0 );
            return( ret );
        }
    }


    polarssl_zeroize( keyblk, sizeof( keyblk ) );

#line 766 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"

    do { } while( 0 );

    return( 0 );
}


void ssl_calc_verify_ssl( ssl_context *ssl, unsigned char hash[36] )
{
    md5_context md5;
    sha1_context sha1;
    unsigned char pad_1[48];
    unsigned char pad_2[48];

    do { } while( 0 );

    _memcpy(&md5, &ssl->handshake ->fin_md5, sizeof(md5_context));
    _memcpy(&sha1, &ssl->handshake ->fin_sha1, sizeof(sha1_context));

    _memset(pad_1, 0x36, 48);
    _memset(pad_2, 0x5C, 48);

    md5_update( &md5, ssl->session_negotiate->master, 48 );
    md5_update( &md5, pad_1, 48 );
    md5_finish( &md5, hash );

    md5_starts( &md5 );
    md5_update( &md5, ssl->session_negotiate->master, 48 );
    md5_update( &md5, pad_2, 48 );
    md5_update( &md5, hash,  16 );
    md5_finish( &md5, hash );

    sha1_update( &sha1, ssl->session_negotiate->master, 48 );
    sha1_update( &sha1, pad_1, 40 );
    sha1_finish( &sha1, hash + 16 );

    sha1_starts( &sha1 );
    sha1_update( &sha1, ssl->session_negotiate->master, 48 );
    sha1_update( &sha1, pad_2, 40 );
    sha1_update( &sha1, hash + 16, 20 );
    sha1_finish( &sha1, hash + 16 );

    do { } while( 0 );
    do { } while( 0 );

    md5_free(  &md5  );
    sha1_free( &sha1 );

    return;
}



void ssl_calc_verify_tls( ssl_context *ssl, unsigned char hash[36] )
{
    md5_context md5;
    sha1_context sha1;

    do { } while( 0 );

    _memcpy(&md5, &ssl->handshake ->fin_md5, sizeof(md5_context));
    _memcpy(&sha1, &ssl->handshake ->fin_sha1, sizeof(sha1_context));

     md5_finish( &md5,  hash );
    sha1_finish( &sha1, hash + 16 );

    do { } while( 0 );
    do { } while( 0 );

    md5_free(  &md5  );
    sha1_free( &sha1 );

    return;
}




void ssl_calc_verify_tls_sha256( ssl_context *ssl, unsigned char hash[32] )
{
    sha256_context sha256;

    do { } while( 0 );

    _memcpy(&sha256, &ssl->handshake ->fin_sha256, sizeof(sha256_context));
    sha256_finish( &sha256, hash );

    do { } while( 0 );
    do { } while( 0 );

    sha256_free( &sha256 );

    return;
}



void ssl_calc_verify_tls_sha384( ssl_context *ssl, unsigned char hash[48] )
{
    sha512_context sha512;

    do { } while( 0 );

    _memcpy(&sha512, &ssl->handshake ->fin_sha512, sizeof(sha512_context));
    sha512_finish( &sha512, hash );

    do { } while( 0 );
    do { } while( 0 );

    sha512_free( &sha512 );

    return;
}



#line 983 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"




 
static void ssl_mac( md_context_t *md_ctx, unsigned char *secret,
                     unsigned char *buf, size_t len,
                     unsigned char *ctr, int type )
{
    unsigned char header[11];
    unsigned char padding[48];
    int padlen = 0;
    int md_size = md_get_size( md_ctx->md_info );
    int md_type = md_get_type( md_ctx->md_info );

    if( md_type == POLARSSL_MD_MD5 )
        padlen = 48;
    else if( md_type == POLARSSL_MD_SHA1 )
        padlen = 40;
    else if( md_type == POLARSSL_MD_SHA256 )
        padlen = 32;
    else if( md_type == POLARSSL_MD_SHA384 )
        padlen = 16;

    _memcpy(header, ctr, 8);
    header[ 8] = (unsigned char)  type;
    header[ 9] = (unsigned char)( len >> 8 );
    header[10] = (unsigned char)( len      );

    _memset(padding, 0x36, padlen);
    md_starts( md_ctx );
    md_update( md_ctx, secret,  md_size );
    md_update( md_ctx, padding, padlen  );
    md_update( md_ctx, header,  11      );
    md_update( md_ctx, buf,     len     );
    md_finish( md_ctx, buf +    len     );

    _memset(padding, 0x5C, padlen);
    md_starts( md_ctx );
    md_update( md_ctx, secret,    md_size );
    md_update( md_ctx, padding,   padlen  );
    md_update( md_ctx, buf + len, md_size );
    md_finish( md_ctx, buf + len          );
}




 
static int ssl_encrypt_buf( ssl_context *ssl )
{
    size_t i;
    const cipher_mode_t mode = cipher_get_cipher_mode(
                                        &ssl->transform_out->cipher_ctx_enc );

    do { } while( 0 );

    

 



    if( mode != POLARSSL_MODE_GCM &&
        mode != POLARSSL_MODE_CCM )
    {

        if( ssl->minor_ver == 0 )
        {
            ssl_mac( &ssl->transform_out->md_ctx_enc,
                      ssl->transform_out->mac_enc,
                      ssl->out_msg, ssl->out_msglen,
                      ssl->out_ctr, ssl->out_msgtype );
        }
        else



        if( ssl->minor_ver >= 1 )
        {
            md_hmac_update( &ssl->transform_out->md_ctx_enc, ssl->out_ctr, 13 );
            md_hmac_update( &ssl->transform_out->md_ctx_enc,
                             ssl->out_msg, ssl->out_msglen );
            md_hmac_finish( &ssl->transform_out->md_ctx_enc,
                             ssl->out_msg + ssl->out_msglen );
            md_hmac_reset( &ssl->transform_out->md_ctx_enc );
        }
        else

        {
            do { } while( 0 );
            return( -0x6C00 );
        }

        do { } while( 0 );



        ssl->out_msglen += ssl->transform_out->maclen;
    }


    

 

    if( mode == POLARSSL_MODE_STREAM )
    {
        int ret;
        size_t olen = 0;

        do { } while( 0 );



        do { } while( 0 );


        if( ( ret = cipher_crypt( &ssl->transform_out->cipher_ctx_enc,
                                   ssl->transform_out->iv_enc,
                                   ssl->transform_out->ivlen,
                                   ssl->out_msg, ssl->out_msglen,
                                   ssl->out_msg, &olen ) ) != 0 )
        {
            do { } while( 0 );
            return( ret );
        }

        if( ssl->out_msglen != olen )
        {
            do { } while( 0 );
            return( -0x6C00 );
        }
    }
    else
#line 1200 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"
    if( mode == POLARSSL_MODE_CBC )
    {
        int ret;
        unsigned char *enc_msg;
        size_t enc_msglen, padlen, olen = 0;

        padlen = ssl->transform_out->ivlen - ( ssl->out_msglen + 1 ) %
                 ssl->transform_out->ivlen;
        if( padlen == ssl->transform_out->ivlen )
            padlen = 0;

        for( i = 0; i <= padlen; i++ )
            ssl->out_msg[ssl->out_msglen + i] = (unsigned char) padlen;

        ssl->out_msglen += padlen + 1;

        enc_msglen = ssl->out_msglen;
        enc_msg = ssl->out_msg;


        


 
        if( ssl->minor_ver >= 2 )
        {
            

 
            int ret = ssl->f_rng( ssl->p_rng, ssl->transform_out->iv_enc,
                                  ssl->transform_out->ivlen );
            if( ret != 0 )
                return( ret );

            _memcpy(ssl->out_iv, ssl->transform_out->iv_enc, ssl->transform_out->ivlen);


            

 
            enc_msg = ssl->out_msg;
            enc_msglen = ssl->out_msglen;
            ssl->out_msglen += ssl->transform_out->ivlen;
        }


        do { } while( 0 );




        do { } while( 0 );


        if( ( ret = cipher_crypt( &ssl->transform_out->cipher_ctx_enc,
                                   ssl->transform_out->iv_enc,
                                   ssl->transform_out->ivlen,
                                   enc_msg, enc_msglen,
                                   enc_msg, &olen ) ) != 0 )
        {
            do { } while( 0 );
            return( ret );
        }

        if( enc_msglen != olen )
        {
            do { } while( 0 );
            return( -0x6C00 );
        }


        if( ssl->minor_ver < 2 )
        {
            

 
            _memcpy(ssl->transform_out->iv_enc, ssl->transform_out->cipher_ctx_enc . iv, ssl->transform_out->ivlen);


        }

    }
    else


    {
        do { } while( 0 );
        return( -0x6C00 );
    }

    for( i = 8; i > 0; i-- )
        if( ++ssl->out_ctr[i - 1] != 0 )
            break;

     
    if( i == 0 )
    {
        do { } while( 0 );
        return( -0x6B80 );
    }

    do { } while( 0 );

    return( 0 );
}



static int ssl_decrypt_buf( ssl_context *ssl )
{
    size_t i;
    const cipher_mode_t mode = cipher_get_cipher_mode(
                                        &ssl->transform_in->cipher_ctx_dec );



    size_t padlen = 0, correct = 1;


    do { } while( 0 );

    if( ssl->in_msglen < ssl->transform_in->minlen )
    {
        do { } while( 0 );

        return( -0x7180 );
    }


    if( mode == POLARSSL_MODE_STREAM )
    {
        int ret;
        size_t olen = 0;

        padlen = 0;

        if( ( ret = cipher_crypt( &ssl->transform_in->cipher_ctx_dec,
                                   ssl->transform_in->iv_dec,
                                   ssl->transform_in->ivlen,
                                   ssl->in_msg, ssl->in_msglen,
                                   ssl->in_msg, &olen ) ) != 0 )
        {
            do { } while( 0 );
            return( ret );
        }

        if( ssl->in_msglen != olen )
        {
            do { } while( 0 );
            return( -0x6C00 );
        }
    }
    else
#line 1428 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"
    if( mode == POLARSSL_MODE_CBC )
    {
        

 
        int ret;
        unsigned char *dec_msg;
        unsigned char *dec_msg_result;
        size_t dec_msglen;
        size_t minlen = 0;
        size_t olen = 0;

        

 
        if( ssl->in_msglen % ssl->transform_in->ivlen != 0 )
        {
            do { } while( 0 );

            return( -0x7180 );
        }


        if( ssl->minor_ver >= 2 )
            minlen += ssl->transform_in->ivlen;


        if( ssl->in_msglen < minlen + ssl->transform_in->ivlen ||
            ssl->in_msglen < minlen + ssl->transform_in->maclen + 1 )
        {
            do { } while( 0 );



            return( -0x7180 );
        }

        dec_msglen = ssl->in_msglen;
        dec_msg = ssl->in_msg;
        dec_msg_result = ssl->in_msg;


        

 
        if( ssl->minor_ver >= 2 )
        {
            dec_msglen -= ssl->transform_in->ivlen;
            ssl->in_msglen -= ssl->transform_in->ivlen;

            for( i = 0; i < ssl->transform_in->ivlen; i++ )
                ssl->transform_in->iv_dec[i] = ssl->in_iv[i];
        }


        if( ( ret = cipher_crypt( &ssl->transform_in->cipher_ctx_dec,
                                   ssl->transform_in->iv_dec,
                                   ssl->transform_in->ivlen,
                                   dec_msg, dec_msglen,
                                   dec_msg_result, &olen ) ) != 0 )
        {
            do { } while( 0 );
            return( ret );
        }

        if( dec_msglen != olen )
        {
            do { } while( 0 );
            return( -0x6C00 );
        }


        if( ssl->minor_ver < 2 )
        {
            

 
            _memcpy(ssl->transform_in->iv_dec, ssl->transform_in->cipher_ctx_dec . iv, ssl->transform_in->ivlen);


        }


        padlen = 1 + ssl->in_msg[ssl->in_msglen - 1];

        if( ssl->in_msglen < ssl->transform_in->maclen + padlen )
        {




            padlen = 0;
            correct = 0;
        }


        if( ssl->minor_ver == 0 )
        {
            if( padlen > ssl->transform_in->ivlen )
            {





                correct = 0;
            }
        }
        else



        if( ssl->minor_ver > 0 )
        {
            


 
            size_t pad_count = 0, real_count = 1;
            size_t padding_idx = ssl->in_msglen - padlen - 1;

            








 
            correct &= ( ssl->in_msglen >= padlen + 1 );
            correct &= ( padding_idx < 5120 +
                                       ssl->transform_in->maclen );

            padding_idx *= correct;

            for( i = 1; i <= 256; i++ )
            {
                real_count &= ( i <= padlen );
                pad_count += real_count *
                             ( ssl->in_msg[padding_idx + i] == padlen - 1 );
            }

            correct &= ( pad_count == padlen );  





            padlen &= correct * 0x1FF;
        }
        else


        {
            do { } while( 0 );
            return( -0x6C00 );
        }
    }
    else


    {
        do { } while( 0 );
        return( -0x6C00 );
    }

    do { } while( 0 );


    

 



    if( mode != POLARSSL_MODE_GCM &&
        mode != POLARSSL_MODE_CCM )
    {
        unsigned char tmp[48];

        ssl->in_msglen -= ( ssl->transform_in->maclen + padlen );

        ssl->in_hdr[3] = (unsigned char)( ssl->in_msglen >> 8 );
        ssl->in_hdr[4] = (unsigned char)( ssl->in_msglen      );

        _memcpy(tmp, ssl->in_msg + ssl->in_msglen, ssl->transform_in->maclen);


        if( ssl->minor_ver == 0 )
        {
            ssl_mac( &ssl->transform_in->md_ctx_dec,
                      ssl->transform_in->mac_dec,
                      ssl->in_msg, ssl->in_msglen,
                      ssl->in_ctr, ssl->in_msgtype );
        }
        else



        if( ssl->minor_ver > 0 )
        {
            











 
            size_t j, extra_run = 0;
            extra_run = ( 13 + ssl->in_msglen + padlen + 8 ) / 64 -
                        ( 13 + ssl->in_msglen          + 8 ) / 64;

            extra_run &= correct * 0xFF;

            md_hmac_update( &ssl->transform_in->md_ctx_dec, ssl->in_ctr, 13 );
            md_hmac_update( &ssl->transform_in->md_ctx_dec, ssl->in_msg,
                             ssl->in_msglen );
            md_hmac_finish( &ssl->transform_in->md_ctx_dec,
                             ssl->in_msg + ssl->in_msglen );
            for( j = 0; j < extra_run; j++ )
                md_process( &ssl->transform_in->md_ctx_dec, ssl->in_msg );

            md_hmac_reset( &ssl->transform_in->md_ctx_dec );
        }
        else


        {
            do { } while( 0 );
            return( -0x6C00 );
        }

        do { } while( 0 );
        do { } while( 0 );


        if( safer_memcmp( tmp, ssl->in_msg + ssl->in_msglen,
                         ssl->transform_in->maclen ) != 0 )
        {



            correct = 0;
        }

        

 
        if( correct == 0 )
            return( -0x7180 );
    }


    if( ssl->in_msglen == 0 )
    {
        ssl->nb_zero++;

        


 
        if( ssl->nb_zero > 3 )
        {
            do { } while( 0 );

            return( -0x7180 );
        }
    }
    else
        ssl->nb_zero = 0;

    for( i = 8; i > 0; i-- )
        if( ++ssl->in_ctr[i - 1] != 0 )
            break;

     
    if( i == 0 )
    {
        do { } while( 0 );
        return( -0x6B80 );
    }

    do { } while( 0 );

    return( 0 );
}

#line 1819 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"



 
int ssl_fetch_input( ssl_context *ssl, size_t nb_want )
{
    int ret;
    size_t len;

    do { } while( 0 );

    if( nb_want > ( 5120 + 0 + 29 + 48 + 256 ) - 8 )
    {
        do { } while( 0 );
        return( -0x7100 );
    }

    while( ssl->in_left < nb_want )
    {
        len = nb_want - ssl->in_left;
        ret = ssl->f_recv( ssl->p_recv, ssl->in_hdr + ssl->in_left, len );

        do { } while( 0 );

        do { } while( 0 );

        if( ret == 0 )
            return( -0x7280 );

        if( ret < 0 )
            return( ret );

        ssl->in_left += ret;
    }

    do { } while( 0 );

    return( 0 );
}



 
int ssl_flush_output( ssl_context *ssl )
{
    int ret;
    unsigned char *buf;

    do { } while( 0 );

    while( ssl->out_left > 0 )
    {
        do { } while( 0 );


        buf = ssl->out_hdr + 5 + ssl->out_msglen - ssl->out_left;
        ret = ssl->f_send( ssl->p_send, buf, ssl->out_left );

        do { } while( 0 );

        if( ret <= 0 )
            return( ret );

        ssl->out_left -= ret;
    }

    do { } while( 0 );

    return( 0 );
}



 
int ssl_write_record( ssl_context *ssl )
{
    int ret, done = 0;
    size_t len = ssl->out_msglen;

    do { } while( 0 );

    if( ssl->out_msgtype == 22 )
    {
        ssl->out_msg[1] = (unsigned char)( ( len - 4 ) >> 16 );
        ssl->out_msg[2] = (unsigned char)( ( len - 4 ) >>  8 );
        ssl->out_msg[3] = (unsigned char)( ( len - 4 )       );

        if( ssl->out_msg[0] != 0 )
            ssl->handshake->update_checksum( ssl, ssl->out_msg, len );
    }

#line 1923 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"

#line 1940 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"
    if( !done )
    {
        ssl->out_hdr[0] = (unsigned char) ssl->out_msgtype;
        ssl->out_hdr[1] = (unsigned char) ssl->major_ver;
        ssl->out_hdr[2] = (unsigned char) ssl->minor_ver;
        ssl->out_hdr[3] = (unsigned char)( len >> 8 );
        ssl->out_hdr[4] = (unsigned char)( len      );

        if( ssl->transform_out != 0 )
        {
            if( ( ret = ssl_encrypt_buf( ssl ) ) != 0 )
            {
                do { } while( 0 );
                return( ret );
            }

            len = ssl->out_msglen;
            ssl->out_hdr[3] = (unsigned char)( len >> 8 );
            ssl->out_hdr[4] = (unsigned char)( len      );
        }

        ssl->out_left = 5 + ssl->out_msglen;

        do { } while( 0 );




        do { } while( 0 );

    }

    if( ( ret = ssl_flush_output( ssl ) ) != 0 )
    {
        do { } while( 0 );
        return( ret );
    }

    do { } while( 0 );

    return( 0 );
}

int ssl_read_record( ssl_context *ssl )
{
    int ret, done = 0;

    do { } while( 0 );

    if( ssl->in_hslen != 0 &&
        ssl->in_hslen < ssl->in_msglen )
    {
        

 
        ssl->in_msglen -= ssl->in_hslen;

        __rtl_memmove_v1_00( ssl->in_msg, ssl->in_msg + ssl->in_hslen,
                 ssl->in_msglen );

        ssl->in_hslen  = 4;
        ssl->in_hslen += ( ssl->in_msg[2] << 8 ) | ssl->in_msg[3];

        do { } while( 0 );



        if( ssl->in_msglen < 4 || ssl->in_msg[1] != 0 )
        {
            do { } while( 0 );
            return( -0x7200 );
        }

        if( ssl->in_msglen < ssl->in_hslen )
        {
            do { } while( 0 );
            return( -0x7200 );
        }

        if( ssl->state != SSL_HANDSHAKE_OVER )
            ssl->handshake->update_checksum( ssl, ssl->in_msg, ssl->in_hslen );

        return( 0 );
    }

    ssl->in_hslen = 0;

    

 
    if( ( ret = ssl_fetch_input( ssl, 5 ) ) != 0 )
    {
        do { } while( 0 );
        return( ret );
    }

    ssl->in_msgtype =  ssl->in_hdr[0];
    ssl->in_msglen = ( ssl->in_hdr[3] << 8 ) | ssl->in_hdr[4];

    do { } while( 0 );




    if( ssl->in_hdr[1] != ssl->major_ver )
    {
        do { } while( 0 );
        return( -0x7200 );
    }

    if( ssl->in_hdr[2] > ssl->max_minor_ver )
    {
        do { } while( 0 );
        return( -0x7200 );
    }

     
    if( ssl->in_msglen < 1 || ssl->in_msglen > ( 5120 + 0 + 29 + 48 + 256 ) - 13 )
    {
        do { } while( 0 );
        return( -0x7200 );
    }

    


 
    if( ssl->transform_in == 0 )
    {
        if( ssl->in_msglen > 5120 )
        {
            do { } while( 0 );
            return( -0x7200 );
        }
    }
    else
    {
        if( ssl->in_msglen < ssl->transform_in->minlen )
        {
            do { } while( 0 );
            return( -0x7200 );
        }


        if( ssl->minor_ver == 0 &&
            ssl->in_msglen > ssl->transform_in->minlen + 5120 )
        {
            do { } while( 0 );
            return( -0x7200 );
        }




        

 
        if( ssl->minor_ver >= 1 &&
            ssl->in_msglen > ssl->transform_in->minlen +
                             5120 + 256 )
        {
            do { } while( 0 );
            return( -0x7200 );
        }

    }

    

 
    if( ( ret = ssl_fetch_input( ssl, 5 + ssl->in_msglen ) ) != 0 )
    {
        do { } while( 0 );
        return( ret );
    }

    do { } while( 0 );


#line 2135 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"
    if( !done && ssl->transform_in != 0 )
    {
        if( ( ret = ssl_decrypt_buf( ssl ) ) != 0 )
        {

            if( ret == -0x7180 )
            {
                ssl_send_alert_message( ssl,
                                        2,
                                        20 );
            }

            do { } while( 0 );
            return( ret );
        }

        do { } while( 0 );


        if( ssl->in_msglen > 5120 )
        {
            do { } while( 0 );
            return( -0x7200 );
        }
    }

#line 2175 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"

    if( ssl->in_msgtype != 22 &&
        ssl->in_msgtype != 21 &&
        ssl->in_msgtype != 20 &&
        ssl->in_msgtype != 23 )
    {
        do { } while( 0 );

        if( ( ret = ssl_send_alert_message( ssl,
                        2,
                        10 ) ) != 0 )
        {
            return( ret );
        }

        return( -0x7200 );
    }

    if( ssl->in_msgtype == 22 )
    {
        ssl->in_hslen  = 4;
        ssl->in_hslen += ( ssl->in_msg[2] << 8 ) | ssl->in_msg[3];

        do { } while( 0 );



        

 
        if( ssl->in_msglen < 4 || ssl->in_msg[1] != 0 )
        {
            do { } while( 0 );
            return( -0x7200 );
        }

        if( ssl->in_msglen < ssl->in_hslen )
        {
            do { } while( 0 );
            return( -0x7200 );
        }

        if( ssl->state != SSL_HANDSHAKE_OVER )
            ssl->handshake->update_checksum( ssl, ssl->in_msg, ssl->in_hslen );
    }

    if( ssl->in_msgtype == 21 )
    {
        do { } while( 0 );


        

 
        if( ssl->in_msg[0] == 2 )
        {
            do { } while( 0 );

            


 
            return( -0x7780 );
        }

        if( ssl->in_msg[0] == 1 &&
            ssl->in_msg[1] == 0 )
        {
            do { } while( 0 );
            return( -0x7880 );
        }
    }

    ssl->in_left = 0;

    do { } while( 0 );

    return( 0 );
}

int ssl_send_fatal_handshake_failure( ssl_context *ssl )
{
    int ret;

    if( ( ret = ssl_send_alert_message( ssl,
                    2,
                    40 ) ) != 0 )
    {
        return( ret );
    }

    return( 0 );
}

int ssl_send_alert_message( ssl_context *ssl,
                            unsigned char level,
                            unsigned char message )
{
    int ret;

    do { } while( 0 );

    ssl->out_msgtype = 21;
    ssl->out_msglen = 2;
    ssl->out_msg[0] = level;
    ssl->out_msg[1] = message;

    if( ( ret = ssl_write_record( ssl ) ) != 0 )
    {
        do { } while( 0 );
        return( ret );
    }

    do { } while( 0 );

    return( 0 );
}



 
#line 2341 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"
int ssl_write_certificate( ssl_context *ssl )
{
    int ret = -0x7080;
    size_t i, n;
    const x509_crt *crt;
    const ssl_ciphersuite_t *ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;

    do { } while( 0 );

    if( ciphersuite_info->key_exchange == POLARSSL_KEY_EXCHANGE_PSK ||
        ciphersuite_info->key_exchange == POLARSSL_KEY_EXCHANGE_DHE_PSK ||
        ciphersuite_info->key_exchange == POLARSSL_KEY_EXCHANGE_ECDHE_PSK )
    {
        do { } while( 0 );
        ssl->state++;
        return( 0 );
    }

    if( ssl->endpoint == 0 )
    {
        if( ssl->client_auth == 0 )
        {
            do { } while( 0 );
            ssl->state++;
            return( 0 );
        }


        


 
        if( ssl_own_cert( ssl )  == 0 &&
            ssl->minor_ver == 0 )
        {
            ssl->out_msglen  = 2;
            ssl->out_msgtype = 21;
            ssl->out_msg[0]  = 1;
            ssl->out_msg[1]  = 41;

            do { } while( 0 );
            goto write_msg;
        }

    }
    else  
    {
        if( ssl_own_cert( ssl ) == 0 )
        {
            do { } while( 0 );
            return( -0x7580 );
        }
    }

    do { } while( 0 );

    







 
    i = 7;
    crt = ssl_own_cert( ssl );

    while( crt != 0 )
    {
        n = crt->raw.len;
        if( n > 5120 - 3 - i )
        {
            do { } while( 0 );

            return( -0x7500 );
        }

        ssl->out_msg[i    ] = (unsigned char)( n >> 16 );
        ssl->out_msg[i + 1] = (unsigned char)( n >>  8 );
        ssl->out_msg[i + 2] = (unsigned char)( n       );

        i += 3; _memcpy(ssl->out_msg + i, crt->raw . p, n);
        i += n; crt = crt->next;
    }

    ssl->out_msg[4]  = (unsigned char)( ( i - 7 ) >> 16 );
    ssl->out_msg[5]  = (unsigned char)( ( i - 7 ) >>  8 );
    ssl->out_msg[6]  = (unsigned char)( ( i - 7 )       );

    ssl->out_msglen  = i;
    ssl->out_msgtype = 22;
    ssl->out_msg[0]  = 11;


write_msg:


    ssl->state++;

    if( ( ret = ssl_write_record( ssl ) ) != 0 )
    {
        do { } while( 0 );
        return( ret );
    }

    do { } while( 0 );

    return( ret );
}

int ssl_parse_certificate( ssl_context *ssl )
{
    int ret = -0x7080;
    size_t i, n;
    const ssl_ciphersuite_t *ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;

    do { } while( 0 );

    if( ciphersuite_info->key_exchange == POLARSSL_KEY_EXCHANGE_PSK ||
        ciphersuite_info->key_exchange == POLARSSL_KEY_EXCHANGE_DHE_PSK ||
        ciphersuite_info->key_exchange == POLARSSL_KEY_EXCHANGE_ECDHE_PSK )
    {
        do { } while( 0 );
        ssl->state++;
        return( 0 );
    }

    if( ssl->endpoint == 1 &&
        ( ssl->authmode == 0 ||
          ciphersuite_info->key_exchange == POLARSSL_KEY_EXCHANGE_RSA_PSK ) )
    {
        ssl->session_negotiate->verify_result = 0x80;
        do { } while( 0 );
        ssl->state++;
        return( 0 );
    }

    if( ( ret = ssl_read_record( ssl ) ) != 0 )
    {
        do { } while( 0 );
        return( ret );
    }

    ssl->state++;


    

 
    if( ssl->endpoint  == 1 &&
        ssl->minor_ver == 0 )
    {
        if( ssl->in_msglen  == 2                        &&
            ssl->in_msgtype == 21            &&
            ssl->in_msg[0]  == 1  &&
            ssl->in_msg[1]  == 41 )
        {
            do { } while( 0 );

            ssl->session_negotiate->verify_result = 0x40;
            if( ssl->authmode == 1 )
                return( 0 );
            else
                return( -0x7480 );
        }
    }




    if( ssl->endpoint  == 1 &&
        ssl->minor_ver != 0 )
    {
        if( ssl->in_hslen   == 7                    &&
            ssl->in_msgtype == 22    &&
            ssl->in_msg[0]  == 11   &&
            _memcmp(ssl->in_msg + 4, "\0\0\0", 3) == 0 )
        {
            do { } while( 0 );

            ssl->session_negotiate->verify_result = 0x40;
            if( ssl->authmode == 2 )
                return( -0x7480 );
            else
                return( 0 );
        }
    }



    if( ssl->in_msgtype != 22 )
    {
        do { } while( 0 );
        return( -0x7700 );
    }

    if( ssl->in_msg[0] != 11 || ssl->in_hslen < 10 )
    {
        do { } while( 0 );
        return( -0x7A00 );
    }

    

 
    n = ( ssl->in_msg[5] << 8 ) | ssl->in_msg[6];

    if( ssl->in_msg[4] != 0 || ssl->in_hslen != 7 + n )
    {
        do { } while( 0 );
        return( -0x7A00 );
    }

     
    if( ssl->session_negotiate->peer_cert != 0 )
    {
        x509_crt_free( ssl->session_negotiate->peer_cert );
        rom_ssl_ram_map . ssl_free( ssl->session_negotiate->peer_cert );
    }

    if( ( ssl->session_negotiate->peer_cert = (x509_crt *) rom_ssl_ram_map . ssl_malloc(
                    sizeof( x509_crt ) ) ) == 0 )
    {
        do { } while( 0 );

        return( -0x7F00 );
    }

    x509_crt_init( ssl->session_negotiate->peer_cert );

    i = 7;

    while( i < ssl->in_hslen )
    {
        if( ssl->in_msg[i] != 0 )
        {
            do { } while( 0 );
            return( -0x7A00 );
        }

        n = ( (unsigned int) ssl->in_msg[i + 1] << 8 )
            | (unsigned int) ssl->in_msg[i + 2];
        i += 3;

        if( n < 128 || i + n > ssl->in_hslen )
        {
            do { } while( 0 );
            return( -0x7A00 );
        }

        ret = x509_crt_parse_der( ssl->session_negotiate->peer_cert,
                                  ssl->in_msg + i, n );
        if( ret != 0 )
        {
            do { } while( 0 );
            return( ret );
        }

        i += n;
    }

    do { } while( 0 );

    


 
    if( ssl->endpoint == 0 &&
        ssl->renegotiation == 1 )
    {
        if( ssl->session->peer_cert == 0 )
        {
            do { } while( 0 );
            return( -0x7A00 );
        }

        if( ssl->session->peer_cert->raw.len !=
            ssl->session_negotiate->peer_cert->raw.len ||
            _memcmp(ssl->session->peer_cert->raw . p, ssl->session_negotiate ->peer_cert->raw . p, ssl->session->peer_cert->raw . len) != 0 )


        {
            do { } while( 0 );
            return( -0x7A00 );
        }
    }

    if( ssl->authmode != 0 )
    {
        if( ssl->ca_chain == 0 )
        {
            do { } while( 0 );
            return( -0x7680 );
        }

        

 
        ret = x509_crt_verify( ssl->session_negotiate->peer_cert,
                               ssl->ca_chain, ssl->ca_crl, ssl->peer_cn,
                              &ssl->session_negotiate->verify_result,
                               ssl->f_vrfy, ssl->p_vrfy );

        if( ret != 0 )
        {
            do { } while( 0 );
        }

        

 

#line 2668 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"

        if( ssl_check_cert_usage( ssl->session_negotiate->peer_cert,
                                  ciphersuite_info,
                                  ! ssl->endpoint ) != 0 )
        {
            do { } while( 0 );
            if( ret == 0 )
                ret = -0x7A00;
        }

        if( ssl->authmode != 2 )
            ret = 0;
    }

    do { } while( 0 );

    return( ret );
}
#line 2693 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"

int ssl_write_change_cipher_spec( ssl_context *ssl )
{
    int ret;

    do { } while( 0 );

    ssl->out_msgtype = 20;
    ssl->out_msglen  = 1;
    ssl->out_msg[0]  = 1;

    ssl->state++;

    if( ( ret = ssl_write_record( ssl ) ) != 0 )
    {
        do { } while( 0 );
        return( ret );
    }

    do { } while( 0 );

    return( 0 );
}

int ssl_parse_change_cipher_spec( ssl_context *ssl )
{
    int ret;

    do { } while( 0 );

    if( ( ret = ssl_read_record( ssl ) ) != 0 )
    {
        do { } while( 0 );
        return( ret );
    }

    if( ssl->in_msgtype != 20 )
    {
        do { } while( 0 );
        return( -0x7700 );
    }

    if( ssl->in_msglen != 1 || ssl->in_msg[0] != 1 )
    {
        do { } while( 0 );
        return( -0x7E00 );
    }

    ssl->state++;

    do { } while( 0 );

    return( 0 );
}

void ssl_optimize_checksum( ssl_context *ssl,
                            const ssl_ciphersuite_t *ciphersuite_info )
{
    ((void) ciphersuite_info);



    if( ssl->minor_ver < 3 )
        ssl->handshake->update_checksum = ssl_update_checksum_md5sha1;
    else



    if( ciphersuite_info->mac == POLARSSL_MD_SHA384 )
        ssl->handshake->update_checksum = ssl_update_checksum_sha384;
    else


    if( ciphersuite_info->mac != POLARSSL_MD_SHA384 )
        ssl->handshake->update_checksum = ssl_update_checksum_sha256;
    else


    {
        do { } while( 0 );
        return;
    }
}

static void ssl_update_checksum_start( ssl_context *ssl,
                                       const unsigned char *buf, size_t len )
{


     md5_update( &ssl->handshake->fin_md5 , buf, len );
    sha1_update( &ssl->handshake->fin_sha1, buf, len );



    sha256_update( &ssl->handshake->fin_sha256, buf, len );


    sha512_update( &ssl->handshake->fin_sha512, buf, len );


}



static void ssl_update_checksum_md5sha1( ssl_context *ssl,
                                         const unsigned char *buf, size_t len )
{
     md5_update( &ssl->handshake->fin_md5 , buf, len );
    sha1_update( &ssl->handshake->fin_sha1, buf, len );
}




static void ssl_update_checksum_sha256( ssl_context *ssl,
                                        const unsigned char *buf, size_t len )
{
    sha256_update( &ssl->handshake->fin_sha256, buf, len );
}



static void ssl_update_checksum_sha384( ssl_context *ssl,
                                        const unsigned char *buf, size_t len )
{
    sha512_update( &ssl->handshake->fin_sha512, buf, len );
}




static void ssl_calc_finished_ssl(
                ssl_context *ssl, unsigned char *buf, int from )
{
    const char *sender;
    md5_context  md5;
    sha1_context sha1;

    unsigned char padbuf[48];
    unsigned char md5sum[16];
    unsigned char sha1sum[20];

    ssl_session *session = ssl->session_negotiate;
    if( !session )
        session = ssl->session;

    do { } while( 0 );

    _memcpy(&md5, &ssl->handshake ->fin_md5, sizeof(md5_context));
    _memcpy(&sha1, &ssl->handshake ->fin_sha1, sizeof(sha1_context));

    






 


    do { } while( 0 );




    do { } while( 0 );



    sender = ( from == 0 ) ? "CLNT"
                                       : "SRVR";

    _memset(padbuf, 0x36, 48);

    md5_update( &md5, (const unsigned char *) sender, 4 );
    md5_update( &md5, session->master, 48 );
    md5_update( &md5, padbuf, 48 );
    md5_finish( &md5, md5sum );

    sha1_update( &sha1, (const unsigned char *) sender, 4 );
    sha1_update( &sha1, session->master, 48 );
    sha1_update( &sha1, padbuf, 40 );
    sha1_finish( &sha1, sha1sum );

    _memset(padbuf, 0x5C, 48);

    md5_starts( &md5 );
    md5_update( &md5, session->master, 48 );
    md5_update( &md5, padbuf, 48 );
    md5_update( &md5, md5sum, 16 );
    md5_finish( &md5, buf );

    sha1_starts( &sha1 );
    sha1_update( &sha1, session->master, 48 );
    sha1_update( &sha1, padbuf , 40 );
    sha1_update( &sha1, sha1sum, 20 );
    sha1_finish( &sha1, buf + 16 );

    do { } while( 0 );

    md5_free(  &md5  );
    sha1_free( &sha1 );

    polarssl_zeroize(  padbuf, sizeof(  padbuf ) );
    polarssl_zeroize(  md5sum, sizeof(  md5sum ) );
    polarssl_zeroize( sha1sum, sizeof( sha1sum ) );

    do { } while( 0 );
}



static void ssl_calc_finished_tls(
                ssl_context *ssl, unsigned char *buf, int from )
{
    int len = 12;
    const char *sender;
    md5_context  md5;
    sha1_context sha1;
    unsigned char padbuf[36];

    ssl_session *session = ssl->session_negotiate;
    if( !session )
        session = ssl->session;

    do { } while( 0 );

    _memcpy(&md5, &ssl->handshake ->fin_md5, sizeof(md5_context));
    _memcpy(&sha1, &ssl->handshake ->fin_sha1, sizeof(sha1_context));

    



 


    do { } while( 0 );




    do { } while( 0 );



    sender = ( from == 0 )
             ? "client finished"
             : "server finished";

    md5_finish(  &md5, padbuf );
    sha1_finish( &sha1, padbuf + 16 );

    ssl->handshake->tls_prf( session->master, 48, sender,
                             padbuf, 36, buf, len );

    do { } while( 0 );

    md5_free(  &md5  );
    sha1_free( &sha1 );

    polarssl_zeroize(  padbuf, sizeof(  padbuf ) );

    do { } while( 0 );
}




static void ssl_calc_finished_tls_sha256(
                ssl_context *ssl, unsigned char *buf, int from )
{
    int len = 12;
    const char *sender;
    sha256_context sha256;
    unsigned char padbuf[32];

    ssl_session *session = ssl->session_negotiate;
    if( !session )
        session = ssl->session;

    do { } while( 0 );

    _memcpy(&sha256, &ssl->handshake ->fin_sha256, sizeof(sha256_context));

    



 


    do { } while( 0 );



    sender = ( from == 0 )
             ? "client finished"
             : "server finished";

    sha256_finish( &sha256, padbuf );

    ssl->handshake->tls_prf( session->master, 48, sender,
                             padbuf, 32, buf, len );

    do { } while( 0 );

    sha256_free( &sha256 );

    polarssl_zeroize(  padbuf, sizeof(  padbuf ) );

    do { } while( 0 );
}



static void ssl_calc_finished_tls_sha384(
                ssl_context *ssl, unsigned char *buf, int from )
{
    int len = 12;
    const char *sender;
    sha512_context sha512;
    unsigned char padbuf[48];

    ssl_session *session = ssl->session_negotiate;
    if( !session )
        session = ssl->session;

    do { } while( 0 );

    _memcpy(&sha512, &ssl->handshake ->fin_sha512, sizeof(sha512_context));

    



 


    do { } while( 0 );



    sender = ( from == 0 )
             ? "client finished"
             : "server finished";

    sha512_finish( &sha512, padbuf );

    ssl->handshake->tls_prf( session->master, 48, sender,
                             padbuf, 48, buf, len );

    do { } while( 0 );

    sha512_free( &sha512 );

    polarssl_zeroize(  padbuf, sizeof( padbuf ) );

    do { } while( 0 );
}



void ssl_handshake_wrapup( ssl_context *ssl )
{
    int resume = ssl->handshake->resume;

    do { } while( 0 );

    

 
    ssl_handshake_free( ssl->handshake );
    rom_ssl_ram_map . ssl_free( ssl->handshake );
    ssl->handshake = 0;

    if( ssl->renegotiation == 1 )
    {
        ssl->renegotiation =  2;
        ssl->renego_records_seen = 0;
    }

    

 
    if( ssl->transform )
    {
        ssl_transform_free( ssl->transform );
        rom_ssl_ram_map . ssl_free( ssl->transform );
    }
    ssl->transform = ssl->transform_negotiate;
    ssl->transform_negotiate = 0;

    if( ssl->session )
    {
        ssl_session_free( ssl->session );
        rom_ssl_ram_map . ssl_free( ssl->session );
    }
    ssl->session = ssl->session_negotiate;
    ssl->session_negotiate = 0;

    

 
    if( ssl->f_set_cache != 0 &&
        ssl->session->length != 0 &&
        resume == 0 )
    {
        if( ssl->f_set_cache( ssl->p_set_cache, ssl->session ) != 0 )
            do { } while( 0 );
    }

    ssl->state++;

    do { } while( 0 );
}

int ssl_write_finished( ssl_context *ssl )
{
    int ret, hash_len;

    do { } while( 0 );

    

 
    if( ssl->minor_ver >= 2 )
    {
        ssl->out_msg = ssl->out_iv + ssl->transform_negotiate->ivlen -
                       ssl->transform_negotiate->fixed_ivlen;
    }
    else
        ssl->out_msg = ssl->out_iv;

    ssl->handshake->calc_finished( ssl, ssl->out_msg + 4, ssl->endpoint );

    
    hash_len = ( ssl->minor_ver == 0 ) ? 36 : 12;

    ssl->verify_data_len = hash_len;
    _memcpy(ssl->own_verify_data, ssl->out_msg + 4, hash_len);

    ssl->out_msglen  = 4 + hash_len;
    ssl->out_msgtype = 22;
    ssl->out_msg[0]  = 20;

    


 
    if( ssl->handshake->resume != 0 )
    {
        if( ssl->endpoint == 0 )
            ssl->state = SSL_HANDSHAKE_WRAPUP;
        else
            ssl->state = SSL_CLIENT_CHANGE_CIPHER_SPEC;
    }
    else
        ssl->state++;

    


 
    do { } while( 0 );
    ssl->transform_out = ssl->transform_negotiate;
    ssl->session_out = ssl->session_negotiate;
    _memset(ssl->out_ctr, 0, 8);

#line 3173 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"

    if( ( ret = ssl_write_record( ssl ) ) != 0 )
    {
        do { } while( 0 );
        return( ret );
    }

    do { } while( 0 );

    return( 0 );
}

int ssl_parse_finished( ssl_context *ssl )
{
    int ret;
    unsigned int hash_len;
    unsigned char buf[36];

    do { } while( 0 );

    ssl->handshake->calc_finished( ssl, buf, ssl->endpoint ^ 1 );

    


 
    do { } while( 0 );
    ssl->transform_in = ssl->transform_negotiate;
    ssl->session_in = ssl->session_negotiate;
    _memset(ssl->in_ctr, 0, 8);

    

 
    if( ssl->minor_ver >= 2 )
    {
        ssl->in_msg = ssl->in_iv + ssl->transform_negotiate->ivlen -
                      ssl->transform_negotiate->fixed_ivlen;
    }
    else
        ssl->in_msg = ssl->in_iv;

#line 3225 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"

    if( ( ret = ssl_read_record( ssl ) ) != 0 )
    {
        do { } while( 0 );
        return( ret );
    }

    if( ssl->in_msgtype != 22 )
    {
        do { } while( 0 );
        return( -0x7700 );
    }

    
    hash_len = ( ssl->minor_ver == 0 ) ? 36 : 12;

    if( ssl->in_msg[0] != 20 ||
        ssl->in_hslen  != 4 + hash_len )
    {
        do { } while( 0 );
        return( -0x7E80 );
    }

    if( safer_memcmp( ssl->in_msg + 4, buf, hash_len ) != 0 )
    {
        do { } while( 0 );
        return( -0x7E80 );
    }

    ssl->verify_data_len = hash_len;
    _memcpy(ssl->peer_verify_data, buf, hash_len);

    if( ssl->handshake->resume != 0 )
    {
        if( ssl->endpoint == 0 )
            ssl->state = SSL_CLIENT_CHANGE_CIPHER_SPEC;

        if( ssl->endpoint == 1 )
            ssl->state = SSL_HANDSHAKE_WRAPUP;
    }
    else
        ssl->state++;

    do { } while( 0 );

    return( 0 );
}

static void ssl_handshake_params_init( ssl_handshake_params *handshake )
{
    _memset(handshake, 0, sizeof( ssl_handshake_params ));



     md5_init(   &handshake->fin_md5  );
    sha1_init(   &handshake->fin_sha1 );
     md5_starts( &handshake->fin_md5  );
    sha1_starts( &handshake->fin_sha1 );



    sha256_init(   &handshake->fin_sha256    );
    sha256_starts( &handshake->fin_sha256, 0 );


    sha512_init(   &handshake->fin_sha512    );
    sha512_starts( &handshake->fin_sha512, 1 );



    handshake->update_checksum = ssl_update_checksum_start;
    handshake->sig_alg = 2;

#line 3304 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"
}

static void ssl_transform_init( ssl_transform *transform )
{
    _memset(transform, 0, sizeof(ssl_transform));

    cipher_init( &transform->cipher_ctx_enc );
    cipher_init( &transform->cipher_ctx_dec );

    md_init( &transform->md_ctx_enc );
    md_init( &transform->md_ctx_dec );
}

void ssl_session_init( ssl_session *session )
{
    _memset(session, 0, sizeof(ssl_session));
}

static int ssl_handshake_init( ssl_context *ssl )
{
     
    if( ssl->transform_negotiate )
        ssl_transform_free( ssl->transform_negotiate );
    if( ssl->session_negotiate )
        ssl_session_free( ssl->session_negotiate );
    if( ssl->handshake )
        ssl_handshake_free( ssl->handshake );

    


 
    if( ssl->transform_negotiate == 0 )
    {
        ssl->transform_negotiate =
            (ssl_transform *) rom_ssl_ram_map . ssl_malloc( sizeof(ssl_transform) );
    }

    if( ssl->session_negotiate == 0 )
    {
        ssl->session_negotiate =
            (ssl_session *) rom_ssl_ram_map . ssl_malloc( sizeof(ssl_session) );
    }

    if( ssl->handshake == 0)
    {
        ssl->handshake = (ssl_handshake_params *)
            rom_ssl_ram_map . ssl_malloc( sizeof(ssl_handshake_params) );
    }

     
    if( ssl->handshake == 0 ||
        ssl->transform_negotiate == 0 ||
        ssl->session_negotiate == 0 )
    {
        do { } while( 0 );

        rom_ssl_ram_map . ssl_free( ssl->handshake );
        rom_ssl_ram_map . ssl_free( ssl->transform_negotiate );
        rom_ssl_ram_map . ssl_free( ssl->session_negotiate );

        ssl->handshake = 0;
        ssl->transform_negotiate = 0;
        ssl->session_negotiate = 0;

        return( -0x7F00 );
    }

     
    ssl_session_init( ssl->session_negotiate );
    ssl_transform_init( ssl->transform_negotiate );
    ssl_handshake_params_init( ssl->handshake );


    ssl->handshake->key_cert = ssl->key_cert;


    return( 0 );
}



 
int ssl_init( ssl_context *ssl )
{
    int ret;
    int len = ( 5120 + 0 + 29 + 48 + 256 );

    _memset(ssl, 0, sizeof( ssl_context ));

    

 
    ssl->min_major_ver = 3;
    ssl->min_minor_ver = 0;
    ssl->max_major_ver = 3;
    ssl->max_minor_ver = 3;

    ssl_set_ciphersuites( ssl, ssl_list_ciphersuites() );

    ssl->renego_max_records = 16;

#line 3416 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"

    

 
    ssl->in_ctr = (unsigned char *) rom_ssl_ram_map . ssl_malloc( len );
    ssl->in_hdr = ssl->in_ctr +  8;
    ssl->in_iv  = ssl->in_ctr + 13;
    ssl->in_msg = ssl->in_ctr + 13;

    if( ssl->in_ctr == 0 )
    {
        do { } while( 0 );
        return( -0x7F00 );
    }

    ssl->out_ctr = (unsigned char *) rom_ssl_ram_map . ssl_malloc( len );
    ssl->out_hdr = ssl->out_ctr +  8;
    ssl->out_iv  = ssl->out_ctr + 13;
    ssl->out_msg = ssl->out_ctr + 13;

    if( ssl->out_ctr == 0 )
    {
        do { } while( 0 );
        rom_ssl_ram_map . ssl_free( ssl->in_ctr );
        ssl->in_ctr = 0;
        return( -0x7F00 );
    }

    _memset(ssl-> in_ctr, 0, ( 5120 + 0 + 29 + 48 + 256 ));
    _memset(ssl->out_ctr, 0, ( 5120 + 0 + 29 + 48 + 256 ));


    ssl->ticket_lifetime = 86400;






    if( ( ret = ssl_handshake_init( ssl ) ) != 0 )
        return( ret );
    

 
    if ( rtl_cryptoEngine_init() != 0 ) {
        DiagPrintf("crypto engine init failed\r\n");
    }

    return( 0 );
}




 
int ssl_session_reset( ssl_context *ssl )
{
    int ret;

    ssl->state = SSL_HELLO_REQUEST;
    ssl->renegotiation = 0;
    ssl->secure_renegotiation = 0;

    ssl->verify_data_len = 0;
    _memset(ssl->own_verify_data, 0, 36);
    _memset(ssl->peer_verify_data, 0, 36);

    ssl->in_offt = 0;

    ssl->in_msg = ssl->in_ctr + 13;
    ssl->in_msgtype = 0;
    ssl->in_msglen = 0;
    ssl->in_left = 0;

    ssl->in_hslen = 0;
    ssl->nb_zero = 0;
    ssl->record_read = 0;

    ssl->out_msg = ssl->out_ctr + 13;
    ssl->out_msgtype = 0;
    ssl->out_msglen = 0;
    ssl->out_left = 0;

    ssl->transform_in = 0;
    ssl->transform_out = 0;

    ssl->renego_records_seen = 0;

    _memset(ssl->out_ctr, 0, ( 5120 + 0 + 29 + 48 + 256 ));
    _memset(ssl->in_ctr, 0, ( 5120 + 0 + 29 + 48 + 256 ));

#line 3518 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"

    if( ssl->transform )
    {
        ssl_transform_free( ssl->transform );
        rom_ssl_ram_map . ssl_free( ssl->transform );
        ssl->transform = 0;
    }

    if( ssl->session )
    {
        ssl_session_free( ssl->session );
        rom_ssl_ram_map . ssl_free( ssl->session );
        ssl->session = 0;
    }





    if( ( ret = ssl_handshake_init( ssl ) ) != 0 )
        return( ret );

    return( 0 );
}


static void ssl_ticket_keys_free( ssl_ticket_keys *tkeys )
{
    aes_free( &tkeys->enc );
    aes_free( &tkeys->dec );

    polarssl_zeroize( tkeys, sizeof(ssl_ticket_keys) );
}



 
static int ssl_ticket_keys_init( ssl_context *ssl )
{
    int ret;
    ssl_ticket_keys *tkeys;
    unsigned char buf[16];

    if( ssl->ticket_keys != 0 )
        return( 0 );

    tkeys = (ssl_ticket_keys *) rom_ssl_ram_map . ssl_malloc( sizeof(ssl_ticket_keys) );
    if( tkeys == 0 )
        return( -0x7F00 );

    polarssl_aes_init( &tkeys->enc );
    polarssl_aes_init( &tkeys->dec );

    if( ( ret = ssl->f_rng( ssl->p_rng, tkeys->key_name, 16 ) ) != 0 )
    {
        ssl_ticket_keys_free( tkeys );
        rom_ssl_ram_map . ssl_free( tkeys );
        return( ret );
    }

    if( ( ret = ssl->f_rng( ssl->p_rng, buf, 16 ) ) != 0 ||
        ( ret = aes_setkey_enc( &tkeys->enc, buf, 128 ) ) != 0 ||
        ( ret = aes_setkey_dec( &tkeys->dec, buf, 128 ) ) != 0 )
    {
        ssl_ticket_keys_free( tkeys );
        rom_ssl_ram_map . ssl_free( tkeys );
        return( ret );
    }

    if( ( ret = ssl->f_rng( ssl->p_rng, tkeys->mac_key, 16 ) ) != 0 )
    {
        ssl_ticket_keys_free( tkeys );
        rom_ssl_ram_map . ssl_free( tkeys );
        return( ret );
    }

    ssl->ticket_keys = tkeys;

    return( 0 );
}




 
void ssl_set_endpoint( ssl_context *ssl, int endpoint )
{
    ssl->endpoint   = endpoint;


    if( endpoint == 0 )
        ssl->session_tickets = 1;

}

void ssl_set_authmode( ssl_context *ssl, int authmode )
{
    ssl->authmode   = authmode;
}


void ssl_set_verify( ssl_context *ssl,
                     int (*f_vrfy)(void *, x509_crt *, int, int *),
                     void *p_vrfy )
{
    ssl->f_vrfy      = f_vrfy;
    ssl->p_vrfy      = p_vrfy;
}


void ssl_set_rng( ssl_context *ssl,
                  int (*f_rng)(void *, unsigned char *, size_t),
                  void *p_rng )
{
    ssl->f_rng      = f_rng;
    ssl->p_rng      = p_rng;
}

void ssl_set_dbg( ssl_context *ssl,
                  void (*f_dbg)(void *, int, const char *),
                  void  *p_dbg )
{
    ssl->f_dbg      = f_dbg;
    ssl->p_dbg      = p_dbg;
}

void ssl_set_bio( ssl_context *ssl,
            int (*f_recv)(void *, unsigned char *, size_t), void *p_recv,
            int (*f_send)(void *, const unsigned char *, size_t), void *p_send )
{
    ssl->f_recv     = f_recv;
    ssl->f_send     = f_send;
    ssl->p_recv     = p_recv;
    ssl->p_send     = p_send;
}

void ssl_set_session_cache( ssl_context *ssl,
        int (*f_get_cache)(void *, ssl_session *), void *p_get_cache,
        int (*f_set_cache)(void *, const ssl_session *), void *p_set_cache )
{
    ssl->f_get_cache = f_get_cache;
    ssl->p_get_cache = p_get_cache;
    ssl->f_set_cache = f_set_cache;
    ssl->p_set_cache = p_set_cache;
}

int ssl_set_session( ssl_context *ssl, const ssl_session *session )
{
    int ret;

    if( ssl == 0 ||
        session == 0 ||
        ssl->session_negotiate == 0 ||
        ssl->endpoint != 0 )
    {
        return( -0x7100 );
    }

    if( ( ret = ssl_session_copy( ssl->session_negotiate, session ) ) != 0 )
        return( ret );

    ssl->handshake->resume = 1;

    return( 0 );
}

void ssl_set_ciphersuites( ssl_context *ssl, const int *ciphersuites )
{
    ssl->ciphersuite_list[0] = ciphersuites;
    ssl->ciphersuite_list[1] = ciphersuites;
    ssl->ciphersuite_list[2] = ciphersuites;
    ssl->ciphersuite_list[3] = ciphersuites;
}

void ssl_set_ciphersuites_for_version( ssl_context *ssl,
                                       const int *ciphersuites,
                                       int major, int minor )
{
    if( major != 3 )
        return;

    if( minor < 0 || minor > 3 )
        return;

    ssl->ciphersuite_list[minor] = ciphersuites;
}


 
static ssl_key_cert *ssl_add_key_cert( ssl_context *ssl )
{
    ssl_key_cert *key_cert, *last;

    key_cert = (ssl_key_cert *) rom_ssl_ram_map . ssl_malloc( sizeof(ssl_key_cert) );
    if( key_cert == 0 )
        return( 0 );

    _memset(key_cert, 0, sizeof( ssl_key_cert ));

     
    if( ssl->key_cert == 0 )
    {
        ssl->key_cert = key_cert;
        if( ssl->handshake != 0 )
            ssl->handshake->key_cert = key_cert;
    }
    else
    {
        last = ssl->key_cert;
        while( last->next != 0 )
            last = last->next;
        last->next = key_cert;
    }

    return( key_cert );
}

void ssl_set_ca_chain( ssl_context *ssl, x509_crt *ca_chain,
                       x509_crl *ca_crl, const char *peer_cn )
{
    ssl->ca_chain   = ca_chain;
    ssl->ca_crl     = ca_crl;
    ssl->peer_cn    = peer_cn;
}

int ssl_set_own_cert( ssl_context *ssl, x509_crt *own_cert,
                       pk_context *pk_key )
{
    ssl_key_cert *key_cert = ssl_add_key_cert( ssl );

    if( key_cert == 0 )
        return( -0x7F00 );

    key_cert->cert = own_cert;
    key_cert->key  = pk_key;

    return( 0 );
}


int ssl_set_own_cert_rsa( ssl_context *ssl, x509_crt *own_cert,
                           rsa_context *rsa_key )
{
    int ret;
    ssl_key_cert *key_cert = ssl_add_key_cert( ssl );

    if( key_cert == 0 )
        return( -0x7F00 );

    key_cert->key = (pk_context *) rom_ssl_ram_map . ssl_malloc( sizeof(pk_context) );
    if( key_cert->key == 0 )
        return( -0x7F00 );

    pk_init( key_cert->key );

    ret = pk_init_ctx( key_cert->key, pk_info_from_type( POLARSSL_PK_RSA ) );
    if( ret != 0 )
        return( ret );

    if( ( ret = rsa_copy( ( (rsa_context *) (*key_cert->key). pk_ctx ), rsa_key ) ) != 0 )
        return( ret );

    key_cert->cert = own_cert;
    key_cert->key_own_alloc = 1;

    return( 0 );
}


int ssl_set_own_cert_alt( ssl_context *ssl, x509_crt *own_cert,
                          void *rsa_key,
                          rsa_decrypt_func rsa_decrypt,
                          rsa_sign_func rsa_sign,
                          rsa_key_len_func rsa_key_len )
{
    int ret;
    ssl_key_cert *key_cert = ssl_add_key_cert( ssl );

    if( key_cert == 0 )
        return( -0x7F00 );

    key_cert->key = (pk_context *) rom_ssl_ram_map . ssl_malloc( sizeof(pk_context) );
    if( key_cert->key == 0 )
        return( -0x7F00 );

    pk_init( key_cert->key );

    if( ( ret = pk_init_ctx_rsa_alt( key_cert->key, rsa_key,
                                 rsa_decrypt, rsa_sign, rsa_key_len ) ) != 0 )
        return( ret );

    key_cert->cert = own_cert;
    key_cert->key_own_alloc = 1;

    return( 0 );
}


#line 3857 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"

#line 3897 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"

#line 3907 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"


int ssl_set_hostname( ssl_context *ssl, const char *hostname )
{
    if( hostname == 0 )
        return( -0x7100 );

    ssl->hostname_len = prvStrLen((const unsigned char *) hostname);

    if( ssl->hostname_len + 1 == 0 )
        return( -0x7100 );

    ssl->hostname = (unsigned char *) rom_ssl_ram_map . ssl_malloc( ssl->hostname_len + 1 );

    if( ssl->hostname == 0 )
        return( -0x7F00 );

    _memcpy(ssl->hostname, (const unsigned char *) hostname, ssl->hostname_len);


    ssl->hostname[ssl->hostname_len] = '\0';

    return( 0 );
}

void ssl_set_sni( ssl_context *ssl,
                  int (*f_sni)(void *, ssl_context *,
                                const unsigned char *, size_t),
                  void *p_sni )
{
    ssl->f_sni = f_sni;
    ssl->p_sni = p_sni;
}


#line 3972 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"

void ssl_set_max_version( ssl_context *ssl, int major, int minor )
{
    if( major >= 3 && major <= 3 &&
        minor >= 0 && minor <= 3 )
    {
        ssl->max_major_ver = major;
        ssl->max_minor_ver = minor;
    }
}

void ssl_set_min_version( ssl_context *ssl, int major, int minor )
{
    if( major >= 3 && major <= 3 &&
        minor >= 0 && minor <= 3 )
    {
        ssl->min_major_ver = major;
        ssl->min_minor_ver = minor;
    }
}


int ssl_set_max_frag_len( ssl_context *ssl, unsigned char mfl_code )
{
    if( mfl_code >= 5 ||
        mfl_code_to_length[mfl_code] > 5120 )
    {
        return( -0x7100 );
    }

    ssl->mfl_code = mfl_code;

    return( 0 );
}



int ssl_set_truncated_hmac( ssl_context *ssl, int truncate )
{
    if( ssl->endpoint != 0 )
        return( -0x7100 );

    ssl->trunc_hmac = truncate;

    return( 0 );
}


void ssl_set_renegotiation( ssl_context *ssl, int renegotiation )
{
    ssl->disable_renegotiation = renegotiation;
}

void ssl_legacy_renegotiation( ssl_context *ssl, int allow_legacy )
{
    ssl->allow_legacy_renegotiation = allow_legacy;
}

void ssl_set_renegotiation_enforced( ssl_context *ssl, int max_records )
{
    ssl->renego_max_records = max_records;
}


int ssl_set_session_tickets( ssl_context *ssl, int use_tickets )
{
    ssl->session_tickets = use_tickets;

    if( ssl->endpoint == 0 )
        return( 0 );

    if( ssl->f_rng == 0 )
        return( -0x7100 );

    return( ssl_ticket_keys_init( ssl ) );
}

void ssl_set_session_ticket_lifetime( ssl_context *ssl, int lifetime )
{
    ssl->ticket_lifetime = lifetime;
}




 
size_t ssl_get_bytes_avail( const ssl_context *ssl )
{
    return( ssl->in_offt == 0 ? 0 : ssl->in_msglen );
}

int ssl_get_verify_result( const ssl_context *ssl )
{
    return( ssl->session->verify_result );
}

const char *ssl_get_ciphersuite( const ssl_context *ssl )
{
    if( ssl == 0 || ssl->session == 0 )
        return( 0 );

    return ssl_get_ciphersuite_name( ssl->session->ciphersuite );
}

const char *ssl_get_version( const ssl_context *ssl )
{
    switch( ssl->minor_ver )
    {
        case 0:
            return( "SSLv3.0" );

        case 1:
            return( "TLSv1.0" );

        case 2:
            return( "TLSv1.1" );

        case 3:
            return( "TLSv1.2" );

        default:
            break;
    }
    return( "unknown" );
}


const x509_crt *ssl_get_peer_cert( const ssl_context *ssl )
{
    if( ssl == 0 || ssl->session == 0 )
        return( 0 );

    return( ssl->session->peer_cert );
}


int ssl_get_session( const ssl_context *ssl, ssl_session *dst )
{
    if( ssl == 0 ||
        dst == 0 ||
        ssl->session == 0 ||
        ssl->endpoint != 0 )
    {
        return( -0x7100 );
    }

    return( ssl_session_copy( dst, ssl->session ) );
}



 
int ssl_handshake_step( ssl_context *ssl )
{
    int ret = -0x7080;


    if( ssl->endpoint == 0 )
        ret = ssl_handshake_client_step( ssl );







    return( ret );
}



 
int ssl_handshake( ssl_context *ssl )
{
    int ret = 0;

    do { } while( 0 );

    while( ssl->state != SSL_HANDSHAKE_OVER )
    {
        ret = ssl_handshake_step( ssl );

        if( ret != 0 )
            break;
    }

    do { } while( 0 );

    return( ret );
}

#line 4190 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"









 
static int ssl_start_renegotiation( ssl_context *ssl )
{
    int ret;

    do { } while( 0 );

    if( ( ret = ssl_handshake_init( ssl ) ) != 0 )
        return( ret );

    ssl->state = SSL_HELLO_REQUEST;
    ssl->renegotiation = 1;

    if( ( ret = ssl_handshake( ssl ) ) != 0 )
    {
        do { } while( 0 );
        return( ret );
    }

    do { } while( 0 );

    return( 0 );
}




 
int ssl_renegotiate( ssl_context *ssl )
{
    int ret = -0x7080;

#line 4241 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"


    


 
    if( ssl->renegotiation != 1 )
    {
        if( ssl->state != SSL_HANDSHAKE_OVER )
            return( -0x7100 );

        if( ( ret = ssl_start_renegotiation( ssl ) ) != 0 )
        {
            do { } while( 0 );
            return( ret );
        }
    }
    else
    {
        if( ( ret = ssl_handshake( ssl ) ) != 0 )
        {
            do { } while( 0 );
            return( ret );
        }
    }


    return( ret );
}



 
int ssl_read( ssl_context *ssl, unsigned char *buf, size_t len )
{
    int ret;
    size_t n;

    do { } while( 0 );

    if( ssl->state != SSL_HANDSHAKE_OVER )
    {
        if( ( ret = ssl_handshake( ssl ) ) != 0 )
        {
            do { } while( 0 );
            return( ret );
        }
    }

    if( ssl->in_offt == 0 )
    {
        if( ( ret = ssl_read_record( ssl ) ) != 0 )
        {
            if( ret == -0x7280 )
                return( 0 );

            do { } while( 0 );
            return( ret );
        }

        if( ssl->in_msglen  == 0 &&
            ssl->in_msgtype == 23 )
        {
            

 
            if( ( ret = ssl_read_record( ssl ) ) != 0 )
            {
                if( ret == -0x7280 )
                    return( 0 );

                do { } while( 0 );
                return( ret );
            }
        }

        if( ssl->in_msgtype == 22 )
        {
            do { } while( 0 );

            if( ssl->endpoint == 0 &&
                ( ssl->in_msg[0] != 0 ||
                  ssl->in_hslen != 4 ) )
            {
                do { } while( 0 );
                return( -0x7700 );
            }

            if( ssl->disable_renegotiation == 0 ||
                ( ssl->secure_renegotiation == 0 &&
                  ssl->allow_legacy_renegotiation ==
                                                0 ) )
            {
                do { } while( 0 );


                if( ssl->minor_ver == 0 )
                {
                    

 
                    if( ( ret = ssl_send_fatal_handshake_failure( ssl ) ) != 0 )
                        return( ret );
                }
                else



                if( ssl->minor_ver >= 1 )
                {
                    if( ( ret = ssl_send_alert_message( ssl,
                                    1,
                                    100 ) ) != 0 )
                    {
                        return( ret );
                    }
                }
                else


                {
                    do { } while( 0 );
                    return( -0x6C00 );
                }
            }
            else
            {
                if( ( ret = ssl_start_renegotiation( ssl ) ) != 0 )
                {
                    do { } while( 0 );
                    return( ret );
                }

                return( -0x0052 );
            }
        }
        else if( ssl->renegotiation == 3 )
        {
            ssl->renego_records_seen++;

            if( ssl->renego_max_records >= 0 &&
                ssl->renego_records_seen > ssl->renego_max_records )
            {
                do { } while( 0 );

                return( -0x7700 );
            }
        }
        else if( ssl->in_msgtype != 23 )
        {
            do { } while( 0 );
            return( -0x7700 );
        }

        ssl->in_offt = ssl->in_msg;
    }

    n = ( len < ssl->in_msglen )
        ? len : ssl->in_msglen;

    _memcpy(buf, ssl->in_offt, n);
    ssl->in_msglen -= n;

    if( ssl->in_msglen == 0 )
         
        ssl->in_offt = 0;
    else
         
        ssl->in_offt += n;

    do { } while( 0 );

    return( (int) n );
}



 
int ssl_write( ssl_context *ssl, const unsigned char *buf, size_t len )
{
    int ret;
    size_t n;
    unsigned int max_len = 5120;

    do { } while( 0 );

    if( ssl->state != SSL_HANDSHAKE_OVER )
    {
        if( ( ret = ssl_handshake( ssl ) ) != 0 )
        {
            do { } while( 0 );
            return( ret );
        }
    }


    

 
    max_len = mfl_code_to_length[ssl->mfl_code];

    

 
    if( ssl->session_out != 0 &&
        mfl_code_to_length[ssl->session_out->mfl_code] < max_len )
    {
        max_len = mfl_code_to_length[ssl->session_out->mfl_code];
    }


    n = ( len < max_len) ? len : max_len;

    if( ssl->out_left != 0 )
    {
        if( ( ret = ssl_flush_output( ssl ) ) != 0 )
        {
            do { } while( 0 );
            return( ret );
        }
    }
    else
    {
        ssl->out_msglen  = n;
        ssl->out_msgtype = 23;
        _memcpy(ssl->out_msg, buf, n);

        if( ( ret = ssl_write_record( ssl ) ) != 0 )
        {
            do { } while( 0 );
            return( ret );
        }
    }

    do { } while( 0 );

    return( (int) n );
}



 
int ssl_close_notify( ssl_context *ssl )
{
    int ret;

    do { } while( 0 );

    if( ( ret = ssl_flush_output( ssl ) ) != 0 )
    {
        do { } while( 0 );
        return( ret );
    }

    if( ssl->state == SSL_HANDSHAKE_OVER )
    {
        if( ( ret = ssl_send_alert_message( ssl,
                        1,
                        0 ) ) != 0 )
        {
            return( ret );
        }
    }

    do { } while( 0 );

    return( ret );
}

void ssl_transform_free( ssl_transform *transform )
{
    if( transform == 0 )
        return;






    cipher_free( &transform->cipher_ctx_enc );
    cipher_free( &transform->cipher_ctx_dec );

    md_free( &transform->md_ctx_enc );
    md_free( &transform->md_ctx_dec );

    polarssl_zeroize( transform, sizeof( ssl_transform ) );
}


static void ssl_key_cert_free( ssl_key_cert *key_cert )
{
    ssl_key_cert *cur = key_cert, *next;

    while( cur != 0 )
    {
        next = cur->next;

        if( cur->key_own_alloc )
        {
            pk_free( cur->key );
            rom_ssl_ram_map . ssl_free( cur->key );
        }
        rom_ssl_ram_map . ssl_free( cur );

        cur = next;
    }
}


void ssl_handshake_free( ssl_handshake_params *handshake )
{
    if( handshake == 0 )
        return;

#line 4561 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"








    


 
    if( handshake->sni_key_cert != 0 )
    {
        ssl_key_cert *cur = handshake->sni_key_cert, *next;

        while( cur != 0 )
        {
            next = cur->next;
            rom_ssl_ram_map . ssl_free( cur );
            cur = next;
        }
    }


    polarssl_zeroize( handshake, sizeof( ssl_handshake_params ) );
}

void ssl_session_free( ssl_session *session )
{
    if( session == 0 )
        return;


    if( session->peer_cert != 0 )
    {
        x509_crt_free( session->peer_cert );
        rom_ssl_ram_map . ssl_free( session->peer_cert );
    }



    rom_ssl_ram_map . ssl_free( session->ticket );


    polarssl_zeroize( session, sizeof( ssl_session ) );
}



 
void ssl_free( ssl_context *ssl )
{
    if( ssl == 0 )
        return;

    do { } while( 0 );

    if( ssl->out_ctr != 0 )
    {
        polarssl_zeroize( ssl->out_ctr, ( 5120 + 0 + 29 + 48 + 256 ) );
        rom_ssl_ram_map . ssl_free( ssl->out_ctr );
    }

    if( ssl->in_ctr != 0 )
    {
        polarssl_zeroize( ssl->in_ctr, ( 5120 + 0 + 29 + 48 + 256 ) );
        rom_ssl_ram_map . ssl_free( ssl->in_ctr );
    }

#line 4638 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"






    if( ssl->transform )
    {
        ssl_transform_free( ssl->transform );
        rom_ssl_ram_map . ssl_free( ssl->transform );
    }

    if( ssl->handshake )
    {
        ssl_handshake_free( ssl->handshake );
        ssl_transform_free( ssl->transform_negotiate );
        ssl_session_free( ssl->session_negotiate );

        rom_ssl_ram_map . ssl_free( ssl->handshake );
        rom_ssl_ram_map . ssl_free( ssl->transform_negotiate );
        rom_ssl_ram_map . ssl_free( ssl->session_negotiate );
    }

    if( ssl->session )
    {
        ssl_session_free( ssl->session );
        rom_ssl_ram_map . ssl_free( ssl->session );
    }


    if( ssl->ticket_keys )
    {
        ssl_ticket_keys_free( ssl->ticket_keys );
        rom_ssl_ram_map . ssl_free( ssl->ticket_keys );
    }



    if( ssl->hostname != 0 )
    {
        polarssl_zeroize( ssl->hostname, ssl->hostname_len );
        rom_ssl_ram_map . ssl_free( ssl->hostname );
        ssl->hostname_len = 0;
    }


#line 4695 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"


    ssl_key_cert_free( ssl->key_cert );


#line 4707 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"

    do { } while( 0 );

     
    polarssl_zeroize( ssl, sizeof( ssl_context ) );
}




 
unsigned char ssl_sig_from_pk( pk_context *pk )
{

    if( pk_can_do( pk, POLARSSL_PK_RSA ) )
        return( 1 );





    return( 0 );
}

pk_type_t ssl_pk_alg_from_sig( unsigned char sig )
{
    switch( sig )
    {

        case 1:
            return( POLARSSL_PK_RSA );





        default:
            return( POLARSSL_PK_NONE );
    }
}




 
md_type_t ssl_md_alg_from_hash( unsigned char hash )
{
    switch( hash )
    {

        case 1:
            return( POLARSSL_MD_MD5 );


        case 2:
            return( POLARSSL_MD_SHA1 );


        case 3:
            return( POLARSSL_MD_SHA224 );
        case 4:
            return( POLARSSL_MD_SHA256 );


        case 5:
            return( POLARSSL_MD_SHA384 );
        case 6:
            return( POLARSSL_MD_SHA512 );

        default:
            return( POLARSSL_MD_NONE );
    }
}

#line 4797 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"


int ssl_check_cert_usage( const x509_crt *cert,
                          const ssl_ciphersuite_t *ciphersuite,
                          int cert_endpoint )
{
#line 4810 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"



    ((void) cert);
    ((void) cert_endpoint);


#line 4856 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"
    ((void) ciphersuite);


#line 4874 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\ssl\\polarssl-1.3.8\\library\\ssl_tls.c"

    return( 0 );
}


