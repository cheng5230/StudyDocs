#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\misc\\rtl8710b_ota.c"



















































 

#line 1 "F:\\IAR\\arm\\inc\\c\\stdlib.h"
 
 





  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"















 

#line 103 "F:\\IAR\\arm\\inc\\c\\ycheck.h"









#line 12 "F:\\IAR\\arm\\inc\\c\\stdlib.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\yvals.h"
 
 





  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 12 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 









  


                 




















 


   
#line 59 "F:\\IAR\\arm\\inc\\c\\yvals.h"





#line 70 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 
#line 1 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"



























 





  #pragma system_include


 
#line 1 "F:\\IAR\\arm\\INC\\c\\DLib_Config_Normal.h"
 
 





  #pragma system_include


 

#line 40 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"
   
#line 47 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"

 
#line 1 "F:\\IAR\\arm\\inc\\c\\DLib_Product.h"




   #pragma system_include







 




 


 



 



 


 




 
#line 45 "F:\\IAR\\arm\\inc\\c\\DLib_Product.h"

 


 


 






 




 


 


 
#line 99 "F:\\IAR\\arm\\inc\\c\\DLib_Product.h"







#line 51 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"











 












 
























 













 























































































































 






 














 
























 


















 
















 








 















 

#line 351 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"













 













 












 














 












 












 












 












 

















 

















 






















 















 








 














 

#line 566 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"












 












 












 












 












 












 












 












 












 










 







 












 







 








 



















































 
















 




#line 812 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"





 

#line 826 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"


   
#line 836 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"

#line 844 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"
  







 









 








 







 






 

#line 899 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"




 







 






 















 

   
#line 943 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"









 

  #pragma language = save 
  #pragma language = extended





  #pragma language = restore










 








 







 
#line 997 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"





 







#line 73 "F:\\IAR\\arm\\inc\\c\\yvals.h"











                 




















 
#line 147 "F:\\IAR\\arm\\inc\\c\\yvals.h"





                 


 




 
 
#line 170 "F:\\IAR\\arm\\inc\\c\\yvals.h"

 




 






 






 
#line 233 "F:\\IAR\\arm\\inc\\c\\yvals.h"











                 
#line 292 "F:\\IAR\\arm\\inc\\c\\yvals.h"









#line 308 "F:\\IAR\\arm\\inc\\c\\yvals.h"








#line 1 "F:\\IAR\\arm\\inc\\c\\xencoding_limits.h"
 
 





  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 12 "F:\\IAR\\arm\\inc\\c\\xencoding_limits.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\yvals.h"
 
 

#line 711 "F:\\IAR\\arm\\inc\\c\\yvals.h"




 
#line 13 "F:\\IAR\\arm\\inc\\c\\xencoding_limits.h"

                                 


#line 24 "F:\\IAR\\arm\\inc\\c\\xencoding_limits.h"




#line 42 "F:\\IAR\\arm\\inc\\c\\xencoding_limits.h"

                                 














#line 317 "F:\\IAR\\arm\\inc\\c\\yvals.h"



                 

                 
#line 335 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 
#line 360 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 
                 




#line 382 "F:\\IAR\\arm\\inc\\c\\yvals.h"


                 

                                 







  #pragma language=save
  #pragma language=extended
  typedef long long _Longlong;
  typedef unsigned long long _ULonglong;
  #pragma language=restore
#line 405 "F:\\IAR\\arm\\inc\\c\\yvals.h"






  typedef unsigned short int _Wchart;
  typedef unsigned short int _Wintt;


#line 424 "F:\\IAR\\arm\\inc\\c\\yvals.h"

#line 432 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 


typedef signed int  _Ptrdifft;
typedef unsigned int     _Sizet;

 


                 







 
  typedef struct __va_list
  {
    char  *_Ap;
  } __va_list;

  typedef __va_list __Va_list;





__intrinsic __nounwind void __iar_Atexit(void (*)(void));



  typedef struct
  {        
    unsigned int _Wchar;
    unsigned int _State;
  } _Mbstatet;
#line 481 "F:\\IAR\\arm\\inc\\c\\yvals.h"










typedef struct
{        

  _Longlong _Off;     



  _Mbstatet _Wstate;
} _Fpost;







                 

#line 1 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"













 





  #pragma system_include






 






















































































 

 



#line 157 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"

  
 

   





  


#line 176 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"





#line 187 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"





  #pragma language=save 
  #pragma language=extended
  __intrinsic __nounwind void __iar_dlib_perthread_initialize(void  *);
  __intrinsic __nounwind void  *__iar_dlib_perthread_allocate(void);
  __intrinsic __nounwind void __iar_dlib_perthread_destroy(void);
  __intrinsic __nounwind void __iar_dlib_perthread_deallocate(void  *);









  #pragma segment = "__DLIB_PERTHREAD" 
  #pragma segment = "__DLIB_PERTHREAD_init" 


























#line 242 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"

   
  void  *__iar_dlib_perthread_access(void  *);
  #pragma language=restore



























     
  









   






  





  
  typedef void *__iar_Rmtx;
  

  
  __intrinsic __nounwind void __iar_system_Mtxinit(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_system_Mtxdst(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_system_Mtxlock(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_system_Mtxunlock(__iar_Rmtx *m);

  __intrinsic __nounwind void __iar_file_Mtxinit(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_file_Mtxdst(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_file_Mtxlock(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_file_Mtxunlock(__iar_Rmtx *m);

  
 
  __intrinsic __nounwind void __iar_clearlocks(void);


#line 323 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"

  





  

#line 341 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"

  typedef unsigned _Once_t;



  













#line 510 "F:\\IAR\\arm\\inc\\c\\yvals.h"

#line 520 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 
#line 528 "F:\\IAR\\arm\\inc\\c\\yvals.h"


                 

  
  
    
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock_Locale(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock_Malloc(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock_Stream(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock_Debug(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock_StaticGuard(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock(unsigned int);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock_Locale(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock_Malloc(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock_Stream(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock_Debug(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock_StaticGuard(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock(unsigned int);

  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Initdynamicfilelock(__iar_Rmtx *);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Dstdynamicfilelock(__iar_Rmtx *);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Lockdynamicfilelock(__iar_Rmtx *);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlockdynamicfilelock(__iar_Rmtx *);
  
  
#line 568 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 
#line 576 "F:\\IAR\\arm\\inc\\c\\yvals.h"

#line 694 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 





#line 709 "F:\\IAR\\arm\\inc\\c\\yvals.h"






 
#line 13 "F:\\IAR\\arm\\inc\\c\\stdlib.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\ysizet.h"
 
 





  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 12 "F:\\IAR\\arm\\inc\\c\\ysizet.h"



                 




typedef _Sizet size_t;




typedef unsigned int __data_size_t;











#line 14 "F:\\IAR\\arm\\inc\\c\\stdlib.h"


 
#pragma rtmodel="__dlib_full_locale_support",   "0"





extern int __aeabi_MB_CUR_MAX(void);


#line 34 "F:\\IAR\\arm\\inc\\c\\stdlib.h"





                 













                 


  typedef _Wchart wchar_t;


typedef struct
{        
  int quot;
  int rem;
} div_t;

typedef struct
{        
  long quot;
  long rem;
} ldiv_t;



    #pragma language=save
    #pragma language=extended
    typedef struct
    {      
      _Longlong quot;
      _Longlong rem;
    } lldiv_t;
    #pragma language=restore



                 
  
__intrinsic __nounwind int atexit(void (*)(void));

  __intrinsic __noreturn __nounwind void _Exit(int) ;

__intrinsic __noreturn __nounwind void exit(int) ;
__intrinsic __nounwind char * getenv(const char *);
__intrinsic __nounwind int system(const char *);



             __intrinsic __noreturn __nounwind void abort(void) ;
_Pragma("function_effects = no_state, always_returns")     __intrinsic __nounwind int abs(int);
             __intrinsic __nounwind void * calloc(size_t, size_t);
_Pragma("function_effects = no_state, always_returns")     __intrinsic __nounwind div_t div(int, int);
             __intrinsic __nounwind void free(void *);
_Pragma("function_effects = no_state, always_returns")     __intrinsic __nounwind long labs(long);
_Pragma("function_effects = no_state, always_returns")     __intrinsic __nounwind ldiv_t ldiv(long, long);


    #pragma language=save
    #pragma language=extended
    _Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long llabs(long long);
    _Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind lldiv_t lldiv(long long, long long);
    #pragma language=restore


             __intrinsic __nounwind void * malloc(size_t);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind int mblen(const char *, size_t);
_Pragma("function_effects = no_read(1), no_write(2), always_returns") __intrinsic __nounwind size_t mbstowcs(wchar_t *, 
                                          const char *, size_t);
_Pragma("function_effects = no_read(1), no_write(2), always_returns") __intrinsic __nounwind int mbtowc(wchar_t *, const char *, 
                                     size_t);
             __intrinsic __nounwind int rand(void);
             __intrinsic __nounwind void srand(unsigned int);
             __intrinsic __nounwind void * realloc(void *, size_t);
_Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long strtol(const char *, 
                                      char **, int);
_Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind unsigned long strtoul(const char *, char **, int);
_Pragma("function_effects = no_read(1), no_write(2), always_returns") __intrinsic __nounwind size_t wcstombs(char *, 
                                          const wchar_t *, size_t);
_Pragma("function_effects = no_read(1), always_returns")    __intrinsic __nounwind int wctomb(char *, wchar_t);


    #pragma language=save
    #pragma language=extended
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long long strtoll(const char *, char **, int);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind unsigned long long strtoull(const char *, 
                                                          char **, int);
    #pragma language=restore





#line 188 "F:\\IAR\\arm\\inc\\c\\stdlib.h"



    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind unsigned long __iar_Stoul(const char *, char **, 
                                                        int);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind float         __iar_Stof(const char *, char **, long);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind double        __iar_Stod(const char *, char **, long);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long double   __iar_Stold(const char *, char **, 
                                                          long);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long          __iar_Stolx(const char *, char **, int, 
                                                        int *);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind unsigned long __iar_Stoulx(const char *, char **,
                                                         int, int *);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind float         __iar_Stofx(const char *, char **, 
                                                        long, int *);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind double        __iar_Stodx(const char *, char **, 
                                                        long, int *);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long double   __iar_Stoldx(const char *, char **, 
                                                         long, int *);

      #pragma language=save
      #pragma language=extended
      _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind _Longlong   __iar_Stoll(const char *, char **, 
                                                        int);
      _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind _ULonglong   __iar_Stoull(const char *, char **, 
                                                          int);
      _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind _Longlong    __iar_Stollx(const char *, char **, 
                                                          int, int *);
      _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind _ULonglong   __iar_Stoullx(const char *, char **, 
                                                           int, int *);
      #pragma language=restore








typedef int _Cmpfun(const void *, const void *);

_Pragma("function_effects = no_write(1,2), always_returns") __intrinsic void * bsearch(const void *, 
                                                   const void *, size_t,
                                                   size_t, _Cmpfun *);
             __intrinsic void qsort(void *, size_t, size_t, 
                                               _Cmpfun *);
             __intrinsic void __qsortbbl(void *, size_t, size_t, 
                                                    _Cmpfun *);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind double atof(const char *);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind int atoi(const char *);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind long atol(const char *);


    #pragma language=save
    #pragma language=extended
    _Pragma("function_effects = no_write(1), always_returns") __intrinsic __nounwind long long atoll(const char *);
    #pragma language=restore

  _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind float strtof(const char *, 
                                         char **);
  _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long double strtold(const char *, char **);

_Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind double strtod(const char *, 
                                        char **);
                                        

                                        
               __intrinsic __nounwind size_t __iar_Mbcurmax(void);

  _Pragma("function_effects = no_state, always_returns")     __intrinsic __nounwind int __iar_DLib_library_version(void);

  


#line 276 "F:\\IAR\\arm\\inc\\c\\stdlib.h"



  
  typedef void _Atexfun(void);
  
#line 304 "F:\\IAR\\arm\\inc\\c\\stdlib.h"


                 
    #pragma inline=no_body
    double atof(const char *_S)
    {       
      return (__iar_Stod(_S, 0, 0));
    }

    #pragma inline=no_body
    int atoi(const char *_S)
    {       
      return ((int)__iar_Stoul(_S, 0, 10));
    }

    #pragma inline=no_body
    long atol(const char *_S)
    {       
      return ((long)__iar_Stoul(_S, 0, 10));
    }



        #pragma language=save
        #pragma language=extended
        #pragma inline=no_body
        long long atoll(const char *_S)
        {       



            return ((long long)__iar_Stoull(_S, 0, 10));

        }
        #pragma language=restore



    #pragma inline=no_body
    double strtod(const char * _S, char ** _Endptr)
    {       
      return (__iar_Stod(_S, _Endptr, 0));
    }


      #pragma inline=no_body
      float strtof(const char * _S, char ** _Endptr)
      {       
        return (__iar_Stof(_S, _Endptr, 0));
      }

      #pragma inline=no_body
      long double strtold(const char * _S, char ** _Endptr)
      {       
        return (__iar_Stold(_S, _Endptr, 0));
      }


    #pragma inline=no_body
    long strtol(const char * _S, char ** _Endptr, 
                int _Base)
    {       
      return (__iar_Stolx(_S, _Endptr, _Base, 0));
    }

    #pragma inline=no_body
    unsigned long strtoul(const char * _S, char ** _Endptr, 
                          int _Base)
    {       
      return (__iar_Stoul(_S, _Endptr, _Base));
    }



        #pragma language=save
        #pragma language=extended
        #pragma inline=no_body
        long long strtoll(const char * _S, char ** _Endptr,
                          int _Base)
        {       



            return (__iar_Stoll(_S, _Endptr, _Base));

        }

        #pragma inline=no_body
        unsigned long long strtoull(const char * _S, 
                                    char ** _Endptr, int _Base)
        {       



            return (__iar_Stoull(_S, _Endptr, _Base));

        }
        #pragma language=restore





  #pragma inline=no_body
  int abs(int i)
  {       
    return (i < 0 ? -i : i);
  }

  #pragma inline=no_body
  long labs(long i)
  {       
    return (i < 0 ? -i : i);
  }



      #pragma language=save
      #pragma language=extended
      #pragma inline=no_body
      long long llabs(long long i)
      {       
        return (i < 0 ? -i : i);
      }
      #pragma language=restore



#line 465 "F:\\IAR\\arm\\inc\\c\\stdlib.h"




#line 494 "F:\\IAR\\arm\\inc\\c\\stdlib.h"




 
#line 55 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\misc\\rtl8710b_ota.c"
#line 1 "F:\\IAR\\arm\\inc\\c\\string.h"
 
 




  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 11 "F:\\IAR\\arm\\inc\\c\\string.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\ysizet.h"
 
 

#line 30 "F:\\IAR\\arm\\inc\\c\\ysizet.h"







#line 13 "F:\\IAR\\arm\\inc\\c\\string.h"

#line 1 "F:\\IAR\\arm\\inc\\c\\DLib_Product_string.h"








 





  #pragma system_include




  
  

  





 


  




 



#line 47 "F:\\IAR\\arm\\inc\\c\\DLib_Product_string.h"



  


 


  #pragma inline=forced_no_body
  __intrinsic __nounwind void * memcpy(void * _D, const void * _S, size_t _N)
  {
    __aeabi_memcpy(_D, _S, _N);
    return _D;
  }


  #pragma inline=forced_no_body
  __intrinsic __nounwind void * memmove(void * _D, const void * _S, size_t _N)
  {
    __aeabi_memmove(_D, _S, _N);
    return _D;
  }


  #pragma inline=forced_no_body
  __intrinsic __nounwind void * memset(void * _D, int _C, size_t _N)
  {
    __aeabi_memset(_D, _N, _C);
    return _D;
  }

  
  



#line 16 "F:\\IAR\\arm\\inc\\c\\string.h"



                 




                 

_Pragma("function_effects = no_state, no_write(1,2), always_returns")   __intrinsic __nounwind int        memcmp(const void *, const void *,
                                                size_t);
_Pragma("function_effects = no_state, no_read(1), no_write(2), returns 1, always_returns") __intrinsic __nounwind void *     memcpy(void *, 
                                                const void *, size_t);
_Pragma("function_effects = no_state, no_read(1), no_write(2), returns 1, always_returns") __intrinsic __nounwind void *     memmove(void *, const void *, size_t);
_Pragma("function_effects = no_state, no_read(1), returns 1, always_returns")    __intrinsic __nounwind void *     memset(void *, int, size_t);
_Pragma("function_effects = no_state, no_write(2), returns 1, always_returns")    __intrinsic __nounwind char *     strcat(char *, 
                                                const char *);
_Pragma("function_effects = no_state, no_write(1,2), always_returns")   __intrinsic __nounwind int        strcmp(const char *, const char *);
_Pragma("function_effects = no_write(1,2), always_returns")     __intrinsic __nounwind int        strcoll(const char *, const char *);
_Pragma("function_effects = no_state, no_read(1), no_write(2), returns 1, always_returns") __intrinsic __nounwind char *     strcpy(char *, 
                                                const char *);
_Pragma("function_effects = no_state, no_write(1,2), always_returns")   __intrinsic __nounwind size_t     strcspn(const char *, const char *);
                 __intrinsic __nounwind char *     strerror(int);
_Pragma("function_effects = no_state, no_write(1), always_returns")      __intrinsic __nounwind size_t     strlen(const char *);
_Pragma("function_effects = no_state, no_write(2), returns 1, always_returns")    __intrinsic __nounwind char *     strncat(char *, 
                                                 const char *, size_t);
_Pragma("function_effects = no_state, no_write(1,2), always_returns")   __intrinsic __nounwind int        strncmp(const char *, const char *, 
                                                 size_t);
_Pragma("function_effects = no_state, no_read(1), no_write(2), returns 1, always_returns") __intrinsic __nounwind char *     strncpy(char *, 
                                                 const char *, size_t);
_Pragma("function_effects = no_state, no_write(1,2), always_returns")   __intrinsic __nounwind size_t     strspn(const char *, const char *);
_Pragma("function_effects = no_write(2), always_returns")        __intrinsic __nounwind char *     strtok(char *, 
                                                const char *);
_Pragma("function_effects = no_write(2), always_returns")        __intrinsic __nounwind size_t     strxfrm(char *, 
                                                 const char *, size_t);


  _Pragma("function_effects = no_write(1), always_returns")      __intrinsic __nounwind char *   strdup(const char *);
  _Pragma("function_effects = no_write(1,2), always_returns")   __intrinsic __nounwind int      strcasecmp(const char *, const char *);
  _Pragma("function_effects = no_write(1,2), always_returns")   __intrinsic __nounwind int      strncasecmp(const char *, const char *, 
                                                   size_t);
  _Pragma("function_effects = no_state, no_write(2), always_returns")    __intrinsic __nounwind char *   strtok_r(char *, const char *, char **);
  _Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind size_t   strnlen(char const *, size_t);




#line 81 "F:\\IAR\\arm\\inc\\c\\string.h"
  _Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind void *memchr(const void *_S, int _C, size_t _N);
  _Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind char *strchr(const char *_S, int _C);
  _Pragma("function_effects = no_state, no_write(1,2), always_returns") __intrinsic __nounwind char *strpbrk(const char *_S, const char *_P);
  _Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind char *strrchr(const char *_S, int _C);
  _Pragma("function_effects = no_state, no_write(1,2), always_returns") __intrinsic __nounwind char *strstr(const char *_S, const char *_P);




                 


                 

_Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind void *__iar_Memchr(const void *, int, size_t);
_Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind char *__iar_Strchr(const char *, int);
               __intrinsic __nounwind char *__iar_Strerror(int, char *);
_Pragma("function_effects = no_state, no_write(1,2), always_returns") __intrinsic __nounwind char *__iar_Strpbrk(const char *, const char *);
_Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind char *__iar_Strrchr(const char *, int);
_Pragma("function_effects = no_state, no_write(1,2), always_returns") __intrinsic __nounwind char *__iar_Strstr(const char *, const char *);


                 
#line 168 "F:\\IAR\\arm\\inc\\c\\string.h"
                 
    #pragma inline
    void *memchr(const void *_S, int _C, size_t _N)
    {
      return (__iar_Memchr(_S, _C, _N));
    }

    #pragma inline
    char *strchr(const char *_S, int _C)
    {
      return (__iar_Strchr(_S, _C));
    }

    #pragma inline
    char *strpbrk(const char *_S, const char *_P)
    {
      return (__iar_Strpbrk(_S, _P));
    }

    #pragma inline
    char *strrchr(const char *_S, int _C)
    {
      return (__iar_Strrchr(_S, _C));
    }

    #pragma inline
    char *strstr(const char *_S, const char *_P)
    {
      return (__iar_Strstr(_S, _P));
    }


  #pragma inline
  char *strerror(int _Err)
  {
    return (__iar_Strerror(_Err, 0));
  }

#line 451 "F:\\IAR\\arm\\inc\\c\\string.h"






#line 479 "F:\\IAR\\arm\\inc\\c\\string.h"




 
#line 56 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\misc\\rtl8710b_ota.c"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"































































 






 
#line 1 "F:\\IAR\\arm\\inc\\c\\stddef.h"
 
 




  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 11 "F:\\IAR\\arm\\inc\\c\\stddef.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\ysizet.h"
 
 

#line 30 "F:\\IAR\\arm\\inc\\c\\ysizet.h"







#line 13 "F:\\IAR\\arm\\inc\\c\\stddef.h"



                 








                 




  typedef _Ptrdifft ptrdiff_t;









#line 49 "F:\\IAR\\arm\\inc\\c\\stddef.h"





 
#line 73 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"













 
#line 1 "F:\\IAR\\arm\\inc\\c\\stdint.h"
 
 




  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 11 "F:\\IAR\\arm\\inc\\c\\stdint.h"



 

  typedef signed char   int8_t;
  typedef unsigned char uint8_t;



  typedef signed short int   int16_t;
  typedef unsigned short int uint16_t;



  typedef signed int   int32_t;
  typedef unsigned int uint32_t;



  #pragma language=save
  #pragma language=extended
  typedef signed long long int   int64_t;
  typedef unsigned long long int uint64_t;
  #pragma language=restore



 
typedef signed char   int_least8_t;
typedef unsigned char uint_least8_t;

typedef signed short int   int_least16_t;
typedef unsigned short int uint_least16_t;

typedef signed int   int_least32_t;
typedef unsigned int uint_least32_t;

 

  #pragma language=save
  #pragma language=extended
  typedef signed long long int int_least64_t;
  #pragma language=restore


  #pragma language=save
  #pragma language=extended
  typedef unsigned long long int uint_least64_t;
  #pragma language=restore




 
typedef signed int   int_fast8_t;
typedef unsigned int uint_fast8_t;

typedef signed int   int_fast16_t;
typedef unsigned int uint_fast16_t;

typedef signed int   int_fast32_t;
typedef unsigned int uint_fast32_t;


  #pragma language=save
  #pragma language=extended
  typedef signed long long int int_fast64_t;
  #pragma language=restore


  #pragma language=save
  #pragma language=extended
  typedef unsigned long long int uint_fast64_t;
  #pragma language=restore


 
#pragma language=save
#pragma language=extended
typedef signed long long int   intmax_t;
typedef unsigned long long int uintmax_t;
#pragma language=restore


 
typedef signed long int   intptr_t;
typedef unsigned long int uintptr_t;

 



typedef int __data_intptr_t; typedef unsigned int __data_uintptr_t;


 






























































































 

































#line 258 "F:\\IAR\\arm\\inc\\c\\stdint.h"




 
#line 88 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"





 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"


































































 

#line 1 "F:\\IAR\\arm\\inc\\c\\stdint.h"
 
 
#line 235 "F:\\IAR\\arm\\inc\\c\\stdint.h"

#line 258 "F:\\IAR\\arm\\inc\\c\\stdint.h"




 
#line 73 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"
extern uint32_t SystemCoreClock; 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"


 




 



 








 
#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"



 
#line 42 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"



 
#line 52 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"



 
#line 62 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"



 





 





 





 





 





 





 





 





 





 





 




 





 







 





 






 





 




 




 




 







 




 




 




 






 




 




 




 




 








 
#line 76 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"











 

#line 108 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"






#line 127 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"







extern void freertos_pre_sleep_processing(unsigned int *expected_idle_time);
extern void freertos_post_sleep_processing(unsigned int *expected_idle_time);
extern int  freertos_ready_to_sleep();

 


 


 




 






                                                        



 





 
#line 176 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"

 
#line 184 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"



 





 




 


 





#line 95 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"

 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\projdefs.h"































































 







 
typedef void (*TaskFunction_t)( void * );

 










 








#line 98 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"

 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\portable.h"































































 



 







 










































































































































































#line 254 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\portable.h"

#line 262 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\portable.h"







#line 276 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\portable.h"











































 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\portable\\IAR\\ARM_CM4F\\portmacro.h"































































 

















 

 
#line 92 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\portable\\IAR\\ARM_CM4F\\portmacro.h"

typedef uint32_t StackType_t;
typedef long BaseType_t;
typedef unsigned long UBaseType_t;





	typedef uint32_t TickType_t;


 

 



 

 
extern void vPortYield( void );





 

 






	 




	 



	 

#line 1 "F:\\IAR\\arm\\inc\\c\\intrinsics.h"








 




#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 15 "F:\\IAR\\arm\\inc\\c\\intrinsics.h"


  #pragma system_include




 





 









#pragma language=save
#pragma language=extended

__intrinsic __nounwind void    __no_operation(void);

__intrinsic __nounwind void    __disable_interrupt(void);
__intrinsic __nounwind void    __enable_interrupt(void);

typedef unsigned long __istate_t;

__intrinsic __nounwind __istate_t __get_interrupt_state(void);
__intrinsic __nounwind void __set_interrupt_state(__istate_t);



 
__intrinsic __nounwind unsigned long __get_PSR( void );
__intrinsic __nounwind unsigned long __get_IPSR( void );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __get_MSP( void );
__intrinsic __nounwind void          __set_MSP( unsigned long );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __get_PSP( void );
__intrinsic __nounwind void          __set_PSP( unsigned long );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __get_PRIMASK( void );
__intrinsic __nounwind void          __set_PRIMASK( unsigned long );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __get_CONTROL( void );
__intrinsic __nounwind void          __set_CONTROL( unsigned long );



 
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __get_FAULTMASK( void );
__intrinsic __nounwind void          __set_FAULTMASK(unsigned long);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __get_BASEPRI( void );
__intrinsic __nounwind void          __set_BASEPRI( unsigned long );

#line 80 "F:\\IAR\\arm\\inc\\c\\intrinsics.h"

__intrinsic __nounwind void __disable_fiq(void);
__intrinsic __nounwind void __enable_fiq(void);


 

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SWP( unsigned long, volatile unsigned long * );
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned char __SWPB( unsigned char, volatile unsigned char * );

typedef unsigned long __ul;





 
__intrinsic __nounwind void          __MCR( unsigned __constrange(0,15) coproc, unsigned __constrange(0,8) opcode_1, __ul src,
                                 unsigned __constrange(0,15) CRn, unsigned __constrange(0,15) CRm, unsigned __constrange(0,8) opcode_2 );
__intrinsic __nounwind unsigned long __MRC( unsigned __constrange(0,15) coproc, unsigned __constrange(0,8) opcode_1,
                                 unsigned __constrange(0,15) CRn, unsigned __constrange(0,15) CRm, unsigned __constrange(0,8) opcode_2 );
__intrinsic __nounwind void          __MCR2( unsigned __constrange(0,15) coproc, unsigned __constrange(0,8) opcode_1, __ul src,
                                  unsigned __constrange(0,15) CRn, unsigned __constrange(0,15) CRm, unsigned __constrange(0,8) opcode_2 );
__intrinsic __nounwind unsigned long __MRC2( unsigned __constrange(0,15) coproc, unsigned __constrange(0,8) opcode_1,
                                  unsigned __constrange(0,15) CRn, unsigned __constrange(0,15) CRm, unsigned __constrange(0,8) opcode_2 );

 
__intrinsic __nounwind void __LDC( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src);
__intrinsic __nounwind void __LDCL( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src);
__intrinsic __nounwind void __LDC2( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src);
__intrinsic __nounwind void __LDC2L( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src);

 
__intrinsic __nounwind void __STC( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst);
__intrinsic __nounwind void __STCL( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst);
__intrinsic __nounwind void __STC2( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst);
__intrinsic __nounwind void __STC2L( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst);

 
__intrinsic __nounwind void __LDC_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src,
                              unsigned __constrange(0,255) option);

__intrinsic __nounwind void __LDCL_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src,
                               unsigned __constrange(0,255) option);

__intrinsic __nounwind void __LDC2_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src,
                               unsigned __constrange(0,255) option);

__intrinsic __nounwind void __LDC2L_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src,
                                unsigned __constrange(0,255) option);

 
__intrinsic __nounwind void __STC_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst,
                              unsigned __constrange(0,255) option);

__intrinsic __nounwind void __STCL_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst,
                               unsigned __constrange(0,255) option);

__intrinsic __nounwind void __STC2_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst,
                               unsigned __constrange(0,255) option);

__intrinsic __nounwind void __STC2L_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst,
                                unsigned __constrange(0,255) option);


 
__intrinsic __nounwind unsigned long __get_APSR( void );
__intrinsic __nounwind void          __set_APSR( unsigned long );






 
__intrinsic __nounwind unsigned long __get_FPSCR( void );
__intrinsic __nounwind void __set_FPSCR( unsigned long );

 
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned char __CLZ( unsigned long );

 

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind signed long __QADD( signed long, signed long );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind signed long __QDADD( signed long, signed long );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind signed long __QSUB( signed long, signed long );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind signed long __QDSUB( signed long, signed long );

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind signed long __QDOUBLE( signed long );

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind int         __QFlag( void );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind void __reset_Q_flag( void );


_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind int         __QCFlag( void );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind void __reset_QC_flag( void );

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind signed long __SMUL( signed short, signed short );

 
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __REV( unsigned long );
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind signed long __REVSH( short );

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __REV16( unsigned long );
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __RBIT( unsigned long );

_Pragma("function_effects = no_state, no_write(1), always_returns") __intrinsic __nounwind unsigned char  __LDREXB( volatile unsigned char const * );
_Pragma("function_effects = no_state, no_write(1), always_returns") __intrinsic __nounwind unsigned short __LDREXH( volatile unsigned short const * );
_Pragma("function_effects = no_state, no_write(1), always_returns") __intrinsic __nounwind unsigned long  __LDREX ( volatile unsigned long const * );
_Pragma("function_effects = no_state, no_write(1), always_returns") __intrinsic __nounwind unsigned long long __LDREXD( volatile unsigned long long const * );

_Pragma("function_effects = no_state, no_read(2), always_returns") __intrinsic __nounwind unsigned long  __STREXB( unsigned char, volatile unsigned char * );
_Pragma("function_effects = no_state, no_read(2), always_returns") __intrinsic __nounwind unsigned long  __STREXH( unsigned short, volatile unsigned short * );
_Pragma("function_effects = no_state, no_read(2), always_returns") __intrinsic __nounwind unsigned long  __STREX ( unsigned long, volatile unsigned long * );
_Pragma("function_effects = no_state, no_read(2), always_returns") __intrinsic __nounwind unsigned long  __STREXD( unsigned long long, volatile unsigned long long * );

__intrinsic __nounwind void __CLREX( void );

__intrinsic __nounwind void __SEV( void );
__intrinsic __nounwind void __WFE( void );
__intrinsic __nounwind void __WFI( void );
__intrinsic __nounwind void __YIELD( void );

__intrinsic __nounwind void __PLI( volatile void const * );
__intrinsic __nounwind void __PLD( volatile void const * );
__intrinsic __nounwind void __PLDW( volatile void const * );

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind   signed long __SSAT     (unsigned long val,
                                      unsigned int __constrange( 1, 32 ) sat );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __USAT     (unsigned long val,
                                      unsigned int __constrange( 0, 31 ) sat );




 
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SEL( unsigned long op1, unsigned long op2 );

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SADD8    (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SADD16   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SSUB8    (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SSUB16   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SADDSUBX (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SSUBADDX (unsigned long pair1, unsigned long pair2);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHADD8   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHADD16  (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHSUB8   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHSUB16  (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHADDSUBX(unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHSUBADDX(unsigned long pair1, unsigned long pair2);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QADD8    (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QADD16   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QSUB8    (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QSUB16   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QADDSUBX (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QSUBADDX (unsigned long pair1, unsigned long pair2);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UADD8    (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UADD16   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __USUB8    (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __USUB16   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UADDSUBX (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __USUBADDX (unsigned long pair1, unsigned long pair2);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHADD8   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHADD16  (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHSUB8   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHSUB16  (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHADDSUBX(unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHSUBADDX(unsigned long pair1, unsigned long pair2);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQADD8   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQADD16  (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQSUB8   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQSUB16  (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQADDSUBX(unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQSUBADDX(unsigned long pair1, unsigned long pair2);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __USAD8(unsigned long x, unsigned long y );
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __USADA8(unsigned long x, unsigned long y,
                                   unsigned long acc );

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SSAT16   (unsigned long pair,
                                      unsigned int __constrange( 1, 16 ) sat );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __USAT16   (unsigned long pair,
                                      unsigned int __constrange( 0, 15 ) sat );

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMUAD (unsigned long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMUSD (unsigned long x, unsigned long y);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMUADX(unsigned long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMUSDX(unsigned long x, unsigned long y);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLAD (unsigned long x, unsigned long y, long sum);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLSD (unsigned long x, unsigned long y, long sum);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLADX(unsigned long x, unsigned long y, long sum);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLSDX(unsigned long x, unsigned long y, long sum);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLALD (unsigned long pair1,
                                 unsigned long pair2,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLALDX(unsigned long pair1,
                                 unsigned long pair2,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLSLD (unsigned long pair1,
                                 unsigned long pair2,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLSLDX(unsigned long pair1,
                                 unsigned long pair2,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __PKHBT(unsigned long x,
                                  unsigned long y,
                                  unsigned __constrange(0,31) count);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __PKHTB(unsigned long x,
                                  unsigned long y,
                                  unsigned __constrange(0,32) count);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLABB(unsigned long x, unsigned long y, long acc);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLABT(unsigned long x, unsigned long y, long acc);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLATB(unsigned long x, unsigned long y, long acc);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLATT(unsigned long x, unsigned long y, long acc);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLAWB(long x, unsigned long y, long acc);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLAWT(long x, unsigned long y, long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMMLA (long x, long y, long acc);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMMLAR(long x, long y, long acc);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMMLS (long x, long y, long acc);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMMLSR(long x, long y, long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMMUL (long x, long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMMULR(long x, long y);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMULBB(unsigned long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMULBT(unsigned long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMULTB(unsigned long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMULTT(unsigned long x, unsigned long y);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMULWB(long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMULWT(long x, unsigned long y);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SXTAB (long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SXTAH (long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UXTAB (unsigned long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UXTAH (unsigned long x, unsigned long y);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long long __UMAAL(unsigned long x,
                                       unsigned long y,
                                       unsigned long a,
                                       unsigned long b);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLALBB(unsigned long x,
                                 unsigned long y,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLALBT(unsigned long x,
                                 unsigned long y,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLALTB(unsigned long x,
                                 unsigned long y,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLALTT(unsigned long x,
                                 unsigned long y,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UXTB16(unsigned long x);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UXTAB16(unsigned long acc, unsigned long x);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SXTB16(unsigned long x);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SXTAB16(unsigned long acc, unsigned long x);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SASX(unsigned long, unsigned long) ;
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SSAX(unsigned long, unsigned long) ;
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHASX(unsigned long, unsigned long) ;
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHSAX(unsigned long, unsigned long) ;
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QASX(unsigned long, unsigned long) ;
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QSAX(unsigned long, unsigned long) ;

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UASX(unsigned long, unsigned long) ;
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __USAX(unsigned long, unsigned long) ;
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHASX(unsigned long, unsigned long) ;
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHSAX(unsigned long, unsigned long) ;
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQASX(unsigned long, unsigned long) ;
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQSAX(unsigned long, unsigned long) ;


 
__intrinsic __nounwind void __DMB(void);
__intrinsic __nounwind void __DSB(void);
__intrinsic __nounwind void __ISB(void);

 
__intrinsic __nounwind unsigned long __TT(unsigned long);
__intrinsic __nounwind unsigned long __TTT(unsigned long);
__intrinsic __nounwind unsigned long __TTA(unsigned long);
__intrinsic __nounwind unsigned long __TTAT(unsigned long);




__intrinsic __nounwind unsigned long __get_LR(void);
__intrinsic __nounwind void __set_LR(unsigned long);

__intrinsic __nounwind unsigned long __get_SP(void);
__intrinsic __nounwind void __set_SP(unsigned long);

#pragma language=restore










#line 140 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\portable\\IAR\\ARM_CM4F\\portmacro.h"



 

 
extern void vPortEnterCritical( void );
extern void vPortExitCritical( void );
extern uint32_t ulPortSetInterruptMask( void );
extern void vPortClearInterruptMask( uint32_t ulNewMask );

#line 157 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\portable\\IAR\\ARM_CM4F\\portmacro.h"
 

 

	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );



 



 


 






 




 
#pragma diag_suppress=Pe191
#pragma diag_suppress=Pa082







#line 322 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\portable.h"






























#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\mpu_wrappers.h"































































 





 
#line 144 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\mpu_wrappers.h"










#line 353 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\portable.h"






 



	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) ;


 
typedef struct HeapRegion
{
	uint8_t *pucStartAddress;
	size_t xSizeInBytes;
} HeapRegion_t;











 
void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions );




 
void *pvPortMalloc( size_t xSize ) ;
void vPortFree( void *pv ) ;
void vPortInitialiseBlocks( void ) ;
size_t xPortGetFreeHeapSize( void ) ;
size_t xPortGetMinimumEverFreeHeapSize( void ) ;




 
BaseType_t xPortStartScheduler( void ) ;





 
void vPortEndScheduler( void ) ;







 











#line 101 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"





 















































































































































#line 256 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"

 


























































 

	
 




	
 




	
 




	
 














	
 




	



 




	


 




	


 




	


 







 





























































































































































































































#line 633 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"






























































































 




#line 748 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"

	
 












#line 57 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\misc\\rtl8710b_ota.c"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\task.h"































































 









#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\list.h"































































 



























 
































 









 
struct xLIST_ITEM
{
	 TickType_t xItemValue;			 
	struct xLIST_ITEM *  pxNext;		 
	struct xLIST_ITEM *  pxPrevious;	 
	void * pvOwner;										 
	void *  pvContainer;				 
};
typedef struct xLIST_ITEM ListItem_t;					 

struct xMINI_LIST_ITEM
{
	 TickType_t xItemValue;
	struct xLIST_ITEM *  pxNext;
	struct xLIST_ITEM *  pxPrevious;
};
typedef struct xMINI_LIST_ITEM MiniListItem_t;



 
typedef struct xLIST
{
	 UBaseType_t uxNumberOfItems;
	ListItem_t *  pxIndex;		 
	MiniListItem_t xListEnd;						 
} List_t;







 








 








 









 








 







 







 







 








 




 





















 
#line 280 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\list.h"

















 










 







 






 











 
void vListInitialise( List_t * const pxList );









 
void vListInitialiseItem( ListItem_t * const pxItem );











 
void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem );



















 
void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem );













 
UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove );







#line 75 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\task.h"







 















 
typedef void * TaskHandle_t;




 
typedef BaseType_t (*TaskHookFunction_t)( void * );

 
typedef enum
{
	eRunning = 0,	 
	eReady,			 
	eBlocked,		 
	eSuspended,		 
	eDeleted		 
} eTaskState;



 
typedef struct xTIME_OUT
{
	BaseType_t xOverflowCount;
	TickType_t  xTimeOnEntering;
} TimeOut_t;



 
typedef struct xMEMORY_REGION
{
	void *pvBaseAddress;
	uint32_t ulLengthInBytes;
	uint32_t ulParameters;
} MemoryRegion_t;



 
typedef struct xTASK_PARAMETERS
{
	TaskFunction_t pvTaskCode;
	const char * const pcName;	 
	uint16_t usStackDepth;
	void *pvParameters;
	UBaseType_t uxPriority;
	StackType_t *puxStackBuffer;
	MemoryRegion_t xRegions[ 1 ];
} TaskParameters_t;


 
typedef struct xTASK_STATUS
{
	TaskHandle_t xHandle;			 
	const char *pcTaskName;			   
	UBaseType_t xTaskNumber;		 
	eTaskState eCurrentState;		 
	UBaseType_t uxCurrentPriority;	 
	UBaseType_t uxBasePriority;		 
	uint32_t ulRunTimeCounter;		 



	uint16_t usStackHighWaterMark;	 
} TaskStatus_t;

 
typedef enum
{
	eAbortSleep = 0,		 
	eStandardSleep,			 
	eNoTasksWaitingTimeout	 
} eSleepModeStatus;






 









 













 













 









 









 




 







 
















































































 




































































 















































 
void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) ;







































 
void vTaskDelete( TaskHandle_t xTaskToDelete ) ;



 














































 
void vTaskDelay( const TickType_t xTicksToDelay ) ;

























































 
void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) ;













































 
UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) ;
















 
eTaskState eTaskGetState( TaskHandle_t xTask ) ;








































 
void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) ;

















































 
void vTaskSuspend( TaskHandle_t xTaskToSuspend ) ;















































 
void vTaskResume( TaskHandle_t xTaskToResume ) ;



























 
BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) ;



 



























 
void vTaskStartScheduler( void ) ;






















































 
void vTaskEndScheduler( void ) ;

















































 
void vTaskSuspendAll( void ) ;




















































 
BaseType_t xTaskResumeAll( void ) ;



 









 
TickType_t xTaskGetTickCount( void ) ;














 
TickType_t xTaskGetTickCountFromISR( void ) ;












 
UBaseType_t uxTaskGetNumberOfTasks( void ) ;












 
char *pcTaskGetTaskName( TaskHandle_t xTaskToQuery ) ;  



















 
UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) ;






 
#line 1141 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\task.h"











 
BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) ;







 
TaskHandle_t xTaskGetIdleTaskHandle( void );

































































































 
UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime );













































 
void vTaskList( char * pcWriteBuffer ) ;  




















































 
void vTaskGetRunTimeStats( char *pcWriteBuffer ) ;  



 















 
BaseType_t xTaskIncrementTick( void ) ;































 
void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) ;
void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) ;











 
void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait ) ;
























 
BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) ;
BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) ;








 
void vTaskSwitchContext( void ) ;




 
TickType_t uxTaskResetEventItemValue( void ) ;



 
TaskHandle_t xTaskGetCurrentTaskHandle( void ) ;



 
void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) ;




 
BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) ;




 
void vTaskMissedYield( void ) ;




 
BaseType_t xTaskGetSchedulerState( void ) ;




 
void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) ;




 
BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) ;




 
BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) ;  



 
UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) ;




 
void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) ;








 
void vTaskStepTick( const TickType_t xTicksToJump ) ;














 
eSleepModeStatus eTaskConfirmSleepModeStatus( void ) ;




 
void *pvTaskIncrementMutexHeldCount( void );








#line 58 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\misc\\rtl8710b_ota.c"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sockets.h"






























 





#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/opt.h"




 































 






 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\network\\include\\lwipopts.h"





















 




#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"





 









#line 22 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"

#line 150 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"

#line 1 "F:\\IAR\\arm\\inc\\c\\stdio.h"
 
 




  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 11 "F:\\IAR\\arm\\inc\\c\\stdio.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\ysizet.h"
 
 

#line 30 "F:\\IAR\\arm\\inc\\c\\ysizet.h"







#line 13 "F:\\IAR\\arm\\inc\\c\\stdio.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\ystdio.h"
 
 




  #pragma system_include







#line 58 "F:\\IAR\\arm\\inc\\c\\ystdio.h"
  

 

__intrinsic __nounwind int remove(const char *);
__intrinsic __nounwind int rename(const char *, const char *);














 
#line 14 "F:\\IAR\\arm\\inc\\c\\stdio.h"



 
#pragma rtmodel="__dlib_file_descriptor","0"

                 








#line 66 "F:\\IAR\\arm\\inc\\c\\stdio.h"

#line 88 "F:\\IAR\\arm\\inc\\c\\stdio.h"

#line 99 "F:\\IAR\\arm\\inc\\c\\stdio.h"










                 
typedef _Fpost fpos_t;

                 
#pragma language=save
#pragma language=extended

#line 125 "F:\\IAR\\arm\\inc\\c\\stdio.h"

#line 177 "F:\\IAR\\arm\\inc\\c\\stdio.h"


              
_Pragma("function_effects = no_read(1), always_returns")    __intrinsic __nounwind char * __gets(char *, int);
_Pragma("function_effects = no_read(1), always_returns")    __intrinsic __nounwind char * gets(char *);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind void perror(const char *);
_Pragma("function_effects = no_write(1), always_returns")    _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int printf(const char *, ...);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind int puts(const char *);
_Pragma("function_effects = no_write(1), always_returns")    _Pragma("__scanf_args") _Pragma("library_default_requirements _Scanf = unknown")  __intrinsic __nounwind int scanf(const char *, ...);
_Pragma("function_effects = no_read(1), no_write(2), always_returns") _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int sprintf(char *, 
                                                 const char *, ...);
_Pragma("function_effects = no_write(1,2), always_returns") _Pragma("__scanf_args") _Pragma("library_default_requirements _Scanf = unknown")  __intrinsic __nounwind int sscanf(const char *, 
                                                const char *, ...);
             __intrinsic __nounwind char * tmpnam(char *);
              
             __intrinsic __nounwind int __ungetchar(int);
_Pragma("function_effects = no_write(1), always_returns")    _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int vprintf(const char *,
                                                 __Va_list);

  _Pragma("function_effects = no_write(1), always_returns")    _Pragma("__scanf_args") _Pragma("library_default_requirements _Scanf = unknown")  __intrinsic __nounwind int vscanf(const char *, 
                                                  __Va_list);
  _Pragma("function_effects = no_write(1,2), always_returns") _Pragma("__scanf_args") _Pragma("library_default_requirements _Scanf = unknown")  __intrinsic __nounwind int vsscanf(const char *, 
                                                   const char *, 
                                                   __Va_list);

_Pragma("function_effects = no_read(1), no_write(2), always_returns")  _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int vsprintf(char *, 
                                                   const char *,
                                                   __Va_list);
               
_Pragma("function_effects = no_write(1), always_returns")      __intrinsic __nounwind size_t __write_array(const void *, size_t, size_t);

  _Pragma("function_effects = no_read(1), no_write(3), always_returns") _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int snprintf(char *, size_t, 
                                                    const char *, ...);
  _Pragma("function_effects = no_read(1), no_write(3), always_returns") _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int vsnprintf(char *, size_t,
                                                     const char *, 
                                                     __Va_list);


              __intrinsic __nounwind int getchar(void);
              __intrinsic __nounwind int putchar(int);



#pragma language=restore

#line 238 "F:\\IAR\\arm\\inc\\c\\stdio.h"




#line 292 "F:\\IAR\\arm\\inc\\c\\stdio.h"




 
#line 162 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\stdlib.h"
 
 

#line 468 "F:\\IAR\\arm\\inc\\c\\stdlib.h"

#line 494 "F:\\IAR\\arm\\inc\\c\\stdlib.h"




 
#line 163 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\string.h"
 
 
#line 456 "F:\\IAR\\arm\\inc\\c\\string.h"

#line 479 "F:\\IAR\\arm\\inc\\c\\string.h"




 
#line 164 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
	#include <stdarg.h>  
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"







 




#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"


 




 



 








 
#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 42 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 52 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 62 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 





 





 





 





 





 





 





 





 





 





 




 





 







 





 






 





 




 




 




 







 




 




 




 






 




 




 




 




 








 
#line 14 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"


















 




#line 1 "F:\\IAR\\arm\\inc\\c\\stdint.h"
 
 
#line 235 "F:\\IAR\\arm\\inc\\c\\stdint.h"

#line 258 "F:\\IAR\\arm\\inc\\c\\stdint.h"




 
#line 25 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"






















		













typedef unsigned int	        uint;
typedef	signed int		        sint;


typedef signed long long        __int64_t;
typedef unsigned long long      __uint64_t;


#line 77 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"





typedef unsigned char           BOOL;


typedef unsigned char           bool;








typedef struct { volatile int counter; } atomic_t;

typedef enum _RTK_STATUS_ {
    _EXIT_SUCCESS = 0,
    _EXIT_FAILURE = 1
}RTK_STATUS, *PRTK_STATUS;

#line 107 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"


typedef void * PVOID;


typedef     uint32_t dma_addr_t;

typedef     void (*proc_t)(void*);

typedef     unsigned int __kernel_size_t;
typedef     int __kernel_ssize_t;

typedef 	__kernel_size_t	SIZE_T;	
typedef	    __kernel_ssize_t	SSIZE_T;

























#line 178 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"







#line 201 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"











 




#line 228 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"

#line 241 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"







 




















































#line 307 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"






#line 319 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"





#line 331 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"

		


		


	


	
#line 348 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"
	
#line 355 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"

#line 363 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"
			









#line 379 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"

#line 386 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"

#line 394 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"








#line 411 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"




typedef unsigned char	BOOLEAN,*PBOOLEAN,boolean;







 








								
								
								
								
								

								
								
#line 449 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"












#line 480 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"







typedef struct _RAM_START_FUNCTION_ {
    void (*RamStartFun) (void);
	void (*RamWakeupFun) (void);
}RAM_START_FUNCTION, *PRAM_START_FUNCTION;

typedef struct _RAM_FUNCTION_START_TABLE_ {
	void (*RamStartFun) (void);
	void (*RamWakeupFun) (void);
	void (*RamPatchFun0) (void);
	void (*RamPatchFun1) (void);
	void (*RamPatchFun2) (void);
	void (*FlashStartFun) (void);
}RAM_FUNCTION_START_TABLE, *PRAM_FUNCTION_START_TABLE;

#line 15 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"

#line 1 "F:\\IAR\\arm\\inc\\c\\stddef.h"
 
 
#line 39 "F:\\IAR\\arm\\inc\\c\\stddef.h"

#line 49 "F:\\IAR\\arm\\inc\\c\\stddef.h"





 
#line 17 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\app\\monitor\\include\\rtl_trace.h"















 







 




 



 

 
typedef enum {
	MODULE_OS		= 0,   
	MODULE_BOOT		= 1,   
	MODULE_GDMA	= 2,   
	MODULE_GPIO		= 3,   
	MODULE_TIMER	= 4,   
	MODULE_I2C		= 5,   
	MODULE_I2S		= 6,   
	MODULE_PWM		= 7,   
	MODULE_SDIO		= 8,   
	MODULE_SPI		= 9,   
	MODULE_FLASH	= 10,  
	MODULE_UART		= 11,  
	MODULE_USOC		= 12,  
	MODULE_IPSEC	= 13,  
	MODULE_ADC		= 14,  
	MODULE_EFUSE	= 15,  
	MODULE_MONIT	= 16,  
	MODULE_MISC		= 17,  

	MODULE_NUMs            
} MODULE_DEFINE;

 
typedef enum {
	LEVEL_ERROR	= 0,  
	LEVEL_WARN	= 1,  
	LEVEL_INFO		= 2,  
	LEVEL_TRACE	= 3,  
	LEVEL_NUMs		= 4   
} LEVEL_DEFINE;


 



 

 
 
extern uint32_t ConfigDebug[];
 


















 
void LOG_MASK_MODULE(uint32_t module, uint32_t level, uint32_t new_status);
void LOG_MASK(uint32_t config[]);
void LOG_PRINTF(uint32_t module, uint32_t level, uint32_t line, const char*fmt, ...);



 
#line 120 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\app\\monitor\\include\\rtl_trace.h"



 



 



 


 
#line 18 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"

extern uint32_t ConfigDebugClose;
extern uint32_t ConfigDebugErr;
extern uint32_t ConfigDebugInfo;
extern uint32_t ConfigDebugWarn;

extern uint32_t CfgSysDebugErr;
extern uint32_t CfgSysDebugInfo;
extern uint32_t CfgSysDebugWarn;










#line 57 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"

extern  uint32_t DiagPrintf(const char *fmt, ...);
uint32_t DiagSPrintf(uint8_t *buf, const char *fmt, ...);
int prvDiagPrintf(const char *fmt, ...);
int prvDiagSPrintf(char *buf, const char *fmt, ...);






























#line 100 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"








































#line 153 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"

#line 161 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"

typedef enum {
	DBG_CFG_ERR=0,
	DBG_CFG_WARN=1,
	DBG_CFG_INFO=2
} DBG_CFG_TYPE;

typedef struct {
	uint8_t cmd_name[16];
	uint32_t	cmd_type;
} DBG_CFG_CMD;

typedef enum _CONSOLE_OP_STAGE_ {
	ROM_STAGE = 0,
	RAM_STAGE = 1
}CONSOLE_OP_STAGE;

#line 166 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\strproc.h"







 




#line 1 "F:\\IAR\\arm\\inc\\c\\stddef.h"
 
 
#line 39 "F:\\IAR\\arm\\inc\\c\\stddef.h"

#line 49 "F:\\IAR\\arm\\inc\\c\\stddef.h"





 
#line 14 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\strproc.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\va_list.h"







 




#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"


 




 



 








 
#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 42 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 52 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 62 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 





 





 





 





 





 





 





 





 





 





 




 





 







 





 






 





 




 




 




 







 




 




 




 






 




 




 




 




 








 
#line 14 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\va_list.h"


#line 36 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\va_list.h"

#line 15 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\strproc.h"

#line 24 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\strproc.h"

extern  SIZE_T _strlen(const char *s);
extern  int _strcmp(const char *cs, const char *ct);
extern  char *_strncpy(char *dest, const char *src, size_t count);
extern  char *_strcpy(char *dest, const char *src);
extern  size_t _strlen(const char *s);
extern  size_t _strnlen(const char *s, size_t count);
extern  int _strncmp(const char *cs, const char *ct, size_t count);
extern  int _sscanf(const char *buf, const char *fmt, ...);
extern  char *_strsep(char **s, const char *ct);
extern  char *skip_spaces(const char *str);
extern  int skip_atoi(const char **s);
extern  int _vsscanf(const char *buf, const char *fmt, va_list args);
extern  unsigned long long simple_strtoull(const char *cp, char **endp, unsigned int base);
extern  long simple_strtol(const char *cp, char **endp, unsigned int base);
extern  long long simple_strtoll(const char *cp, char **endp, unsigned int base);
extern  unsigned long simple_strtoul(const char *cp, char **endp, unsigned int base);
extern  const char *_parse_integer_fixup_radix(const char *s, unsigned int *base);
extern  unsigned int _parse_integer(const char *s, unsigned int base, unsigned long long *p);
extern  uint64_t div_u64(uint64_t dividend, uint32_t divisor);
extern  int64_t div_s64(int64_t dividend, int32_t divisor);
extern  uint64_t div_u64_rem(uint64_t dividend, uint32_t divisor, uint32_t *remainder);
extern  int64_t div_s64_rem(int64_t dividend, int32_t divisor, int32_t *remainder);
extern  char *_strpbrk(const char *cs, const char *ct);
extern  char *_strchr(const char *s, int c);


extern  void
prvStrCpy(
      uint8_t  *pDES,
      const uint8_t  *pSRC
);

extern  uint32_t
prvStrLen(
      const   uint8_t  *pSRC
);

extern   uint8_t
prvStrCmp(
      const   uint8_t  *string1,
      const   uint8_t  *string2
);

extern  uint8_t*
StrUpr(
      uint8_t  *string
);

extern  int prvAtoi(
	 const char * s
);

extern   char * prvStrStr(
	 const char * str1, 
	 const char * str2
);

extern  char* prvStrtok(
	 char *str, 
	 const char* delim
);





 
static inline char _tolower(const char c)
{
    return c | 0x20;
}

 
static inline int isodigit(const char c)
{
    return c >= '0' && c <= '7';
}
#line 108 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\strproc.h"

#line 167 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\memproc.h"







 






 
extern  void *_memset( void *s, int c, SIZE_T n );
extern  void *_memcpy( void *s1, const void *s2, SIZE_T n );
extern  int _memcmp( const void *av, const void *bv, SIZE_T len );



#line 168 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\std_lib\\include\\rtl_lib.h"




 
 








extern int __rtl_errno;


void init_rom_libgloss_ram_map(void);






extern int rtl_printf( const char* fmt, ...);
extern int rtl_vprintf(const char *fmt, va_list ap);
extern int rtl_sprintf(char* str, const char* fmt, ...);
extern int rtl_snprintf(char* str, size_t size, const char* fmt, ...);
extern int rtl_vsnprintf(char *str, size_t size, const char *fmt, va_list ap);





extern void * rtl_memchr(const void * src_void , int c , size_t length);
extern int rtl_memcmp(const void * m1 , const void * m2 , size_t n);
extern void * rtl_memcpy(void * dst0 , const void * src0 , size_t len0);
extern void * rtl_memmove( void * dst_void , const void * src_void , size_t length);
extern void * rtl_memset(void * m , int c , size_t n);
extern char * rtl_strcat(char * s1 , const char * s2);
extern char * rtl_strchr(const char *s1 , int i);
extern int rtl_strcmp(const char *s1 ,	const char *s2);
extern char* rtl_strcpy(char *dst0 , const char *src0);
extern size_t rtl_strlen(const char *str);
extern char * rtl_strncat(char * s1 , const char * s2 , size_t n);
extern int rtl_strncmp(const char *s1 , const char *s2 , size_t n);
extern char * rtl_strncpy(char * dst0 , const char * src0 , size_t count);
extern char * rtl_strstr(const char *searchee , const char *lookfor);
extern char * rtl_strsep(char **source_ptr , const char *delim);
extern char * rtl_strtok(char * s , const char * delim);






extern double rtl_fabs(double);
extern float rtl_fabsf(float a);
extern float rtl_cos_f32(float a);
extern float rtl_sin_f32(float a);

extern float rtl_fadd(float a, float b);
extern float rtl_fsub(float a, float b);
extern float rtl_fmul(float a, float b);
extern float rtl_fdiv(float a, float b);

extern int rtl_fcmplt(float a, float b);
extern int rtl_fcmpgt(float a, float b);








extern double rtl_ftod(float f);

extern double rtl_ddiv(double a, double b);






typedef union
{
  float value;
  uint32_t 	word;
} ieee_float_shape_type;

 

#line 100 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\std_lib\\include\\rtl_lib.h"

 

#line 109 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\std_lib\\include\\rtl_lib.h"

static inline
float rtl_nanf(void)
{
	float x;

	do { ieee_float_shape_type sf_u; sf_u . word = (0x7fc00000); (x) = sf_u . value; } while (0);
	return x;
}






extern int rtl_sscanf_patch_test(void);
extern int rtl_lib_test( uint16_t argc,  uint8_t *argv[]);
extern int rtl_math_test( uint16_t argc,  uint8_t *argv[]);
extern int rtl_string_test( uint16_t argc,  uint8_t *argv[]);
















#line 171 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\std_lib\\libc\\rom\\string\\rom_libc_string.h"




 





#line 27 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\std_lib\\libc\\rom\\string\\rom_libc_string.h"





extern  void * __rtl_memchr_v1_00(const void * src_void , int c , size_t length);
extern  int __rtl_memcmp_v1_00(const void * m1 , const void * m2 , size_t n);
extern  void * __rtl_memcpy_v1_00(void *  dst0 , const void *  src0 , size_t len0);
extern  void * __rtl_memmove_v1_00( void * dst_void , const void * src_void , size_t length);
extern  void * __rtl_memset_v1_00(void * m , int c , size_t n);
extern  char * __rtl_strcat_v1_00(char * s1 , const char * s2);
extern  char * __rtl_strchr_v1_00(const char *s1 , int i);
extern  int __rtl_strcmp_v1_00(const char *s1 ,	const char *s2);
extern  char* __rtl_strcpy_v1_00(char *dst0 , const char *src0);
extern  size_t __rtl_strlen_v1_00(const char *str);
extern  char * __rtl_strncat_v1_00(char * s1 , const char * s2 , size_t n);
extern  int __rtl_strncmp_v1_00(const char *s1 , const char *s2 , size_t n);
extern  char * __rtl_strncpy_v1_00(char * dst0 , const char * src0 , size_t count);
extern  char * __rtl_strstr_v1_00(const char *searchee , const char *lookfor);
extern  char * __rtl_strsep_v1_00(register char **source_ptr , register const char *delim);
extern  char * __rtl_strtok_v1_00(register char * s , register const char * delim);

#line 172 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"


#line 196 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
	
#line 218 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
	
#line 227 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
	



	
#line 240 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
	
	
	






extern void *pvPortMalloc( size_t xWantedSize );
extern void vPortFree( void *pv );
#line 259 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"


#line 28 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\network\\include\\lwipopts.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"




 




#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"


 




 



 








 
#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"



 
#line 42 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"



 
#line 52 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"



 
#line 62 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"



 





 





 





 





 





 





 





 





 





 





 




 





 







 





 






 





 




 




 




 







 




 




 




 






 




 




 




 




 








 
#line 11 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"
 




 
#line 27 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"

 




 
#line 41 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"



 


 



 










 







#line 83 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"

 
#line 96 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"

 
#line 106 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"

 


 


 





 







 



 
#line 143 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"



 







 



 

#line 174 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"
 

 


 


 


 


 

   
 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 


 
#line 255 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"

 
#line 270 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"

 


#line 286 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"

 
#line 302 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"











 





 





















 

 


 
#line 358 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"

 
#line 379 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"

 






 





 

 
#line 403 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"






 


	 
 


 


 


 


 
















#line 450 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_opts.h"

#line 29 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\network\\include\\lwipopts.h"

    




 



 










 






 


 



 
#line 72 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\network\\include\\lwipopts.h"



 


 


 


 


 


 



 
 






 






 



 




 


 


 



 



 



 


 


 


 



 


 


 


 




 



 


#line 187 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\network\\include\\lwipopts.h"

#line 217 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\network\\include\\lwipopts.h"

 








 





 




#line 252 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\network\\include\\lwipopts.h"
   

   

   

   

   

   








 


 






 


 






 








 

#line 310 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\network\\include\\lwipopts.h"

 






 
#line 46 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/opt.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/debug.h"






























 



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/arch.h"






























 











#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/cc.h"






























 



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch\\cpu.h"






























 





#line 36 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/cc.h"

typedef unsigned   char    u8_t;
typedef signed     char    s8_t;
typedef unsigned   short   u16_t;
typedef signed     short   s16_t;
typedef unsigned   int    u32_t;
typedef signed     long    s32_t;
typedef u32_t mem_ptr_t;
typedef int sys_prot_t;

#line 53 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/cc.h"

 
#line 68 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/cc.h"







#line 98 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/cc.h"



#line 44 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/arch.h"

 




 




























#line 136 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/arch.h"



#line 203 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/arch.h"





extern int errno;








#line 36 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/debug.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/opt.h"




 































 
#line 37 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/debug.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\stdio.h"
 
 
#line 241 "F:\\IAR\\arm\\inc\\c\\stdio.h"

#line 292 "F:\\IAR\\arm\\inc\\c\\stdio.h"




 
#line 38 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/debug.h"





 
#line 50 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/debug.h"

 

 


 

 

 

 


#line 71 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/debug.h"

 








 


#line 96 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/debug.h"







#line 47 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/opt.h"





 





 







 







 







 







 








 




 








 








 







 








 












 







 









 







 









 





















 








 




 







 








 







 







 







 







 










 









 









 









 







 







 








 








 






 







 








 








 







 







 







 






 








 


 






 










 













 











 






 








 






 









 




 








 








 








 








 









 










 







 






 








 







 










 








 








 



 






 






 






 








 


 






 








 


 






 








 


 







 










 








 



 








 







 








 








 







 








 







 








 


 








 



 




 




 




 




 




 













 





 








 


 






 






 






 








 


 






 







 






 






 







 










 











 








 







 








 








 







 







 






 








 

















 






 







 










 










 




 








 








 



 






 







 







 







 










 







 







 
















 












 








 


 








 


 








 


 








 








 








 






 








 








 






 








 








 






 








 








 








 








 








 








 








 



 







 






 






 








 


 







 








 








 







 







 






 






 






 








 








 


 




#line 1603 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/opt.h"

#line 1616 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/opt.h"







 


 






 






 




#line 1782 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/opt.h"





 


 



 


 



 


 






 



 


 



 


 






 







 








 

 











 







 





 




 







 






 






 






 






 






 






 






 






 






 






 






 






 






 






 






 






 






 






 






 







 






 






 






 






 






 






 






 






 






 






 






 






 






 






 




#line 38 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sockets.h"



#line 1 "F:\\IAR\\arm\\inc\\c\\stddef.h"
 
 
#line 39 "F:\\IAR\\arm\\inc\\c\\stddef.h"

#line 49 "F:\\IAR\\arm\\inc\\c\\stddef.h"





 
#line 42 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sockets.h"

#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/ip_addr.h"






























 



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/def.h"






























 



 














 











 

#line 76 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/def.h"







#line 99 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/def.h"
u16_t lwip_htons(u16_t x);
u16_t lwip_ntohs(u16_t x);
u32_t lwip_htonl(u32_t x);
u32_t lwip_ntohl(u32_t x);




 
#line 115 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/def.h"









#line 37 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/ip_addr.h"






 
struct ip_addr {
  u32_t addr;
};


 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/bpstruct.h"






























 


#pragma pack(1)


#line 52 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/ip_addr.h"


struct ip_addr_packed {
  u32_t addr;
} ;

#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/epstruct.h"






























 


#pragma pack()




#line 60 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/ip_addr.h"



 
typedef struct ip_addr ip_addr_t;
typedef struct ip_addr_packed ip_addr_p_t;




 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/bpstruct.h"






























 


#pragma pack(1)


#line 73 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/ip_addr.h"


struct ip_addr2 {
  u16_t addrw[2];
} ;

#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/epstruct.h"






























 


#pragma pack()




#line 81 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/ip_addr.h"


 
struct netif;

extern const ip_addr_t ip_addr_any;
extern const ip_addr_t ip_addr_broadcast;



 



 

 

 

 





 





























#line 145 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/ip_addr.h"

 
#line 153 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/ip_addr.h"



 




 

 



 

 

 


 



 

 


 









 









u8_t ip4_addr_isbroadcast(u32_t addr, const struct netif *netif);


u8_t ip4_addr_netmask_valid(u32_t netmask);





#line 218 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/ip_addr.h"

 





 





 


u32_t ipaddr_addr(const char *cp);
int ipaddr_aton(const char *cp, ip_addr_t *addr);
 
char *ipaddr_ntoa(const ip_addr_t *addr);
char *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen);





#line 44 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sockets.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\ipv4\\lwip/inet.h"






























 











 
struct in_addr {
  u32_t s_addr;
};

 

 

 

 





 

































 


 









#line 45 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sockets.h"





 
struct sockaddr_in {
  u8_t sin_len;
  u8_t sin_family;
  u16_t sin_port;
  struct in_addr sin_addr;
  char sin_zero[8];
};

struct sockaddr {
  u8_t sa_len;
  u8_t sa_family;
  char sa_data[14];
};


 

typedef u32_t socklen_t;


 






 
#line 89 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sockets.h"





 
#line 105 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sockets.h"




 
struct linger {
       int l_onoff;                 
       int l_linger;                
};



 













 









 






 
#line 156 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sockets.h"

#line 164 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sockets.h"





 






typedef struct ip_mreq {
    struct in_addr imr_multiaddr;  
    struct in_addr imr_interface;  
} ip_mreq;

















 
#line 205 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sockets.h"









 
#line 225 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sockets.h"











 
#line 243 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sockets.h"
                                        
 







#line 258 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sockets.h"

 
#line 267 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sockets.h"

 
#line 275 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sockets.h"


 
#line 284 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sockets.h"







 


   






  typedef struct fd_set {
          unsigned char fd_bits [(8+7)/8];
        } fd_set;




  





struct timeval {
  long    tv_sec;          
  long    tv_usec;         
};


void lwip_socket_init(void);

int lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen);
int lwip_bind(int s, const struct sockaddr *name, socklen_t namelen);
int lwip_shutdown(int s, int how);
int lwip_getpeername (int s, struct sockaddr *name, socklen_t *namelen);
int lwip_getsockname (int s, struct sockaddr *name, socklen_t *namelen);
int lwip_getsockopt (int s, int level, int optname, void *optval, socklen_t *optlen);
int lwip_setsockopt (int s, int level, int optname, const void *optval, socklen_t optlen);
int lwip_close(int s);
int lwip_connect(int s, const struct sockaddr *name, socklen_t namelen);
int lwip_listen(int s, int backlog);
int lwip_recv(int s, void *mem, size_t len, int flags);
int lwip_read(int s, void *mem, size_t len);
int lwip_recvfrom(int s, void *mem, size_t len, int flags,
      struct sockaddr *from, socklen_t *fromlen);
int lwip_send(int s, const void *dataptr, size_t size, int flags);
int lwip_sendto(int s, const void *dataptr, size_t size, int flags,
    const struct sockaddr *to, socklen_t tolen);
int lwip_socket(int domain, int type, int protocol);
int lwip_write(int s, const void *dataptr, size_t size);
int lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
                struct timeval *timeout);
int lwip_ioctl(int s, long cmd, void *argp);
int lwip_fcntl(int s, int cmd, int val);

#line 364 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sockets.h"

#line 371 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/sockets.h"









#line 59 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\misc\\rtl8710b_ota.c"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip\\sys.h"






























 









#line 76 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip\\sys.h"

 




 


#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/err.h"






























 











 



typedef s8_t err_t;


 

#line 62 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/err.h"














extern const char *lwip_strerr(err_t err);








#line 86 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip\\sys.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/sys_arch.h"






























 



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\queue.h"































































 


















 
typedef void * QueueHandle_t;





 
typedef void * QueueSetHandle_t;





 
typedef void * QueueSetMemberHandle_t;

 




 
#line 112 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\queue.h"
























































 

















































































 

















































































 



















































































 


















































































 























































































 
BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition ) ;






























































































 
































 
BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void * const pvBuffer ) ;



























































































 


































































































 
BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeek ) ;













 
UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue ) ;















 
UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue ) ;












 
void vQueueDelete( QueueHandle_t xQueue ) ;




































































 






































































 






















































































 









































































 













































































 
BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition ) ;























































































 
BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken ) ;




 
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue ) ;
BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue ) ;
UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue ) ;















 
BaseType_t xQueueAltGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, BaseType_t xCopyPosition );
BaseType_t xQueueAltGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, BaseType_t xJustPeeking );













 
BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken );
BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxTaskWoken );
BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait );
BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait );





 
QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType ) ;
QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount ) ;
void* xQueueGetMutexHolder( QueueHandle_t xSemaphore ) ;




 
BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait ) ;
BaseType_t xQueueGiveMutexRecursive( QueueHandle_t pxMutex ) ;






 























 













 







 
QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType ) ;
















































 
QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength ) ;






















 
BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) ;

















 
BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) ;


































 
QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait ) ;



 
QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet ) ;

 
void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait ) ;
BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue ) ;
void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber ) ;
UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue ) ;
uint8_t ucQueueGetQueueType( QueueHandle_t xQueue ) ;








#line 38 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/sys_arch.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\semphr.h"































































 










typedef QueueHandle_t SemaphoreHandle_t;


















































 
#line 135 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\semphr.h"













































 


































































 




























































































 














 






























































 



















































































 













 


























































































 

































 














































 






















































 






























































 













 














 





#line 39 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\port\\realtek\\arch/sys_arch.h"





typedef SemaphoreHandle_t sys_sem_t;
typedef SemaphoreHandle_t sys_mutex_t;
typedef QueueHandle_t sys_mbox_t;
typedef TaskHandle_t sys_thread_t;

typedef struct _sys_arch_state_t
{
	
	char cTaskName[( 10 )];
	unsigned short nStackDepth;
	unsigned short nTaskCount;
} sys_arch_state_t;








 



#line 87 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip\\sys.h"

 
typedef void (*lwip_thread_fn)(void *arg);


 

 


 

 
#line 107 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip\\sys.h"

#line 132 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip\\sys.h"

 




 
err_t sys_sem_new(sys_sem_t *sem, u8_t count);

 
void sys_sem_signal(sys_sem_t *sem);




 
u32_t sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout);

 
void sys_sem_free(sys_sem_t *sem);
 


 
int sys_sem_valid(sys_sem_t *sem);


 
void sys_sem_set_invalid(sys_sem_t *sem);


 

void sys_msleep(u32_t ms);  


 




 
err_t sys_mbox_new(sys_mbox_t *mbox, int size);



 
void sys_mbox_post(sys_mbox_t *mbox, void *msg);


 
err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg);






 
u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout);
 






 
u32_t sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg);

 


 
void sys_mbox_free(sys_mbox_t *mbox);


 
int sys_mbox_valid(sys_mbox_t *mbox);


 
void sys_mbox_set_invalid(sys_mbox_t *mbox);








 
sys_thread_t sys_thread_new(const char *name, lwip_thread_fn thread, void *arg, int stacksize, int prio);
sys_thread_t sys_thread_new_tcm(const char *name, lwip_thread_fn thread , void *arg, int stacksize, int prio);



 
void sys_init(void);


 
u32_t sys_jiffies(void);



 
u32_t sys_now(void);

 



 





 






 









 








 

sys_prot_t sys_arch_protect(void);
void sys_arch_unprotect(sys_prot_t pval);

#line 289 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip\\sys.h"






 

#line 305 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip\\sys.h"

#line 314 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip\\sys.h"

#line 323 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip\\sys.h"

#line 332 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip\\sys.h"






#line 60 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\misc\\rtl8710b_ota.c"

#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\mbed\\hal_ext\\flash_api.h"























 




#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\mbed\\targets\\hal\\rtl8711b\\device.h"














 






























#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\mbed\\targets\\hal\\rtl8711b\\objects.h"














 



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\cmsis\\device\\cmsis.h"





























 




#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\ameba_soc.h"







 



 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"







 



#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"


 




 



 








 
#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 42 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 52 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 62 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 





 





 





 





 





 





 





 





 





 





 




 





 







 





 






 





 




 




 




 







 




 




 




 






 




 




 




 




 








 
#line 13 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\section_config.h"







 






#line 21 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\section_config.h"






















        

















    






#line 84 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\section_config.h"





























        





        

#line 127 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\section_config.h"





 



#line 15 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_sys_on.h"



 




 
#line 17 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_sys_on.h"

 
#line 25 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_sys_on.h"

 
#line 41 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_sys_on.h"

 
#line 65 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_sys_on.h"

 






#line 91 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_sys_on.h"

 
#line 101 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_sys_on.h"

 



 






 


 
#line 124 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_sys_on.h"

 
#line 132 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_sys_on.h"

 
#line 140 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_sys_on.h"


#line 175 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_sys_on.h"




#line 196 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_sys_on.h"

#line 17 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_peri_on.h"














 

#line 23 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_peri_on.h"




#line 39 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_peri_on.h"


#line 50 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_peri_on.h"
									

#line 60 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_peri_on.h"











#line 83 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_peri_on.h"


















 





#line 120 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_peri_on.h"
























#line 160 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_peri_on.h"







 




 




#line 18 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\hal_platform.h"















 






#line 29 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\hal_platform.h"
 

#line 38 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\hal_platform.h"

 


 
































































































































































































 
  
 


 










#line 274 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\hal_platform.h"
 

 


 

 



 
typedef struct {
	volatile uint32_t DLL;				 
	volatile uint32_t DLH_INTCR;			 
	volatile uint32_t INTID;				 
	volatile uint32_t LCR;				 
	volatile uint32_t MCR;				 
	volatile const uint32_t LSR;					 
	volatile const uint32_t MDSR;				 
	volatile uint32_t SPR;				 
	volatile uint32_t STSR;				 
	volatile uint32_t RB_THR;			 
	volatile uint32_t MISCR;				 
	volatile uint32_t TXPLSR;				 
	
	volatile uint32_t RXPLSR;			 
	volatile uint32_t BAUDMONR;			 
	volatile uint32_t RSVD2;				 
	volatile uint32_t DBG_UART;			 

	 
	volatile uint32_t RX_PATH;			 
	volatile uint32_t MON_BAUD_CTRL;	 
	volatile uint32_t MON_BAUD_STS;		 
	volatile uint32_t MON_CYC_NUM;		 
	volatile uint32_t RX_BYTE_CNT;		 

	 
	volatile uint32_t FCR;				 
} UART_TypeDef;
 

 



 
typedef struct {
    volatile  uint32_t CTRLR0;				 
    volatile  uint32_t CTRLR1;				 
    volatile  uint32_t SSIENR;				 
    volatile  uint32_t MWCR;				 
    volatile  uint32_t SER;					 
    volatile  uint32_t BAUDR;				 
    volatile  uint32_t TXFTLR;				 
    volatile  uint32_t RXFTLR;				 
    volatile const  uint32_t TXFLR;				 
    volatile const  uint32_t RXFLR;				 
    volatile const  uint32_t SR;					 
    volatile  uint32_t IMR;					 
    volatile const  uint32_t ISR;					 
    volatile const  uint32_t RISR;					 
    volatile const  uint32_t TXOICR;				 
    volatile const  uint32_t RXOICR;				 
    volatile const  uint32_t RXUICR;				 
    volatile const  uint32_t MSTICR;				 
    volatile const  uint32_t ICR;					 
    volatile  uint32_t DMACR;				 
    volatile  uint32_t DMATDLR;				 
    volatile  uint32_t DMARDLR;				 
    volatile const  uint32_t IDR;					 
    volatile const  uint32_t SSI_COMP_VERSION;		 
    volatile  uint32_t DR[36];				 
    volatile  uint32_t RX_SAMPLE_DLY;		 
}SPI_TypeDef;
 

 



 
typedef struct
{
	volatile uint32_t ctrlr0;			 
	volatile uint32_t ctrlr1;			 
	volatile uint32_t ssienr;			 
	volatile uint32_t mwcr;			 
	volatile uint32_t ser;				 
	volatile uint32_t baudr;			 
	volatile uint32_t txftlr;				 
	volatile uint32_t rxftlr;				 
	volatile uint32_t txflr;				 
	volatile uint32_t rxflr;				   
	volatile uint32_t sr;				 
	volatile uint32_t imr;				 
	volatile uint32_t isr;				 
	volatile uint32_t risr;				 
	volatile uint32_t txoicr;			 
	volatile uint32_t rxoicr;			     
	volatile uint32_t rxuicr;			 
	volatile uint32_t msticr;			 
	volatile uint32_t icr;				  
	volatile uint32_t dmacr;			 
	volatile uint32_t dmatdlr;			 
	volatile uint32_t dmardlr;			 
	volatile uint32_t idr;				 
	volatile uint32_t spi_flash_version;	 
	union{
		volatile uint8_t  byte;
		volatile uint16_t half;
		volatile uint32_t word;
	} dr[32];						 
	volatile uint32_t rd_fast_single;		 
	volatile uint32_t rd_dual_o;		 
	volatile uint32_t rd_dual_io;		 
	volatile uint32_t rd_quad_o; 		 
	volatile uint32_t rd_quad_io;		 
	volatile uint32_t wr_single;			 
	volatile uint32_t wr_dual_i;			 
	volatile uint32_t wr_dual_ii;		 
	volatile uint32_t wr_quad_i;		  
	volatile uint32_t wr_quad_ii;		 
	volatile uint32_t wr_enable;		 
	volatile uint32_t rd_status;			 
	volatile uint32_t ctrlr2;			 
	volatile uint32_t fbaudr;			 
	volatile uint32_t addr_length;		 
	volatile uint32_t auto_length;		 
	volatile uint32_t valid_cmd;		 
	volatile uint32_t flash_size;			 
	volatile uint32_t flush_fifo;			 
} SPIC_TypeDef;
 

 



 
typedef struct {
	volatile uint32_t FIFO_READ;		 
	volatile uint32_t CONTROL;			 
	volatile uint32_t INTR_EN;			 
	volatile uint32_t INTR_STS;			 
	volatile uint32_t COMP_VALUE_L;		 
	volatile uint32_t COMP_VALUE_H;		 
	volatile uint32_t COMP_SET;			 
	volatile uint32_t POWER;			 
	volatile uint32_t ANAPAR_AD0;		 
	volatile uint32_t ANAPAR_AD1;		 
	volatile uint32_t ANAPAR_AD2;		 
	volatile uint32_t ANAPAR_AD3;		 
	volatile uint32_t ANAPAR_AD4;		 
	volatile uint32_t ANAPAR_AD5;		 
	volatile uint32_t CALI_DATA;		 
} ADC_TypeDef;
 

 



 
typedef struct
{
	volatile uint32_t IC_CON;				 
	volatile uint32_t IC_TAR;				 
	volatile uint32_t IC_SAR; 				 
	volatile uint32_t IC_HS_MADDR;		 

	volatile uint32_t IC_DATA_CMD;		 
	volatile uint32_t IC_SS_SCL_HCNT;	 
	volatile uint32_t IC_SS_SCL_LCNT;	 
	volatile uint32_t IC_FS_SCL_HCNT;	 

	volatile uint32_t IC_FS_SCL_LCNT;	 
	volatile uint32_t IC_HS_SCL_HCNT;	 
	volatile uint32_t IC_HS_SCL_LCNT; 	 
	volatile const uint32_t IC_INTR_STAT;		 

	volatile uint32_t IC_INTR_MASK;		 
	volatile const uint32_t IC_RAW_INTR_STAT;	   
	volatile uint32_t IC_RX_TL;			 
	volatile uint32_t IC_TX_TL;			 

	volatile const uint32_t IC_CLR_INTR;			 
	volatile const uint32_t IC_CLR_RX_UNDER;	 
	volatile const uint32_t IC_CLR_RX_OVER;		 
	volatile const uint32_t IC_CLR_TX_OVER;		 

	volatile const uint32_t IC_CLR_RD_REQ;		 
	volatile const uint32_t IC_CLR_TX_ABRT;		 
	volatile const uint32_t IC_CLR_RX_DONE;   	 
	volatile const uint32_t IC_CLR_ACTIVITY;	 

	volatile const uint32_t IC_CLR_STOP_DET;	 
	volatile const uint32_t IC_CLR_START_DET;	 
	volatile const uint32_t IC_CLR_GEN_CALL;	 
	volatile uint32_t IC_ENABLE;			 

	volatile const uint32_t IC_STATUS;			 
	volatile const uint32_t IC_TXFLR;				 
	volatile const uint32_t IC_RXFLR;				 
	volatile uint32_t IC_SDA_HOLD;		 

	volatile const uint32_t IC_TX_ABRT_SOURCE;	 
	volatile uint32_t IC_SLV_DATA_NACK_ONLY;	 
	volatile uint32_t IC_DMA_CR;			 
	volatile uint32_t IC_DMA_TDLR;		 

	volatile uint32_t IC_DMA_RDLR;		 
	volatile uint32_t IC_SDA_SETUP;		 
	volatile uint32_t IC_ACK_GENERAL_CALL;	 
	volatile uint32_t IC_ENABLE_STATUS;	 

	 
	volatile uint32_t IC_DMA_CMD;		 
	volatile uint32_t IC_DMA_DAT_LEN;	 
	volatile uint32_t IC_DMA_MOD;		 
	volatile uint32_t IC_SLEEP;			 

	volatile uint32_t IC_RSVD1[4];			 
	volatile const uint32_t IC_RSVD2[4];			 
	volatile const uint32_t IC_RSVD3[4];			 

	volatile const uint32_t IC_RSVD4;			 
	volatile const uint32_t IC_CLR_ADDR_MATCH;	 
	volatile const uint32_t IC_CLR_DMA_I2C_DONE;	 
	volatile uint32_t IC_FILTER;			 

	volatile const uint32_t IC_RSVD5;			 
	volatile uint32_t IC_SAR1;			 
	volatile uint32_t IC_DATA_S1;		 
	volatile const uint32_t IC_COMP_VERSION;	 
} I2C_TypeDef;
 

 



 
typedef struct
{
	volatile uint32_t IS_CTL;				 
	volatile uint32_t IS_TX_PAGE_PTR;		 
	volatile uint32_t IS_RX_PAGE_PTR; 		 
	volatile uint32_t IS_SETTING;			 

	volatile uint32_t IS_TX_MASK_INT;		 
	volatile uint32_t IS_TX_STATUS_INT;		 
	volatile uint32_t IS_RX_MASK_INT;		 
	volatile uint32_t IS_RX_STATUS_INT;		 

	volatile uint32_t IS_TX_PAGE_OWN[4];	 
	volatile uint32_t IS_RX_PAGE_OWN[4];	 
} I2S_TypeDef;
 

 






 


 
typedef struct {
	volatile uint16_t CCRx;		 
	volatile uint8_t RSVD;		 
	volatile uint8_t CCMRx;		 
} RTIM_CCR_TypeDef;



 
typedef struct {
	volatile uint32_t EN;			 
	volatile uint32_t CR;			 
	volatile uint32_t DIER;		 
	volatile uint32_t SR;			 
	volatile uint32_t EGR;		 
	volatile uint32_t CNT;		 
	volatile uint32_t PSC;			 
	volatile uint32_t ARR;		 

	volatile uint32_t CCMRx[6];	 
} RTIM_TypeDef;
 

 



 
typedef struct {
	volatile uint32_t TR;			 
	volatile uint32_t CR;			 
	volatile uint32_t ISR;			 
	volatile uint32_t PRER;		 
	volatile uint32_t CALIBR;		 
	volatile uint32_t ALMR1;		 
	volatile uint32_t ALMR2;		 
	volatile uint32_t WPR;		 
} RTC_TypeDef;
 

 



 
typedef struct {
	volatile uint32_t PADCTR[21];			 
} PINMUX_TypeDef;
 

 



 


 
typedef struct {
	volatile uint32_t DR;		 
	volatile uint32_t DDR;		 
	volatile uint32_t CTRL;		 
} GPIO_Port_TypeDef;



 
typedef struct {
	GPIO_Port_TypeDef PORT[4];			 

	volatile uint32_t INT_EN;				 
	volatile uint32_t INT_MASK;				 
	volatile uint32_t INT_TYPE;				 
	volatile uint32_t INT_POLARITY;			 
	volatile uint32_t INT_STATUS;			 
	volatile uint32_t INT_RAWSTATUS;		 
	volatile uint32_t DEBOUNCE;				 
	volatile uint32_t PORTA_EOI;			 

	volatile uint32_t EXT_PORT[4];			 

	volatile uint32_t LSSYNC;				 
	volatile uint32_t IDCODE;				 
	volatile uint32_t RSVD2;				 
	volatile uint32_t VERIDCODE;			 
	volatile uint32_t CONFIG2;				 
	volatile uint32_t CONFIG1;				 
} GPIO_TypeDef;
 

 



 
typedef struct {
	volatile uint32_t IPSSDAR;		 
	volatile uint32_t IPSDDAR;		 
	volatile uint32_t IPSCSR;			 
	volatile uint32_t IPSCTR;			 
} IPSEC_TypeDef;
 

 



 
typedef struct {
	volatile uint32_t SIE_CR;				 
	volatile uint32_t CLK_RST_CTRL;			 
	volatile uint32_t CHANN_CTRL;			 
	volatile uint32_t BUFF_SIZE_CTRL;		 
	volatile uint32_t TXBD_BAR;				 
	volatile uint32_t RXBD_BAR;				 
	volatile uint32_t RING_SIZE_CTRL;		 
	volatile uint32_t RSVD1;				 
	volatile const	 uint32_t TXBD_HW_IDX;			 
	volatile uint32_t TXBD_SW_IDX;			 
	volatile const   uint32_t RXBD_HW_IDX;			 
	volatile uint32_t RXBD_SW_IDX;			 
	volatile uint32_t INTR_MASK;			 
	volatile uint32_t INTR_CLR;				 
	volatile uint32_t INTR_STAT;			 
	volatile uint32_t RSVD2;				 
	volatile uint32_t TX_MIT;				 
	volatile uint32_t RX_MIT;				 
	volatile uint32_t RSVD3[2];				 
	volatile uint32_t IOREG_MAR;			 
	volatile uint32_t RSVD4[3];				 
	volatile uint32_t TX_MAIN_BUF_CTRL;		 
	volatile uint32_t TX_DEST_BUF_CTRL;		 
	volatile uint32_t RX_MAIN_BUF_CTRL;		 
	volatile uint32_t RX_SRC_BUF_CTRL;		 
	volatile uint32_t TX_STUCK_TIMER;		 
	volatile uint32_t RX_STUCK_TIMER;		 
	volatile uint32_t QOS_CTRL;				 
} USOC_REG_TypeDef;
 

 



 
typedef struct {
	volatile uint32_t CLK_INFO;			 
	volatile uint32_t CLK_OUT;			 
	volatile uint32_t CLK_REF;			 
	volatile uint32_t CTRL;				 
} NCO32k_TypeDef;
 

 






 
typedef struct {
	volatile uint32_t NCOReg;
} NCO8M_TypeDef;
 

 




 
typedef struct {
	volatile uint32_t DWORD[4];  
} BACKUP_REG_TypeDef;
 

 



 
typedef struct {
	volatile uint32_t SPICC_EN;					 
	volatile uint32_t SPICC_FLUSH;				 
	volatile uint32_t SPICC_INTR;					 
	volatile uint32_t SPICC_RST_CUNT;			 
	volatile uint32_t SPICC_RD_EVT_CUNT;		 
	volatile uint32_t SPICC_HIT_EVT_CUNT;		 
	volatile uint32_t SPICC_HIT_LSTW_EVT_CUNT;	 
	volatile uint32_t SPICC_RD_PEND_CUNT;		 
} SPIC_CACHE_TypeDef;
 

 

 


 









#line 774 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\hal_platform.h"

 

 

 
#line 19 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_pinmux.h"
















 






 




 




 


































 
  
 



  




  
#line 123 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_pinmux.h"


 



 




 



 
#line 146 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_pinmux.h"














 




 
#line 177 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_pinmux.h"


 





 






 



 
#line 205 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_pinmux.h"


 



 



 
 void PAD_CMD(uint8_t PinName, uint8_t NewStatus);
 void PAD_DrvStrength(uint8_t PinName, uint32_t DrvStrength);
 void PAD_PullCtrl(uint8_t PinName, uint8_t PullType);
 void Pinmux_Config(uint8_t PinName, uint32_t PinFunc);
 uint32_t Pinmux_ConfigGet(uint8_t PinName);
 void Pinmux_Deinit(uint8_t PinName);
 void PINMUX_Ctrl(uint32_t  Function, uint32_t  PinLocation, BOOL Operation);
 void PINMUX_SWD_OFF(void);
 BOOL PINMUX_SWD_REG(uint32_t Addr);



 



 



 




 
 




 

#line 20 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_vector.h"
















 






 




 
















 

 



 
typedef int32_t IRQn_Type;
typedef void (*HAL_VECTOR_FUN) (void);
typedef uint32_t (*IRQ_FUN)(void *Data);


 

 


 



  
enum IRQn {
	   
	NonMaskableInt_IRQn		= -14,	 
	HardFault_IRQn				= -13,	 
	MemoryManagement_IRQn	= -12,	 
	BusFault_IRQn				= -11,	 
	UsageFault_IRQn			= -10,	 
	SVCall_IRQn					= -5,	 
	DebugMonitor_IRQn			= -4,	 
	PendSV_IRQn				= -2,	 
	SysTick_IRQn				= -1,	 

	 
	SYSTEM_ON_IRQ				=  0,	 
	WDG_IRQ					=  1,	 
	TIMER0_IRQ					=  2,	 
	TIMER1_IRQ					=  3,	 
	TIMER2_IRQ					=  4,	 
	TIMER3_IRQ					=  5,	 
	SPI0_IRQ					=  6,	 
	GPIO_IRQ					=  7,	 
	UART0_IRQ					=  8,	 
	SPI_FLASH_IRQ				=  9,	 
	UART1_IRQ					=  10,	 
	TIMER4_IRQ					=  11,	 
	SDIO_DEVICE_IRQ			=  12,	 
	I2S0_PCM0_IRQ				=  13,	 
	TIMER5_IRQ					=  14,	 
	WL_DMA_IRQ				=  15,	 
	WL_PROTOCOL_IRQ			=  16,	 
	CRYPTO_IRQ					=  17,	 
	SPI1_IRQ					=  18,	 
	PERIPHERAL_IRQ				=  19,	 
	GDMA0_CHANNEL0_IRQ		=  20,	 
	GDMA0_CHANNEL1_IRQ		=  21,	 
	GDMA0_CHANNEL2_IRQ		=  22,	 
	GDMA0_CHANNEL3_IRQ		=  23,	 
	GDMA0_CHANNEL4_IRQ		=  24,	 
	GDMA0_CHANNEL5_IRQ		=  25,	 

	I2C0_IRQ                     		=  26,	 
	I2C1_IRQ                     		=  27,	 
	UART_LOG_IRQ                     	=  28,	 
	ADC_IRQ                     		=  29,	 
	RDP_IRQ                     		=  30,	 
	RTC_IRQ                     			=  31,	 

	GDMA1_CHANNEL0_IRQ		=  32,	 
	GDMA1_CHANNEL1_IRQ		=  33,	 
	GDMA1_CHANNEL2_IRQ		=  34,	 
	GDMA1_CHANNEL3_IRQ		=  35,	 
	GDMA1_CHANNEL4_IRQ		=  36,	 
	GDMA1_CHANNEL5_IRQ		=  37,	 
	USB_IRQ					=  38,	 
	RXI300_IRQ					=  39,	 
	USB_SIE_IRQ				=  40,	 
};


 



 

 


 
extern  void VECTOR_TableInit(uint32_t StackP);
extern  void VECTOR_TableInitForOS(void *PortSVC, void *PortPendSVH, void *PortSysTick);
extern  BOOL VECTOR_IrqRegister(IRQ_FUN IrqFun, IRQn_Type IrqNum, uint32_t Data, uint32_t Priority);
extern  BOOL VECTOR_IrqUnRegister(IRQn_Type IrqNum);
extern  void VECTOR_IrqEn(IRQn_Type   IrqNum, uint32_t Priority);
extern  void VECTOR_IrqDis(IRQn_Type   IrqNum);









 



 



 

 
extern IRQ_FUN UserIrqFunTable[64];
extern uint32_t UserIrqDataTable[64];
extern HAL_VECTOR_FUN  NewVectorTable[];

#line 174 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_vector.h"


 
#line 21 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_diag.h"
















 






 




 



















 

 



  



 

 


 
 void DIAG_UartInit(BOOL InitConsol);
 void UartLogIrqHandle(void * Data);
 void DIAG_UartReInit(IRQ_FUN IrqFun);

 void LOGUART_PutChar(uint8_t c);
 uint8_t LOGUART_GetChar(BOOL    PullMode);
 uint32_t LOGUART_GetIMR(void);
 void LOGUART_SetIMR (uint32_t SetValue);
 void LOGUART_WaitBusy(void);







 




 



 

 
typedef struct _COMMAND_TABLE_ {
    const   uint8_t* cmd;
    uint16_t     ArgvCnt;
    uint32_t     (*func)(uint16_t argc, uint8_t* argv[]);
    const   uint8_t* msg;
}COMMAND_TABLE, *PCOMMAND_TABLE;

typedef uint32_t (*monitor_cmd_handler)(uint16_t argc, uint8_t* argv[]);

extern COMMAND_TABLE  UartLogRomCmdTable[];


 
#line 22 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_efuse.h"
















 






 




 




























































 

 



  



  




 



 



  



 



 



 




 



  







 



 



 



 

 


 


 
 extern void EFUSE_PowerSwitchROM(uint8_t bWrite, uint8_t PwrState, uint8_t L25OutVoltage);
 extern uint32_t EFUSE_OneByteReadROM(uint32_t CtrlSetting, uint16_t Addr, uint8_t *Data, uint8_t L25OutVoltage);
 extern uint32_t EFUSE_OneByteWriteROM(uint32_t CtrlSetting, uint16_t Addr, uint8_t Data, uint8_t L25OutVoltage);
 extern uint8_t EFUSE_LogicalMap_Read(uint8_t *pbuf);
 extern uint8_t EFUSE_LogicalMap_Write(uint32_t addr, uint32_t cnts, uint8_t *data);
uint32_t EFUSE_OneByteRead_ACUT(uint32_t CtrlSetting, uint16_t Addr, uint8_t *Data, uint8_t L25OutVoltage);
uint8_t EFUSE_LogicalMap_Read_ACUT(uint8_t *pbuf);
uint8_t EFUSE_LogicalMap_Write_Check(uint32_t addr, uint32_t cnts, uint8_t *data);





 



 
 void EFUSE_USER1_Read(uint8_t *pContant);
 void EFUSE_USER2_Read(uint8_t *pContant);
 void EFUSE_USER3_Read(uint8_t *pContant);
 uint8_t EFUSE_USER1_Write(uint8_t SectionIdx, uint8_t WordEnable, uint8_t *pContant);
 uint8_t EFUSE_USER2_Write(uint8_t SectionIdx, uint8_t WordEnable, uint8_t *pContant);
 uint8_t EFUSE_USER3_Write(uint8_t SectionIdx, uint8_t WordEnable, uint8_t *pContant);
uint8_t EFUSE_USER1_Write_ACUT(uint8_t SectionIdx, uint8_t WordEnable, uint8_t *pContant);


 



 
 uint32_t EFUSE_OTP_Read1B(uint32_t CtrlSetting, uint16_t Addr, uint8_t *Data, uint8_t L25OutVoltage);
 uint32_t EFUSE_OTP_Write1B(uint32_t CtrlSetting, uint16_t Addr, uint8_t Data, uint8_t L25OutVoltage);
 void EFUSE_OTP_Read32B(uint8_t *pContant);
 uint32_t EFUSE_OTP_Write32B(uint8_t *pContant);
uint32_t EFUSE_OTP_Write1B_ACUT(uint32_t CtrlSetting, uint16_t Addr, uint8_t Data, uint8_t L25OutVoltage);
uint32_t EFUSE_OTP_Write32B_ACUT(uint8_t *pContant);


 



 
 void EFUSE_RDP_EN(void);
 void EFUSE_RDP_KEY(uint8_t *RdpKey);
 void EFUSE_OTF_KEY(uint8_t *OtfKey);
 uint32_t EFUSE_JTAG_OFF(void);
uint32_t EFUSE_JTAG_OFF_ACUT(void);


 



 




 



 


 



 
 


extern uint8_t EFUSE_MAP[512];

#line 256 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_efuse.h"


 
#line 23 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_soc_ps.h"



typedef struct
{
	uint32_t Module;
	uint32_t Status;
} PWRCFG_TypeDef;

typedef struct
{
	uint32_t Module;
	uint32_t Status;
	uint32_t Polarity;  
} WAKEPIN_TypeDef;

extern const PWRCFG_TypeDef sleep_pwrmgt_config[];
extern const PWRCFG_TypeDef sleep_wevent_config[];
extern const WAKEPIN_TypeDef sleep_wakepin_config[];

extern const PWRCFG_TypeDef dstandby_wevent_config[];
extern const WAKEPIN_TypeDef dstandby_wakepin_config[];

extern const PWRCFG_TypeDef dsleep_wevent_config[];
extern const WAKEPIN_TypeDef dsleep_wakepin_config[];

extern void SOCPS_SleepPG(void);
extern void SOCPS_InitSYSIRQ(void);
extern void SOCPS_SleepDeInit(void);
extern void SOCPS_SleepInit(void);
extern void SOCPS_DstandbyInit(void);
extern void SOCPS_DsleepInit(void);
#line 24 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\app\\monitor\\include\\rtl_consol.h"







 












typedef uint32_t (*ECHOFUNC)( uint8_t*,...);    

typedef struct {
        uint8_t  BufCount;                           
        uint8_t  UARTLogBuf[127];   
} UART_LOG_BUF, *PUART_LOG_BUF;



typedef struct {
        uint8_t  NewIdx;
        uint8_t  SeeIdx;
        uint8_t  RevdNo;
        uint8_t  EscSTS;
        uint8_t  ExecuteCmd;
        uint8_t  ExecuteEsc;
        uint8_t  BootRdy;
        uint8_t  Resvd;
        PUART_LOG_BUF   pTmpLogBuf;        
        void *pfINPUT;
        PCOMMAND_TABLE  pCmdTbl;
        uint32_t CmdTblSz;

        uint32_t  CRSTS;


        uint8_t  (*pHistoryBuf)[127];

} UART_LOG_CTL, *PUART_LOG_CTL;


#line 61 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\app\\monitor\\include\\rtl_consol.h"
























 void RtlConsolInit(uint32_t Boot, uint32_t TBLSz, void *pTBL);
 void RtlConsolTaskRom(void *Data);
 uint32_t Strtoul(const uint8_t *nptr, uint8_t **endptr, uint32_t base);
 uint32_t GetRomCmdNum(void);
 void UartLogCmdExecute(PUART_LOG_CTL   pUartLogCtlExe);
 void RtlConsolRom(uint32_t MaxWaitCount);
 void LOGUART_SetBaud_FromFlash(void);
#line 26 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_rcc.h"















 






 




 





































 


 



 



 
#line 84 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_rcc.h"


 



 
#line 99 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_rcc.h"


 



 






 



 






 



 





 



 





 



 



  



 
#line 162 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_rcc.h"


 



 
#line 175 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_rcc.h"


 



 
#line 189 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_rcc.h"


 



 













 



 




 




 

 


 
 void RCC_PeriphClockCmd(uint32_t APBPeriph, uint32_t APBPeriph_Clock, uint8_t NewState);
 void FUNC_HCI_COM(uint32_t Function_Bit, uint8_t NewState);


 




 



 

 
 


 
#line 27 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_cache.h"
















 






 




 

















 

 


 
 void Cache_Enable(uint32_t Enable);
 void Cache_Flush(void);
 void Cache_Debug(uint32_t PrintLog);


 



 



 

 
#line 28 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_syscfg.h"
















 






 




 













































































 
  
 



  



  
#line 125 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_syscfg.h"


 




 

 


 
 uint32_t SYSCFG0_Get(void);
 uint32_t SYSCFG0_CUTVersion(void);
 uint32_t SYSCFG0_BDOption(void);
 uint32_t SYSCFG1_Get(void);
 uint32_t SYSCFG1_AutoLoadDone(void);
 uint32_t SYSCFG1_TRP_LDOMode(void);
 uint32_t SYSCFG1_TRP_UARTImage(void);
 uint32_t SYSCFG1_TRP_ICFG(void);
 uint32_t SYSCFG2_Get(void);
 uint32_t SYSCFG2_ROMINFO_Get(void);
 void SYSCFG2_ROMINFO_Set(void);


 

 
 


 
 
 


 
#line 169 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_syscfg.h"
 

 


 
#line 184 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_syscfg.h"
 

 


 




 

 


 
#line 208 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_syscfg.h"
 

 


 


 

 


 
#line 229 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_syscfg.h"

 






 

 


 
#line 253 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_syscfg.h"
 

 


 
#line 265 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_syscfg.h"
 

 


 


#line 279 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_syscfg.h"
 

 


 

 
 



 



 

 
 



 
#line 29 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_pmc.h"




















 






 




 































































































 


 



  



  
#line 150 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_pmc.h"


 




  





 



 




 



 




 



 






 



 







 



 

 


 
 void SOCPS_BackupCPUClk(void);
 void SOCPS_RestoreCPUClk(void);

 void SOCPS_BootFromPS(uint32_t NewStatus);
 void SOCPS_TrapPin(uint32_t NewStatus);
 void SOCPS_ANACKSel(uint32_t ANACLK);
 void SOCPS_SetWakeEvent(uint32_t Option, uint32_t NewStatus);
 void SOCPS_ClearWakeEvent(void);
 void SOCPS_WakePinsCtrl(uint32_t GpioOption);
 void SOCPS_WakePinCtrl(uint32_t Index, uint32_t Polarity);
 void SOCPS_SetANATimer(uint32_t SDuration, uint32_t NewStatus);
 void SOCPS_SetReguWakepin(void);
 void SOCPS_SetReguTimer(uint32_t SDuration, uint32_t CalibData);
 void SOCPS_PWRMode(uint32_t pwrmode, uint32_t snz_bypss);
 void SOCPS_PWROption(uint32_t pwrmgt_option);
 void SOCPS_PWROptionExt(uint32_t pwrmgt_option);
 void SOCPS_SNZMode(uint32_t SnzMask, uint32_t NewStatus);

 uint32_t SOCPS_CLKCal(uint32_t ClkSel);

 void SOCPS_DeepStandby(void);
 void SOCPS_DeepSleep(void);
 void SOCPS_SleepPG(void);
 void SOCPS_SetReguWakepins(uint32_t PinMask);
 void SOCPS_ReguTimerCmd(uint32_t NewStatus);
 void SOCPS_WakePinDebounce(uint32_t Index, uint32_t Status);

 void SOCPS_DeepStandby_RAM(void);
 void SOCPS_SleepPG_RAM(void);
 void SOCPS_DeepSleep_RAM(void);
 void SOCPS_FlashPin_PullUp_RAM(uint32_t NewStatus, uint32_t ChipIndex);
void SOCPS_SetReguWakepins_RAM(uint32_t PinMask);
void SOCPS_ReguTimerCmd_RAM(uint32_t NewStatus);
void SOCPS_WakePinDebounce_RAM(uint32_t Index, uint32_t Status);
void SOCPS_SetReguTimer_RAM(uint32_t SDuration, uint32_t CalibData);
void SOCPS_SleepCG(void);
int SOCPS_DsleepWakeReason(void);


 


 
 


 
 
 


 




 

 


 
#line 285 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_pmc.h"
 

 


 


 

 


 
#line 315 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_pmc.h"









 

 


 										














 

 


 	






#line 362 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_pmc.h"






#line 374 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_pmc.h"
 

 


 






#line 392 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_pmc.h"






#line 404 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_pmc.h"
 

 


 


 

 


 


 

 


 









 

 


 





#line 454 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_pmc.h"

#line 464 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_pmc.h"



 
#line 477 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_pmc.h"
 

 


 									





 

 


 	


 
 



 



 

 











 
#line 30 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_clk.h"






















 



  


 




 





























































 

 



  



  
#line 114 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_clk.h"


 




  
#line 130 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_clk.h"


 




  






 
  


 

 


 
 void NCO32K_Init(uint32_t clk_out, uint32_t clk_ref, uint8_t calibration_cycles, uint8_t calibration_thrs);


 



 
 void EXT32K_Cmd(uint32_t NewStatus);


 




 
 void NCO8M_Init(uint32_t clk_ref_M, uint32_t clk_out_M);
 void NCO8M_Cmd(uint32_t NewState);


 




 
 uint32_t CPU_ClkGet(uint8_t Is_FPGA);
 void CPU_ClkSet(uint8_t  CpuType);


 



 
 uint32_t XTAL_ClkGet(void);


 



 
 uint32_t OSC8M_Calibration(uint32_t LOG_EN, uint32_t CaliCycles, uint32_t TargetClock);
 void OSC32K_Calibration(uint32_t LOG_EN, uint32_t CaliCycles);
 void OSC32K_Cmd(uint32_t NewStatus);
 uint32_t OSC8M_Get(void);


 



 
 void ISO_Set(uint32_t BitMask, uint32_t NewState);


 



 
 void PLL0_Set(uint32_t BitMask, uint32_t NewState);
 void PLL1_Set(uint32_t BitMask, uint32_t NewState);
 void PLL2_Set(uint32_t BitMask, uint32_t NewState);
 void PLL3_Set(uint32_t BitMask, uint32_t NewState);


 



 
 void XTAL0_Set(uint32_t BitMask, uint32_t NewState);
 void XTAL1_Set(uint32_t BitMask, uint32_t NewState);
 void XTAL2_Set(uint32_t BitMask, uint32_t NewState);


 



 
 


 
 
 


 

 

 


 




 

 


 

 

 


 



 

 


 



 

 


 
#line 298 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_clk.h"
 

 


 
#line 321 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_clk.h"
 

 


 
#line 333 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_clk.h"
 

 


 
#line 349 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_clk.h"
 

 


 

 

 


 




 

 


 
#line 378 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_clk.h"
 

 


 



 

 


 

 
 



 



 



 

 
extern uint32_t NCO32K_Enable;
extern uint32_t OSC8M_CLOCK_GLB;





 
static inline void NCO32K_Monitor(uint32_t NewStatus)
{
	if (NewStatus == 1) {
		((NCO32k_TypeDef *) 0x40000080)->CTRL |= (0x00000001 << 17);
	} else {
		((NCO32k_TypeDef *) 0x40000080)->CTRL &= ~(0x00000001 << 17);
	}
}

 
#line 31 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_bor.h"















 






 




 



























 

 



 



 
typedef void (*BOR_IRQ_FUN)(void);


 



 
  


  

 



 




 



 



 

void BOR2_INTRegister(void *bor_intr_hook_fun);
void BOR2_INTCmd(uint32_t NewStatus);
void BOR2_ModeSet(uint32_t Option);


 
  


 



  


 

#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_crypto.h"







 
















typedef enum _SHA2_TYPE_ {
	SHA2_NONE 	= 0,
	SHA2_224 	= 224/8,
	SHA2_256 	= 256/8,
	SHA2_384 	= 384/8,
	SHA2_512 	= 512/8
} SHA2_TYPE;




 


#line 45 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_crypto.h"











 









enum _CIPHER_AES_KEYlEN
{
	_CIPHER_AES_KEYLEN_NONE = 0,
	_CIPHER_AES_KEYLEN_128BIT = 1,
	_CIPHER_AES_KEYLEN_192BIT = 2,
	_CIPHER_AES_KEYLEN_256BIT = 3,
};


typedef struct {
	uint32_t rd_key[4 *(14 + 1)];
	int rounds;
} RTL_SW_AES_KEY;



 




typedef struct __rtl_crypto_source_s
{
	
	uint32_t sbl:15;

	uint32_t isSHA2:1;
	uint32_t md5:1;
	uint32_t hmac:1;
	
	uint32_t ctr:1;
	uint32_t cbc:1;
	uint32_t trides:1;
	uint32_t aeskl:2;
	uint32_t kam:3;
	uint32_t ms:2;
	uint32_t resv1:1;
	uint32_t fs:1;
	uint32_t eor:1;
	uint32_t own:1;

	
	uint32_t enl:15;
	uint32_t resv4:1;
	uint32_t a2eo:8;
	uint32_t resv3:5;
	uint32_t sha2:3;

	
	uint32_t resv6:16;
	uint32_t apl:8;
	uint32_t resv5:8;

	
	uint32_t sdbp;
}RTL_CRYPTO_SOURCE_T;

typedef struct __rtl_crypto_dest_s
{
	uint32_t dbl:15;
	uint32_t resv1:15;
	uint32_t eor:1;
	uint32_t own:1;

	uint32_t ddbp;

	uint32_t resv2;

	uint32_t icv[5+4]; 
} RTL_CRYPTO_DEST_T;

#line 178 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_crypto.h"



 
typedef struct _HAL_CRYPTO_ADAPTER_
{
	uint8_t isInit;  
	uint8_t dma_mode; 
	uint8_t sawb_mode;  
	uint8_t desc_num;  

	uint8_t mode_select;

	uint32_t cipher_type;
	uint8_t des;
	uint8_t trides;
	uint8_t aes;
	uint8_t isDecrypt;

	uint32_t auth_type;
	uint8_t isHMAC;
	uint8_t isMD5;
	uint8_t isSHA1;
	uint8_t isSHA2;
	SHA2_TYPE sha2type;


	uint32_t lenAuthKey;
	const uint8_t*  pAuthKey;
	uint8_t  authKey[32];
	uint32_t digestlen;

	
	RTL_SW_AES_KEY aes_key;

	uint32_t 	lenCipherKey;
	const uint8_t* pCipherKey;

	uint32_t a2eo, enl, apl; 


	uint8_t decryptKey[32];

	uint8_t pad_to_align_1[16];	
	uint8_t g_IOPAD[64*2+32];
	uint8_t *ipad;
	uint8_t *opad;

	uint8_t pad_to_align_2[24];	
	uint8_t g_authPadding[64*2+32];

	
	uint8_t idx_srcdesc;
	RTL_CRYPTO_SOURCE_T *g_ipssdar;
	RTL_CRYPTO_SOURCE_T g_src_buf[8];

	
	uint8_t idx_dstdesc;
	RTL_CRYPTO_DEST_T *g_ipsddar;
	RTL_CRYPTO_DEST_T g_dst_buf[8];
	uint8_t pad_to_align_3[16];	
} HAL_CRYPTO_ADAPTER, *PHAL_CRYPTO_ADAPTER ;





 

 
#line 257 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_crypto.h"

 







#line 285 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_crypto.h"









#line 303 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_crypto.h"














#line 333 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_crypto.h"































enum _MODE_SELECT
{
	_MS_CRYPTO = 0,
	_MS_AUTH = 1,
	_MS_AUTH_THEN_DECRYPT = 2,
	_MS_ENCRYPT_THEN_AUTH = 3,
};












	

















#line 408 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_crypto.h"







	











 





 
typedef struct rtl_ipsecScatter_s {
	uint32_t len;
	void* ptr;
} rtl_ipsecScatter_t;



static inline
uint32_t __rtl_cpu_to_be32(uint32_t val)
{
	asm volatile(
		"rev %0, %0"
	  : "=r" (val) 
	  : "0" (val));
		
	return val;
}



extern const uint32_t __AES_Te4[];
extern const uint32_t __AES_rcon[];






















extern  void CRYPTO_AlignToBe32(uint32_t *pData, int bytes4_num );
extern  void CRYPTO_MemDump(const uint8_t *start, uint32_t size, char * strHeader);
extern  int CRYPTO_Init(HAL_CRYPTO_ADAPTER *pIE);
extern  int CRYPTO_DeInit(HAL_CRYPTO_ADAPTER *pIE);
extern  int CRYPTO_Reset(HAL_CRYPTO_ADAPTER *pIE);
extern  int CRYPTO_SetSecurityMode(HAL_CRYPTO_ADAPTER *pIE, 
	 const uint32_t mode_select,  const uint32_t cipher_type,  const uint32_t auth_type,
	 const void* pCipherKey,  const uint32_t lenCipherKey, 
	 const void* pAuthKey,  const uint32_t lenAuthKey);
extern  int CRYPTO_Process(HAL_CRYPTO_ADAPTER *pIE, 
	 const uint8_t *message, 	 const uint32_t msglen, 
	 const uint8_t *pIv, 		 const uint32_t ivlen,
	 const uint32_t a2eo, 		 void *pResult);
extern  int CRYPTO_CipherInit(HAL_CRYPTO_ADAPTER *pIE, 
	 const uint32_t cipher_type, 
	 const uint8_t* key,  const uint32_t keylen);
extern  int CRYPTO_CipherEncrypt(HAL_CRYPTO_ADAPTER *pIE, 
	 const uint32_t cipher_type, 	
	 const uint8_t* message, 	 const uint32_t msglen, 
	 const uint8_t* piv, 		 const uint32_t ivlen, 
	 uint8_t* pResult);
extern  int CRYPTO_CipherDecrypt(HAL_CRYPTO_ADAPTER *pIE, 
	 const uint32_t cipher_type, 	 const uint8_t* message, 	 const uint32_t msglen, 
	 const uint8_t* piv, 			 const uint32_t ivlen, 	
	 uint8_t* pResult );

extern  void CRYPTO_SetCheckSumEn(uint32_t checksum_en);
extern  void CRYPTO_GetCheckSumData(uint32_t* pChecksum);


#line 33 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_crypto_api.h"























 






 




 















































 

 



  



  
#line 106 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_crypto_api.h"


 



 

 



 
 int rtl_cryptoEngine_init(void);
 void rtl_cryptoEngine_info(void);


 



 
 int rtl_crypto_md5( const uint8_t* message,  const uint32_t msglen,  uint8_t* pDigest);
 int rtl_crypto_md5_init(void);
 int rtl_crypto_md5_process( const uint8_t* message, const  uint32_t msglen,  uint8_t* pDigest);

 int rtl_crypto_sha1( const uint8_t* message,  const uint32_t msglen,  uint8_t* pDigest);
 int rtl_crypto_sha1_init(void);
 int rtl_crypto_sha1_process( const uint8_t* message,  const uint32_t msglen,  uint8_t* pDigest);

 int rtl_crypto_sha2( const SHA2_TYPE sha2type,  const uint8_t* message,  const uint32_t msglen,  uint8_t* pDigest);
 int rtl_crypto_sha2_init( const SHA2_TYPE sha2type);
 int rtl_crypto_sha2_process( const uint8_t* message,  const uint32_t msglen,  uint8_t* pDigest);

 int rtl_crypto_hmac_md5( const uint8_t* message,  const uint32_t msglen,  const uint8_t* key,  const uint32_t keylen,  uint8_t* pDigest);
 int rtl_crypto_hmac_md5_init( const uint8_t* key,  const uint32_t keylen);
 int rtl_crypto_hmac_md5_process( const uint8_t* message,  const uint32_t msglen,  uint8_t* pDigest);

 int rtl_crypto_hmac_sha1( const uint8_t* message,  const uint32_t msglen,  const uint8_t* key,  const uint32_t keylen,  uint8_t* pDigest);
 int rtl_crypto_hmac_sha1_init( const uint8_t* key,  const uint32_t keylen);
 int rtl_crypto_hmac_sha1_process( const uint8_t* message,  const uint32_t msglen,  uint8_t* pDigest);

 int rtl_crypto_hmac_sha2( const SHA2_TYPE sha2type,  const uint8_t* message,  const uint32_t msglen,  const uint8_t* key,  const uint32_t keylen,  uint8_t* pDigest);
 int rtl_crypto_hmac_sha2_init( const SHA2_TYPE sha2type,  const uint8_t* key,  const uint32_t keylen);
 int rtl_crypto_hmac_sha2_process( const uint8_t* message,  const uint32_t msglen,  uint8_t* pDigest);


 



 
 int rtl_crypto_aes_cbc_init( const uint8_t* key,  const uint32_t keylen);
 int rtl_crypto_aes_cbc_encrypt( const uint8_t* message,  const uint32_t msglen,  const uint8_t* iv,  const uint32_t ivlen,  uint8_t* pResult);
 int rtl_crypto_aes_cbc_decrypt( const uint8_t* message,  const uint32_t msglen,  const uint8_t* iv,  const uint32_t ivlen,  uint8_t* pResult);

 int rtl_crypto_aes_ecb_init( const uint8_t* key,  const uint32_t keylen);
 int rtl_crypto_aes_ecb_encrypt( const uint8_t* message,  const uint32_t msglen,  const uint8_t* iv,  const uint32_t ivlen,  uint8_t* pResult);
 int rtl_crypto_aes_ecb_decrypt( const uint8_t* message,  const uint32_t msglen,  const uint8_t* iv,  const uint32_t ivlen,  uint8_t* pResult);

 int rtl_crypto_aes_ctr_init( const uint8_t* key,  const uint32_t keylen);
 int rtl_crypto_aes_ctr_encrypt( const uint8_t* message,  const uint32_t msglen,  const uint8_t* iv,  const uint32_t ivlen,  uint8_t* pResult);
 int rtl_crypto_aes_ctr_decrypt( const uint8_t* message,  const uint32_t msglen,  const uint8_t* iv,  const uint32_t ivlen,  uint8_t* pResult);

 int rtl_crypto_3des_cbc_init( const uint8_t* key,  const uint32_t keylen);
 int rtl_crypto_3des_cbc_encrypt( const uint8_t* message,  const uint32_t msglen,  const uint8_t* iv,  const uint32_t ivlen,  uint8_t* pResult);
 int rtl_crypto_3des_cbc_decrypt( const uint8_t* message,  const uint32_t msglen,  const uint8_t* iv,  const uint32_t ivlen,  uint8_t* pResult);

 int rtl_crypto_3des_ecb_init( const uint8_t* key,  const uint32_t keylen);
 int rtl_crypto_3des_ecb_encrypt( const uint8_t* message,  const uint32_t msglen,  const uint8_t* iv,  const uint32_t ivlen,  uint8_t* pResult);
 int rtl_crypto_3des_ecb_decrypt( const uint8_t* message,  const uint32_t msglen,  const uint8_t* iv,  const uint32_t ivlen,  uint8_t* pResult);

 int rtl_crypto_des_cbc_init( const uint8_t* key,  const uint32_t keylen);
 int rtl_crypto_des_cbc_encrypt( const uint8_t* message,  const uint32_t msglen,  const uint8_t* iv,  const uint32_t ivlen,  uint8_t* pResult);
 int rtl_crypto_des_cbc_decrypt( const uint8_t* message,  const uint32_t msglen,  const uint8_t* iv,  const uint32_t ivlen,  uint8_t* pResult);

 int rtl_crypto_des_ecb_init( const uint8_t* key,  const uint32_t keylen);
 int rtl_crypto_des_ecb_encrypt( const uint8_t* message,  const uint32_t msglen,  const uint8_t* iv,  const uint32_t ivlen,  uint8_t* pResult);
 int rtl_crypto_des_ecb_decrypt( const uint8_t* message,  const uint32_t msglen,  const uint8_t* iv,  const uint32_t ivlen,  uint8_t* pResult);


 



 




 



 



 
#line 34 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_boot.h"




extern uint8_t* __image2_entry_func__;
extern uint8_t* __image2_validate_code__;
extern uint8_t* __image1_bss_start__;
extern uint8_t* __image1_bss_end__;
#line 19 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_boot.h"
extern uint8_t __rom_bss_start__[];
extern uint8_t __rom_bss_end__[];
extern uint8_t __flash_text_start__[];
extern uint8_t __ram_start_table_start__[];
extern uint8_t __rom_top_4k_start_[];

enum _BOOT_TYPE_ {
	BOOT_FROM_FLASH = 0,
	BOOT_FROM_SDIO  = 1,        
	BOOT_FROM_USB   = 2,
	BOOT_FROM_UART0   = 3,
	BOOT_FROM_UART1   = 4,
	BOOT_FROM_SPI   = 5,
	BOOT_FROM_RSVD  = 6,    
};

typedef struct {
	uint32_t (*rdp_valid)(void);
	int (*swd_off)(void);
	int (*boot_system_init1)(void);
	int (*boot_system_init2)(void);
	uint32_t boot_ram_end;
} BOOT_EXPORT_SYMB_TABLE;

 void SPI_Boot_ROM(void);
 void UARTIMG_Download(uint8_t uart_idx);
 void USB_Boot_ROM(void);
 void SDIO_Boot_Up(void);
 void BOOT_ROM_ShowBuildInfo(uint32_t Complete);


extern void vPortSVCHandler( void );

extern void xPortSysTickHandler( void );

extern void xPortPendSVHandler( void ); 





extern void BOOT_FLASH_Image1(void);
extern uint32_t BOOT_FLASH_RDP_VALID(void);
extern BOOT_EXPORT_SYMB_TABLE boot_export_symbol;
#line 35 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_wl_on.h"



 

 




 





 




 
#line 39 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_wl_on.h"

 
#line 49 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_wl_on.h"

 
#line 58 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_wl_on.h"

 
















#line 36 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_otf.h"
















 






 




 

















 

 



  



 

 


 
 void OTF_init(uint8_t* IV);
 void OTF_Cmd(uint32_t NewStatus);
 void OTF_Mask(uint32_t MaskIdx, uint32_t Addr, uint32_t Len, uint32_t NewStatus);
 uint32_t KEY_Request(uint32_t KeyTypeBit);
 uint32_t RDP_EN_Request(void);


 

 
 


 
 
 


 
#line 88 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_otf.h"
 

 


 




 

 


 



 

 


 





 

 



 



 

 



 
#line 37 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_flash.h"
















 




#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_flashclk.h"
















 




 
typedef struct {
	uint8_t phase_int;
	uint8_t phase_frac;
} FLASH_CLK_Phase;

typedef struct {
	uint16_t div_sel;
	uint8_t div_int;
	uint8_t div_frac;
} FLASH_CLK_Div;

extern uint8_t NEW_CALIBREATION_END[];

 
#line 23 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_flash.h"



 




 


































































 

 



 



 
typedef struct {
	uint32_t FLASH_Id;				
 
	uint8_t FLASH_cur_bitmode;		
 
	uint8_t FLASH_baud_rate;			
 
	uint8_t FLASH_baud_boot;			
 
	uint32_t FLASH_cur_cmd; 			
 
						
	 
	uint32_t FLASH_QuadEn_bit;		 
	uint32_t FLASH_Busy_bit;			
 
	uint32_t FLASH_WLE_bit; 			
 
	uint32_t FLASH_Status2_exist;		

 
	
	 
	uint8_t FLASH_rd_sample_phase;	 
	uint8_t FLASH_rd_dummy_cyle[3];	
 

	 
	uint32_t FLASH_rd_dual_o; 			 
	uint32_t FLASH_rd_dual_io; 			 
	uint32_t FLASH_rd_quad_o; 		 
	uint32_t FLASH_rd_quad_io; 		    
	uint32_t FLASH_wr_dual_i; 			 
	uint32_t FLASH_wr_dual_ii;			 
	uint32_t FLASH_wr_quad_i; 			 
	uint32_t FLASH_wr_quad_ii;			 
	uint32_t FALSH_dual_valid_cmd;		 
	uint32_t FALSH_quad_valid_cmd;	 

	 
	uint8_t FLASH_cmd_wr_en;			 
	uint8_t FLASH_cmd_rd_id;			 
	uint8_t FLASH_cmd_rd_status;		 
	uint8_t FLASH_cmd_rd_status2;		 
	uint8_t FLASH_cmd_wr_status;		 
	uint8_t FLASH_cmd_wr_status2;		

 
	uint8_t FLASH_cmd_chip_e;			 
	uint8_t FLASH_cmd_block_e;		 
	uint8_t FLASH_cmd_sector_e;		 
	uint8_t FLASH_cmd_pwdn_release;	 
	uint8_t FLASH_cmd_pwdn;			
 

	 
	uint8_t debug;					 

	 
	uint8_t phase_shift_idx;			 
} FLASH_InitTypeDef;


 


 



  



  
#line 191 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_flash.h"


 



 





 



 





 



 






 



 
#line 256 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_flash.h"










 



 
#line 279 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_flash.h"




 



 
#line 295 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_flash.h"



 



 

 


 
 void FLASH_Erase(uint32_t EraseType, uint32_t Address);
 void FLASH_SetStatus(uint8_t Cmd, uint32_t Len, uint8_t* Status);
 void FLASH_SetStatusBits(uint32_t SetBits, uint32_t NewState);
 void FLASH_WaitBusy(uint32_t WaitType);
 void FLASH_WriteEn(void);
 void FLASH_TxCmd(uint8_t cmd, uint8_t DataPhaseLen, uint8_t* pData);
 void FLASH_RxCmd(uint8_t cmd, uint32_t read_len, uint8_t* read_data);
 void FLASH_StructInit(FLASH_InitTypeDef* FLASH_InitStruct);
 void FLASH_StructInit_Micron(FLASH_InitTypeDef* FLASH_InitStruct);
 void FLASH_StructInit_MXIC(FLASH_InitTypeDef* FLASH_InitStruct);
 void FLASH_StructInit_GD(FLASH_InitTypeDef* FLASH_InitStruct);
 uint8_t FLASH_Init(uint8_t SpicBitMode);
 void FLASH_SetSpiMode(FLASH_InitTypeDef *FLASH_InitStruct, uint8_t SpicBitMode);
 void FLASH_DeepPowerDown(uint32_t NewState);
 void FLASH_TxData12B(uint32_t StartAddr, uint8_t DataPhaseLen, uint8_t* pData);
 void FLASH_RxData(uint8_t cmd, uint32_t StartAddr, uint32_t read_len, uint8_t* read_data);
 uint32_t FLASH_Calibration(FLASH_InitTypeDef* FLASH_InitStruct, uint8_t SpicBitMode, uint8_t LineDelay);

 uint32_t FLASH_ClockDiv(uint8_t Div);
 uint32_t FLASH_CalibrationNew(FLASH_InitTypeDef* FLASH_InitStruct, uint8_t SpicBitMode, uint8_t Div, uint8_t CalStep, uint8_t LineDelay, uint8_t StartIdx);
 uint32_t FLASH_CalibrationNewCmd(uint32_t NewStatus);
 uint32_t FLASH_CalibrationPhaseIdx(uint8_t phase_idx);
 uint32_t FLASH_CalibrationPhase(uint8_t phase_int, uint8_t phase_sel);
 uint32_t FLASH_Calibration500MPSCmd(uint32_t NewStatus);
 uint32_t FLASH_CalibrationInit(uint8_t CalibrationEnd);


 




 
void FLASH_Write_Lock(void);
void FLASH_Write_Unlock(void);
void FLASH_RxCmdXIP(uint8_t cmd, uint32_t read_len, uint8_t* read_data);
void FLASH_SetStatusXIP(uint8_t Cmd, uint32_t Len, uint8_t* Status);
void FLASH_SetStatusBitsXIP(uint32_t SetBits, uint32_t NewState);
void FLASH_TxData12BXIP(uint32_t StartAddr, uint8_t DataPhaseLen, uint8_t* pData);
void FLASH_TxData256BXIP(uint32_t StartAddr, uint32_t DataPhaseLen, uint8_t* pData);
void FLASH_EraseXIP(uint32_t EraseType, uint32_t Address);
void FLASH_EreaseDwordsXIP(uint32_t address, uint32_t dword_num);


 



 


 

 
 
#line 369 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_flash.h"

 


 



 


 


 
#line 390 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_flash.h"

 
#line 402 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_flash.h"

 
#line 414 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_flash.h"

 
#line 425 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_flash.h"

 






 


 






 
#line 454 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_flash.h"

 
extern FLASH_InitTypeDef flash_init_para;
extern uint32_t SpicCalibrationPattern[2];

 
#line 38 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_backup_reg.h"















 






 




 










































 

 



  



  
#line 90 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_backup_reg.h"


 


 




 
 void BKUP_Write(uint32_t DwordIdx, uint32_t WriteVal);
 uint32_t BKUP_Read(uint32_t DwordIdx);
 void BKUP_Set(uint32_t DwordIdx, uint32_t BitMask);
 void BKUP_Clear(uint32_t DwordIdx, uint32_t BitMask);


 
  
 
 


 
 
 


 
#line 127 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_backup_reg.h"



 
 



 



 


 
#line 39 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_pinmap.h"



















 



  


 




 




 


















 

 



 



 
typedef struct
{
	uint32_t PinName;  
	uint32_t Function; 
	uint32_t FuncPuPd; 
	uint32_t SleepPuPd; 
	uint32_t DrvStrenth; 
} PMAP_TypeDef;



 
  
 


 
void PMAP_Init(void);
void PMAP_Sleep(void);
void PMAP_Wake(void);


 



 



 



 

 

 
#line 40 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\hal_api.h"







 






typedef enum  _HAL_Status
{
  HAL_OK            = 0x00,
  HAL_BUSY          = 0x01,
  HAL_TIMEOUT       = 0x02,
  HAL_ERR_PARA      = 0x03,     
  HAL_ERR_MEM       = 0x04,     
  HAL_ERR_HW        = 0x05,     

  HAL_ERR_UNKNOWN   = 0xee      
  
} HAL_Status;


#line 41 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"











#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\cmsis\\core_cm4.h"
 







 

























 



 #pragma system_include   




















 




 


 

 








#line 88 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\cmsis\\core_cm4.h"

#line 104 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\cmsis\\core_cm4.h"


 
#line 130 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\cmsis\\core_cm4.h"

#line 167 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\cmsis\\core_cm4.h"

#line 1 "F:\\IAR\\arm\\inc\\c\\stdint.h"
 
 
#line 235 "F:\\IAR\\arm\\inc\\c\\stdint.h"

#line 258 "F:\\IAR\\arm\\inc\\c\\stdint.h"




 
#line 169 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\cmsis\\core_cm4.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\cmsis\\core_cmInstr.h"
 







 

























 






 



 

#line 296 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\cmsis\\core_cmInstr.h"
 

#line 1 "F:\\IAR\\arm\\inc\\c\\cmsis_iar.h"










 








#pragma system_include









#pragma diag_suppress=Pe940
#pragma diag_suppress=Pe177











#line 110 "F:\\IAR\\arm\\inc\\c\\cmsis_iar.h"

static uint32_t __get_xPSR(void)
{
  return __get_PSR();    
}





#line 173 "F:\\IAR\\arm\\inc\\c\\cmsis_iar.h"












#line 204 "F:\\IAR\\arm\\inc\\c\\cmsis_iar.h"







static inline uint32_t __RRX(uint32_t value)
{
  uint32_t result;
  __asm("RRX %0, %1" : "=r"(result) : "r" (value) );
  return(result);
}

static inline uint8_t __LDRBT(volatile uint8_t *addr)
{
  uint32_t result;
  __asm("LDRBT %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
  return ((uint8_t) result);
}

static inline uint16_t __LDRHT(volatile uint16_t *addr)
{
  uint32_t result;
  __asm("LDRHT %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
  return ((uint16_t) result);
}

static inline uint32_t __LDRT(volatile uint32_t *addr)
{
  uint32_t result;
  __asm("LDRT %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
  return(result);
}

static inline void __STRBT(uint8_t value, volatile uint8_t *addr)
{
  __asm("STRBT %1, [%0]" : : "r" (addr), "r" ((uint32_t)value) : "memory" );
}

static inline void __STRHT(uint16_t value, volatile uint16_t *addr)
{
  __asm("STRHT %1, [%0]" : : "r" (addr), "r" ((uint32_t)value) : "memory" );
}

static inline void __STRT(uint32_t value, volatile uint32_t *addr)
{
  __asm("STRT %1, [%0]" : : "r" (addr), "r" (value) : "memory" );
}





static inline uint32_t __ROR(uint32_t op1, uint32_t op2)
{
  return (op1 >> op2) | (op1 << ((sizeof(op1)*8)-op2));
}

#pragma diag_default=Pe940
#pragma diag_default=Pe177

#line 299 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\cmsis\\core_cmInstr.h"


#line 685 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\cmsis\\core_cmInstr.h"

   

#line 170 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\cmsis\\core_cm4.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\cmsis\\core_cmFunc.h"
 







 

























 






 



 

#line 310 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\cmsis\\core_cmFunc.h"
 




#line 632 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\cmsis\\core_cmFunc.h"

 


#line 171 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\cmsis\\core_cm4.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\cmsis\\core_cm4_simd.h"
 







 

























 












 


 



 

#line 135 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\cmsis\\core_cm4_simd.h"
 

 


 



#line 665 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\cmsis\\core_cm4_simd.h"

 




#line 172 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\cmsis\\core_cm4.h"








 
#line 207 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\cmsis\\core_cm4.h"

 






 
#line 223 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\cmsis\\core_cm4.h"

 













 


 





 


 
typedef union
{
  struct
  {



    uint32_t _reserved0:16;               
    uint32_t GE:4;                        
    uint32_t _reserved1:7;                

    uint32_t Q:1;                         
    uint32_t V:1;                         
    uint32_t C:1;                         
    uint32_t Z:1;                         
    uint32_t N:1;                         
  } b;                                    
  uint32_t w;                             
} APSR_Type;



 
typedef union
{
  struct
  {
    uint32_t ISR:9;                       
    uint32_t _reserved0:23;               
  } b;                                    
  uint32_t w;                             
} IPSR_Type;



 
typedef union
{
  struct
  {
    uint32_t ISR:9;                       



    uint32_t _reserved0:7;                
    uint32_t GE:4;                        
    uint32_t _reserved1:4;                

    uint32_t T:1;                         
    uint32_t IT:2;                        
    uint32_t Q:1;                         
    uint32_t V:1;                         
    uint32_t C:1;                         
    uint32_t Z:1;                         
    uint32_t N:1;                         
  } b;                                    
  uint32_t w;                             
} xPSR_Type;



 
typedef union
{
  struct
  {
    uint32_t nPRIV:1;                     
    uint32_t SPSEL:1;                     
    uint32_t FPCA:1;                      
    uint32_t _reserved0:29;               
  } b;                                    
  uint32_t w;                             
} CONTROL_Type;

 






 


 
typedef struct
{
  volatile uint32_t ISER[8];                  
       uint32_t RESERVED0[24];
  volatile uint32_t ICER[8];                  
       uint32_t RSERVED1[24];
  volatile uint32_t ISPR[8];                  
       uint32_t RESERVED2[24];
  volatile uint32_t ICPR[8];                  
       uint32_t RESERVED3[24];
  volatile uint32_t IABR[8];                  
       uint32_t RESERVED4[56];
  volatile uint8_t  IP[240];                  
       uint32_t RESERVED5[644];
  volatile  uint32_t STIR;                     
}  NVIC_Type;

 



 






 


 
typedef struct
{
  volatile const  uint32_t CPUID;                    
  volatile uint32_t ICSR;                     
  volatile uint32_t VTOR;                     
  volatile uint32_t AIRCR;                    
  volatile uint32_t SCR;                      
  volatile uint32_t CCR;                      
  volatile uint8_t  SHP[12];                  
  volatile uint32_t SHCSR;                    
  volatile uint32_t CFSR;                     
  volatile uint32_t HFSR;                     
  volatile uint32_t DFSR;                     
  volatile uint32_t MMFAR;                    
  volatile uint32_t BFAR;                     
  volatile uint32_t AFSR;                     
  volatile const  uint32_t PFR[2];                   
  volatile const  uint32_t DFR;                      
  volatile const  uint32_t ADR;                      
  volatile const  uint32_t MMFR[4];                  
  volatile const  uint32_t ISAR[5];                  
       uint32_t RESERVED0[5];
  volatile uint32_t CPACR;                    
} SCB_Type;

 















 






























 



 





















 









 


















 










































 









 









 















 






 


 
typedef struct
{
       uint32_t RESERVED0[1];
  volatile const  uint32_t ICTR;                     
  volatile uint32_t ACTLR;                    
} SCnSCB_Type;

 



 















 






 


 
typedef struct
{
  volatile uint32_t CTRL;                     
  volatile uint32_t LOAD;                     
  volatile uint32_t VAL;                      
  volatile const  uint32_t CALIB;                    
} SysTick_Type;

 












 



 



 









 






 


 
typedef struct
{
  volatile  union
  {
    volatile  uint8_t    uint8_t;                   
    volatile  uint16_t   uint16_t;                  
    volatile  uint32_t   uint32_t;                  
  }  PORT [32];                           
       uint32_t RESERVED0[864];
  volatile uint32_t TER;                      
       uint32_t RESERVED1[15];
  volatile uint32_t TPR;                      
       uint32_t RESERVED2[15];
  volatile uint32_t TCR;                      
       uint32_t RESERVED3[29];
  volatile  uint32_t IWR;                      
  volatile const  uint32_t IRR;                      
  volatile uint32_t IMCR;                     
       uint32_t RESERVED4[43];
  volatile  uint32_t LAR;                      
  volatile const  uint32_t LSR;                      
       uint32_t RESERVED5[6];
  volatile const  uint32_t PID4;                     
  volatile const  uint32_t PID5;                     
  volatile const  uint32_t PID6;                     
  volatile const  uint32_t PID7;                     
  volatile const  uint32_t PID0;                     
  volatile const  uint32_t PID1;                     
  volatile const  uint32_t PID2;                     
  volatile const  uint32_t PID3;                     
  volatile const  uint32_t CID0;                     
  volatile const  uint32_t CID1;                     
  volatile const  uint32_t CID2;                     
  volatile const  uint32_t CID3;                     
} ITM_Type;

 



 



























 



 



 



 









   






 


 
typedef struct
{
  volatile uint32_t CTRL;                     
  volatile uint32_t CYCCNT;                   
  volatile uint32_t CPICNT;                   
  volatile uint32_t EXCCNT;                   
  volatile uint32_t SLEEPCNT;                 
  volatile uint32_t LSUCNT;                   
  volatile uint32_t FOLDCNT;                  
  volatile const  uint32_t PCSR;                     
  volatile uint32_t COMP0;                    
  volatile uint32_t MASK0;                    
  volatile uint32_t FUNCTION0;                
       uint32_t RESERVED0[1];
  volatile uint32_t COMP1;                    
  volatile uint32_t MASK1;                    
  volatile uint32_t FUNCTION1;                
       uint32_t RESERVED1[1];
  volatile uint32_t COMP2;                    
  volatile uint32_t MASK2;                    
  volatile uint32_t FUNCTION2;                
       uint32_t RESERVED2[1];
  volatile uint32_t COMP3;                    
  volatile uint32_t MASK3;                    
  volatile uint32_t FUNCTION3;                
} DWT_Type;

 






















































 



 



 



 



 



 



 



























   






 


 
typedef struct
{
  volatile uint32_t SSPSR;                    
  volatile uint32_t CSPSR;                    
       uint32_t RESERVED0[2];
  volatile uint32_t ACPR;                     
       uint32_t RESERVED1[55];
  volatile uint32_t SPPR;                     
       uint32_t RESERVED2[131];
  volatile const  uint32_t FFSR;                     
  volatile uint32_t FFCR;                     
  volatile const  uint32_t FSCR;                     
       uint32_t RESERVED3[759];
  volatile const  uint32_t TRIGGER;                  
  volatile const  uint32_t FIFO0;                    
  volatile const  uint32_t ITATBCTR2;                
       uint32_t RESERVED4[1];
  volatile const  uint32_t ITATBCTR0;                
  volatile const  uint32_t FIFO1;                    
  volatile uint32_t ITCTRL;                   
       uint32_t RESERVED5[39];
  volatile uint32_t CLAIMSET;                 
  volatile uint32_t CLAIMCLR;                 
       uint32_t RESERVED7[8];
  volatile const  uint32_t DEVID;                    
  volatile const  uint32_t DEVTYPE;                  
} TPI_Type;

 



 



 












 






 



 





















 



 





















 



 



 


















 






   







 


 
typedef struct
{
  volatile const  uint32_t TYPE;                     
  volatile uint32_t CTRL;                     
  volatile uint32_t RNR;                      
  volatile uint32_t RBAR;                     
  volatile uint32_t RASR;                     
  volatile uint32_t RBAR_A1;                  
  volatile uint32_t RASR_A1;                  
  volatile uint32_t RBAR_A2;                  
  volatile uint32_t RASR_A2;                  
  volatile uint32_t RBAR_A3;                  
  volatile uint32_t RASR_A3;                  
} MPU_Type;

 









 









 



 









 






























 








 


 
typedef struct
{
       uint32_t RESERVED0[1];
  volatile uint32_t FPCCR;                    
  volatile uint32_t FPCAR;                    
  volatile uint32_t FPDSCR;                   
  volatile const  uint32_t MVFR0;                    
  volatile const  uint32_t MVFR1;                    
} FPU_Type;

 



























 



 












 
























 












 







 


 
typedef struct
{
  volatile uint32_t DHCSR;                    
  volatile  uint32_t DCRSR;                    
  volatile uint32_t DCRDR;                    
  volatile uint32_t DEMCR;                    
} CoreDebug_Type;

 




































 






 







































 






 

 
#line 1381 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\cmsis\\core_cm4.h"

#line 1390 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\cmsis\\core_cm4.h"











 










 

 



 




 










 
static inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);                

  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
  reg_value &= ~((0xFFFFUL << 16) | (7UL << 8));              
  reg_value  =  (reg_value                                 |
                ((uint32_t)0x5FA << 16) |
                (PriorityGroupTmp << 8));                                      
  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
}







 
static inline uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) >> 8);    
}







 
static inline void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 
  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F));  
}







 
static inline void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
}











 
static inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
}







 
static inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
}







 
static inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
}










 
static inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
{
  return((uint32_t)((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
}










 
static inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - 4)) & 0xff); }  
  else {
    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[(uint32_t)(IRQn)] = ((priority << (8 - 4)) & 0xff);    }         
}












 
static inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
{

  if(IRQn < 0) {
    return((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - 4)));  }  
  else {
    return((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[(uint32_t)(IRQn)]           >> (8 - 4)));  }  
}













 
static inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);           
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 4) ? 4 : 7 - PriorityGroupTmp;
  SubPriorityBits     = ((PriorityGroupTmp + 4) < 7) ? 0 : PriorityGroupTmp - 7 + 4;

  return (
           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
         );
}













 
static inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);           
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 4) ? 4 : 7 - PriorityGroupTmp;
  SubPriorityBits     = ((PriorityGroupTmp + 4) < 7) ? 0 : PriorityGroupTmp - 7 + 4;

  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
}





 
static inline void NVIC_SystemReset(void)
{
  __DSB();                                                     
 
  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FA << 16)      |
                 (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) |
                 (1UL << 2));                    
  __DSB();                                                      
  while(1);                                                     
}

 



 




 

#line 1691 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\cmsis\\core_cm4.h"

 



 




 

extern volatile int32_t ITM_RxBuffer;                     












 
static inline uint32_t ITM_SendChar (uint32_t ch)
{
  if ((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL << 0))                  &&       
      (((ITM_Type *) (0xE0000000UL) )->TER & (1UL << 0)        )                    )      
  {
    while (((ITM_Type *) (0xE0000000UL) )->PORT[0]. uint32_t == 0);
    ((ITM_Type *) (0xE0000000UL) )->PORT[0]. uint8_t = (uint8_t) ch;
  }
  return (ch);
}








 
static inline int32_t ITM_ReceiveChar (void) {
  int32_t ch = -1;                            

  if (ITM_RxBuffer != 0x5AA55AA5) {
    ch = ITM_RxBuffer;
    ITM_RxBuffer = 0x5AA55AA5;        
  }

  return (ch);
}








 
static inline int32_t ITM_CheckChar (void) {

  if (ITM_RxBuffer == 0x5AA55AA5) {
    return (0);                                  
  } else {
    return (1);                                  
  }
}







 
static inline void NVIC_SetVectorTable(uint32_t TableAddress)
{
    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR = TableAddress;
}

 





#line 54 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"




#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_gdma.h"
















 






 



 



























































































































 


 



 



 
typedef struct {
	uint8_t	GDMA_Index;      

 
	                                     
	uint8_t	GDMA_ChNum;   

 
	
	uint32_t	GDMA_DIR;	     
 
	
	uint32_t	GDMA_DstDataWidth;    
 
					          
	uint32_t	GDMA_SrcDataWidth;    
 
					                
	uint32_t	GDMA_DstInc;		  
 
					                
	uint32_t	GDMA_SrcInc;              
 
					                
	uint32_t	GDMA_DstMsize;          
 
					                
	uint32_t	GDMA_SrcMsize;          
 
					                
	uint32_t	GDMA_SrcAddr;           


 
					                
	uint32_t	GDMA_DstAddr;          


 
					                
	uint16_t	GDMA_BlockSize; 	      



 

	uint32_t	GDMA_IsrType;        
 

	uint32_t	GDMA_ReloadSrc;     



 
				
	uint32_t	GDMA_ReloadDst;    



 

	uint32_t	GDMA_LlpDstEn;    

 
					                
	uint32_t	GDMA_LlpSrcEn;     

 

	uint32_t	GDMA_SrcHandshakeInterface;    

 
    
	uint32_t	GDMA_DstHandshakeInterface;   

 

	uint32_t	MuliBlockCunt;                
 
					                
	uint32_t	MaxMuliBlock;                
 
} GDMA_InitTypeDef, *PGDMA_InitTypeDef;



 
typedef struct {
	uint32_t Sarx;             

 
					                
	uint32_t Darx;            

 
					                
	uint32_t Llpx;              

 
					                
	uint32_t CtlxLow;        

 
					         
	uint32_t CtlxUp;          

 
					         
	uint32_t Temp;           
 
}GDMA_CH_LLI_ELE, *PGDMA_CH_LLI_ELE;



 
struct GDMA_CH_LLI {
	GDMA_CH_LLI_ELE	 LliEle;     

 
					         
	uint32_t BlockSize;                    
 
	
	struct GDMA_CH_LLI *pNextLli;          

 
};



 
  


 



 









                          


 



 
#line 326 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_gdma.h"


 



    
#line 339 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_gdma.h"




 



 
#line 354 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_gdma.h"
                                            


 



 





                                  



 



 





 



 
#line 399 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_gdma.h"


 


 
#line 415 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_gdma.h"


 



 




 
 void GDMA_StructInit(PGDMA_InitTypeDef GDMA_InitStruct);
 void GDMA_Init(uint8_t GDMA_Index, uint8_t GDMA_ChNum, PGDMA_InitTypeDef GDMA_InitStruct);
 void GDMA_SetLLP(uint8_t GDMA_Index, uint8_t GDMA_ChNum, uint32_t MultiBlockCount, struct GDMA_CH_LLI *pGdmaChLli);
 void GDMA_Cmd(uint8_t GDMA_Index, uint8_t GDMA_ChNum, uint32_t NewState);
 void GDMA_INTConfig(uint8_t GDMA_Index, uint8_t GDMA_ChNum, uint32_t GDMA_IT, uint32_t NewState);
 uint32_t 	GDMA_ClearINTPendingBit(uint8_t GDMA_Index, uint8_t GDMA_ChNum, uint32_t GDMA_IT);
 uint32_t 	GDMA_ClearINT(uint8_t GDMA_Index, uint8_t GDMA_ChNum);
 void GDMA_ChCleanAutoReload(uint8_t GDMA_Index, uint8_t GDMA_ChNum, uint32_t CleanType);

 void GDMA_SetSrcAddr(uint8_t GDMA_Index, uint8_t GDMA_ChNum, uint32_t SrcAddr);
 uint32_t 	GDMA_GetSrcAddr(uint8_t GDMA_Index, uint8_t GDMA_ChNum);
 uint32_t 	GDMA_GetDstAddr(uint8_t GDMA_Index, uint8_t GDMA_ChNum);
 void GDMA_SetDstAddr(uint8_t GDMA_Index, uint8_t GDMA_ChNum, uint32_t DstAddr);
 void GDMA_SetBlkSize(uint8_t GDMA_Index, uint8_t GDMA_ChNum, uint32_t BlkSize);
 uint32_t GDMA_GetBlkSize(uint8_t GDMA_Index, uint8_t GDMA_ChNum);

 BOOL GDMA_ChnlRegister (uint8_t GDMA_Index, uint8_t GDMA_ChNum);
 void GDMA_ChnlUnRegister (uint8_t GDMA_Index, uint8_t GDMA_ChNum);
 uint8_t 	GDMA_ChnlAlloc(uint32_t GDMA_Index, IRQ_FUN IrqFun, uint32_t IrqData, uint32_t IrqPriority);
 void GDMA_ChnlFree(uint8_t GDMA_Index, uint8_t GDMA_ChNum);


 
  


 



  

 
 
#line 473 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_gdma.h"

 
#line 481 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_gdma.h"

 
#line 489 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_gdma.h"

 
#line 497 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_gdma.h"

 
#line 505 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_gdma.h"

 


 
#line 516 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_gdma.h"

 
#line 530 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_gdma.h"

 
 
























 






 








extern uint8_t GDMA_IrqNum[2][6];




 
#line 59 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_tim.h"
















 






 




 

  





















































































































































































 
  
 



 



 
typedef struct {
	uint32_t TIM_Prescaler;		
 
	uint32_t TIM_Period;			


 
	uint32_t TIM_UpdateEvent;		
 
	uint32_t TIM_UpdateSource;		


 
	uint32_t TIM_ARRProtection;	
 

	uint8_t	TIM_Idx;				 
} RTIM_TimeBaseInitTypeDef;



 
typedef struct
{
	uint32_t TIM_CCMode;         						
	uint32_t TIM_CCPolarity;    





 

	uint32_t TIM_OCProtection; 	

 

	uint32_t TIM_OCPulse;        
 

	uint32_t TIM_ICPulseMode;	  
} TIM_CCInitTypeDef;



 

 


 



 
#line 285 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_tim.h"





                                   



                                     








 



 
#line 314 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_tim.h"

#line 321 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_tim.h"
                                 


 



 



 
                                      


 
















  



 

#line 367 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_tim.h"

#line 375 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_tim.h"

#line 384 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_tim.h"



  




 





#line 407 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_tim.h"
  


  




 















 





       









 



 
  


 

  

 
 void RTIM_TimeBaseStructInit(RTIM_TimeBaseInitTypeDef* TIM_InitStruct);
 void RTIM_TimeBaseInit(RTIM_TypeDef* TIMx, RTIM_TimeBaseInitTypeDef* TIM_InitStruct, IRQn_Type   IrqNum, IRQ_FUN UserCB, uint32_t UserCBData);
 void RTIM_Cmd(RTIM_TypeDef* TIMx, uint32_t NewState);
 void RTIM_DeInit(RTIM_TypeDef* TIMx);
 uint32_t RTIM_GetCount(RTIM_TypeDef* TIMx);
 void RTIM_UpdateDisableConfig(RTIM_TypeDef* TIMx, uint32_t NewState);
 void RTIM_ARRPreloadConfig(RTIM_TypeDef* TIMx, uint32_t NewState);
 void RTIM_UpdateRequestConfig(RTIM_TypeDef* TIMx, uint32_t TIM_UpdateSource);
 void RTIM_PrescalerConfig(RTIM_TypeDef* TIMx, uint32_t Prescaler, uint32_t TIM_PSCReloadMode);
 void RTIM_GenerateEvent(RTIM_TypeDef* TIMx, uint32_t TIM_EventSource);
 void RTIM_ChangePeriod(RTIM_TypeDef* TIMx, uint32_t Autoreload);
 void RTIM_Reset(RTIM_TypeDef* TIMx);


 

  

 
 void RTIM_CCStructInit(TIM_CCInitTypeDef* TIM_CCInitStruct);
 void RTIM_CCxInit(RTIM_TypeDef* TIMx, TIM_CCInitTypeDef* TIM_CCInitStruct, uint16_t TIM_Channel);
 void RTIM_CCRxMode(RTIM_TypeDef* TIMx, uint16_t TIM_Channel, uint32_t TIM_CCMode);
 void RTIM_CCRxSet(RTIM_TypeDef* TIMx, uint32_t Compare, uint16_t TIM_Channel);
 uint32_t RTIM_CCRxGet(RTIM_TypeDef* TIMx, uint16_t TIM_Channel);
 void RTIM_OCxPreloadConfig(RTIM_TypeDef* TIMx, uint32_t TIM_OCProtection, uint16_t TIM_Channel);
 void RTIM_CCxPolarityConfig(RTIM_TypeDef* TIMx, uint32_t TIM_OCPolarity, uint16_t TIM_Channel);
 void RTIM_CCxCmd(RTIM_TypeDef* TIMx, uint16_t TIM_Channel, uint32_t TIM_CCx);
 void RTIM_SetOnePulseOutputMode(RTIM_TypeDef* TIMx, uint32_t TIM_OPMode, uint32_t TrigerPolarity);


 

  

 
 void RTIM_DMACmd(RTIM_TypeDef* TIMx, uint16_t TIM_DMASource, uint32_t NewState);
 void RTIM_INTConfig(RTIM_TypeDef* TIMx, uint32_t TIM_IT, uint32_t NewState);
 void RTIM_INTClear(RTIM_TypeDef* TIMx);
 void RTIM_INTClearPendingBit(RTIM_TypeDef* TIMx, uint16_t TIM_IT);
 uint32_t RTIM_GetFlagStatus(RTIM_TypeDef* TIMx, uint32_t TIM_FLAG);
 uint32_t RTIM_GetINTStatus(RTIM_TypeDef* TIMx, uint32_t TIM_IT);
 uint32_t RTIM_TXGDMA_Init(uint32_t TIM_Channel, GDMA_InitTypeDef *GdmaInitStruct, void *CallbackData, IRQ_FUN CallbackFunc, uint8_t* pDataBuf, uint32_t DataLen);
 uint32_t RTIM_RXGDMA_Init(uint32_t TIM_Idx, uint32_t TIM_Channel, GDMA_InitTypeDef *GdmaInitStruct, void *CallbackData, IRQ_FUN CallbackFunc, uint8_t *pDataBuf, int DataLen);


 
  


 


 
 


 
 
 


 




 

 


 





 

 


 
 
#line 551 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_tim.h"

 
#line 560 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_tim.h"
 

 


 
#line 574 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_tim.h"
 

 


 
#line 587 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_tim.h"
 

 


 





 
 

  

 

  

 

extern int TIMx_irq[6];
extern RTIM_TypeDef* TIMx[6];
extern uint32_t TIM_IT_CCx[6];
extern uint32_t TIM_DMA_CCx[6];





 
#line 60 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_gpio.h"
















 
  





 




 






































































 

 



 



 
typedef struct {
	uint32_t GPIO_Mode;      	
 

	uint32_t GPIO_PuPd;     		
 

	uint32_t GPIO_ITTrigger;  	
 

	uint32_t GPIO_ITPolarity; 	
 

	uint32_t GPIO_ITDebounce; 	
 

	uint32_t GPIO_Pin;    		
 
} GPIO_InitTypeDef;


 

 



  



  





 



  







 



  







 



  







 



  







 



  




 



    




 



  





 



 



  
 void GPIO_WriteBit(uint32_t GPIO_Pin, uint32_t BitVal);
 uint32_t GPIO_ReadDataBit(uint32_t GPIO_Pin);
 void GPIO_DeInit(uint32_t GPIO_Pin);
 void GPIO_UserRegIrq(uint32_t GPIO_Pin, void *IrqHandler, void *IrqData);
 void GPIO_INTMode(uint32_t GPIO_Pin, uint32_t NewState, uint32_t GPIO_ITTrigger, uint32_t GPIO_ITPolarity, uint32_t GPIO_ITDebounce);
 void GPIO_INTConfig(uint32_t GPIO_Pin, uint32_t NewState);
 void GPIO_Init(GPIO_InitTypeDef  *GPIO_InitStruct);
 uint32_t GPIO_INTHandler(void *pData);
 void GPIO_Direction(uint32_t GPIO_Pin, uint32_t data_direction);
 uint32_t GPIO_PortRead(uint32_t GPIO_Port, uint32_t GPIO_Mask);
 void GPIO_PortWrite(uint32_t GPIO_Port, uint32_t GPIO_Mask, uint32_t Port_State);
 void GPIO_PortDirection(uint32_t GPIO_Port, uint32_t GPIO_Mask, uint32_t data_direction);


 



 



  


typedef void (*GPIO_IRQ_FUN)(void *Data, uint32_t Id);
typedef void (*GPIO_USER_IRQ_FUN)(uint32_t Id);


 
#line 61 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_ssi.h"
















 






 




 



























































































































 
  
 


 



 
typedef struct
{
	uint32_t  SPI_DmaRxDataLevel;     



 
							     
	uint32_t  SPI_DmaTxDataLevel;    



 
							     
	uint32_t  SPI_RxThresholdLevel;   




 
							     
	uint32_t  SPI_TxThresholdLevel;     




 
							     
	uint32_t  SPI_SlaveSelectEnable;     



    
							     
	uint32_t  SPI_ClockDivider;		    


    
							     
	uint32_t  SPI_DataFrameNumber;   



  
							     
	uint32_t   SPI_DataFrameFormat;    
  
							     
	uint32_t   SPI_DataFrameSize;        


 
							    
	uint32_t   SPI_InterruptMask;	     
  
							   
	uint32_t   SPI_Role;                        
  
							  	
	uint32_t   SPI_SclkPhase;		    




  
							  	
	uint32_t   SPI_SclkPolarity;              



  
							    
	uint32_t   SPI_TransferMode;         

  
								
	uint32_t   SPI_MicrowireControlFrameSize;  
  
																
	uint32_t   SPI_MicrowireDirection;	         
  
																
	uint32_t   SPI_MicrowireHandshaking;        
  
																
	uint32_t   SPI_MicrowireTransferMode;       
  
}SSI_InitTypeDef;



 

 



  



  






 



  




 



  




 



  
#line 307 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_ssi.h"


 



  
#line 330 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_ssi.h"


 



  




 



  






 



  






 



  




 



  




 



  




 



  




 



 

 


 


 
 void SSI_Cmd(SPI_TypeDef *spi_dev, uint32_t NewStaus);
 void SSI_SetSclkPolarity(SPI_TypeDef *spi_dev, uint32_t SclkPolarity);
 void SSI_SetSclkPhase(SPI_TypeDef *spi_dev, uint32_t SclkPhase);
 void SSI_WriteData(SPI_TypeDef *spi_dev, uint32_t value);
 void SSI_INTConfig(SPI_TypeDef* spi_dev, uint32_t SSI_IT, uint32_t newState);
 void SSI_SetRxFifoLevel(SPI_TypeDef *spi_dev, uint32_t RxThresholdLevel);
 void SSI_SetTxFifoLevel(SPI_TypeDef *spi_dev, uint32_t TxThresholdLevel);
 void SSI_SetSlaveEnable(SPI_TypeDef *spi_dev, uint32_t SlaveIndex);
 uint32_t SSI_Busy(SPI_TypeDef *spi_dev);
 uint32_t SSI_Writeable(SPI_TypeDef *spi_dev);
 uint32_t SSI_Readable(SPI_TypeDef *spi_dev);
 uint32_t SSI_GetRxCount(SPI_TypeDef *spi_dev);
 uint32_t SSI_GetTxCount(SPI_TypeDef *spi_dev);
 uint32_t SSI_GetStatus(SPI_TypeDef *spi_dev);
 uint32_t SSI_GetIsr(SPI_TypeDef *spi_dev);
 uint32_t SSI_ReadData(SPI_TypeDef *spi_dev);
 uint32_t SSI_ReceiveData(SPI_TypeDef *spi_dev, void* RxData, uint32_t Length);
 uint32_t SSI_SendData(SPI_TypeDef *spi_dev, void* TxData, uint32_t Length, uint32_t Role);
 uint32_t SSI_GetRawIsr(SPI_TypeDef *spi_dev);
 uint32_t SSI_GetSlaveEnable(SPI_TypeDef *spi_dev);
 uint32_t SSI_GetDataFrameSize(SPI_TypeDef *spi_dev);
 void SSI_Init(SPI_TypeDef *spi_dev, SSI_InitTypeDef *SSI_InitStruct);
 void SSI_StructInit(SSI_InitTypeDef* SSI_InitStruct);
 void SSI_SetDataFrameSize(SPI_TypeDef *spi_dev, uint32_t DataFrameSize);
 void SSI_SetBaud(SPI_TypeDef *SPIx, uint32_t BaudRate, uint32_t IpClk);
 void SSI_SetIsrClean(SPI_TypeDef *spi_dev, uint32_t InterruptStatus);
 void SSI_SetReadLen(SPI_TypeDef *spi_dev, uint32_t DataFrameNumber);
 void SSI_PinmuxInit(uint8_t Index, uint32_t PinmuxSelect);
 void SSI_PinmuxDeInit(uint8_t Index, uint32_t PinmuxSelect);


 



 
 BOOL SSI_TXGDMA_Init(uint32_t Index, PGDMA_InitTypeDef GDMA_InitStruct, void *CallbackData, 
										IRQ_FUN CallbackFunc, uint8_t *pTxData, uint32_t Length);
 BOOL SSI_RXGDMA_Init(uint8_t Index, GDMA_InitTypeDef *GDMA_InitStruct, void *CallbackData, 
										IRQ_FUN CallbackFunc, uint8_t  *pRxData, uint32_t Length);
 void SSI_SetDmaEnable(SPI_TypeDef *spi_dev, uint32_t newState, uint32_t Mask);
 void SSI_SetDmaLevel(SPI_TypeDef *spi_dev, uint32_t TxLeve, uint32_t RxLevel);


 



 



 
 


 
 
 


 
#line 482 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_ssi.h"
 

 


 

 

 


 

 

 


 



 

 


 

 

 


 

 

 


 

 

 


 

 

 


 

 

 


 

 

 


 
#line 560 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_ssi.h"
 

 


 
#line 572 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_ssi.h"
 

 


 
#line 584 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_ssi.h"
 

 


 
#line 596 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_ssi.h"
 

 


 


 

 


 

 

 


 

 

 


 

 
 



 



 

 
typedef struct
{
	SPI_TypeDef* SPIx;
	uint32_t Tx_HandshakeInterface;
	uint32_t Rx_HandshakeInterface;
	IRQn_Type IrqNum;
} SPI_DevTable;

extern const SPI_DevTable SPI_DEV_TABLE[2];



 
#line 62 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_uart.h"
















 






 



 


































































































































































































































 

 



 



 
typedef struct
{
	uint32_t	DmaModeCtrl; 
 
	                             
	uint32_t	WordLen;       
 
                                   
	uint32_t	StopBit;         
 
                                      
	uint32_t	Parity;           
 

	uint32_t	ParityType;    
 
                                      
	uint32_t	StickParity;    
 

	uint32_t	FlowControl;  
 
                                      
	uint32_t	RxFifoTrigLevel;   
 
                                         
	uint32_t	RxErReportCtrl;   
 
} UART_InitTypeDef;




 
typedef struct
{
	uint32_t LPUART_OscPerbitUpdCtrl;    




 
	uint32_t LPUART_BitNumThres;         


 
} LPUART_InitTypeDef;




 
typedef struct
{
	uint32_t UART_IrDARxInv;	    



 
                                              
	uint32_t UART_IrDATxInv;		  



 
                                              
	uint32_t UART_UpperShift;		
 

	uint32_t UART_UpperShiftVal;   
 
 
	uint32_t UART_LowShift;		
 
                                             
	uint32_t UART_LowShiftVal;	
 
                                             
	uint32_t UART_RxFilterThres;  

 
                                             
	uint32_t UART_RxFilterCmd;	



 
}IrDA_InitTypeDef;


 

 


 



 







 



 
  












 



 
  








 



 
  








   



 
  








 



 
  








 



 
  








 



 

#line 473 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_uart.h"



 






 
  
#line 491 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_uart.h"


 



 
  








 



 



  



 
#line 526 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_uart.h"


 




  

 


 


 
 void UART_DeInit(UART_TypeDef* UARTx);
 void UART_StructInit(UART_InitTypeDef* UART_InitStruct);
 void UART_Init(UART_TypeDef* UARTx, UART_InitTypeDef *UART_InitStruct);
 uint32_t UART_BaudParaGet(uint32_t baudrate, uint32_t *ovsr, uint32_t *ovsr_adj);
 void UART_BaudParaGetFull(uint32_t IPclk, uint32_t baudrate, uint32_t *ovsr, uint32_t *ovsr_adj);
 void UART_SetBaudExt(UART_TypeDef* UARTx, uint32_t Ovsr, uint32_t Ovsr_adj);
 void UART_SetBaud(UART_TypeDef* UARTx, uint32_t BaudRate);
 void UART_SetRxLevel(UART_TypeDef* UARTx, uint32_t FifoLv);
 void UART_RxCmd(UART_TypeDef* UARTx, uint32_t NewState);
 uint32_t UART_Writable(UART_TypeDef* UARTx);
 uint32_t UART_Readable(UART_TypeDef* UARTx);
 void UART_CharPut(UART_TypeDef* UARTx, uint8_t TxData);
 void UART_CharGet(UART_TypeDef* UARTx, uint8_t  *pRxByte);
 void UART_ReceiveData(UART_TypeDef* UARTx, uint8_t* OutBuf, uint32_t Count);
 void UART_SendData(UART_TypeDef* UARTx, uint8_t* InBuf, uint32_t Count);
 uint32_t UART_ReceiveDataTO(UART_TypeDef* UARTx, uint8_t* OutBuf, uint32_t Count, uint32_t Times);
 uint32_t UART_SendDataTO(UART_TypeDef* UARTx,uint8_t* InBuf,uint32_t Count, uint32_t Times);
 void UART_RxByteCntClear(UART_TypeDef* UARTx);
 uint32_t UART_RxByteCntGet(UART_TypeDef* UARTx);
 void UART_BreakCtl(UART_TypeDef* UARTx, uint32_t NewState);
 uint32_t UART_ClearRxFifo(UART_TypeDef* UARTx);
 void UART_ClearTxFifo(UART_TypeDef* UARTx);
 void UART_INTConfig(UART_TypeDef* UARTx, uint32_t UART_IT, uint32_t newState);
 uint32_t UART_IntStatus(UART_TypeDef* UARTx);
 uint32_t UART_ModemStatusGet(UART_TypeDef* UARTx);
 uint32_t UART_LineStatusGet(UART_TypeDef* UARTx);
 void UART_WaitBusy(UART_TypeDef* UARTx, uint32_t PollTimes);
 void UART_PinMuxInit(uint8_t UartIndex, uint8_t PinmuxSelect);
 void UART_PinMuxDeinit(uint8_t UartIndex, uint8_t PinmuxSelect);


  



 
 void UART_TXDMAConfig(UART_TypeDef* UARTx, uint32_t TxDmaBurstSize);
 void UART_RXDMAConfig(UART_TypeDef* UARTx, uint32_t RxDmaBurstSize);
 void UART_TXDMACmd(UART_TypeDef* UARTx, uint32_t NewState);
 void UART_RXDMACmd(UART_TypeDef* UARTx, uint32_t NewState);
 BOOL UART_TXGDMA_Init(uint8_t UartIndex, GDMA_InitTypeDef *GDMA_InitStruct, void *CallbackData, IRQ_FUN CallbackFunc, uint8_t *pTxBuf, int TxCount); 
 BOOL UART_RXGDMA_Init(uint8_t UartIndex, GDMA_InitTypeDef *GDMA_InitStruct, void *CallbackData, IRQ_FUN CallbackFunc, uint8_t *pRxBuf, int RxCount);


  



 
 void UART_LPRxStructInit(LPUART_InitTypeDef* UART_InitStruct);
 void UART_LPRxInit(UART_TypeDef* UARTx, LPUART_InitTypeDef *UART_InitStruct);
 void UART_LPRxBaudSet(UART_TypeDef* UARTx, uint32_t BaudRate, uint32_t RxIPClockHz);
	void UART_LPRxMonitorCmd(UART_TypeDef* UARTx, uint32_t NewState);
 void UART_LPRxpathSet(UART_TypeDef* UARTx, uint32_t LPRxpath);
 void UART_LPRxIPClockSet(UART_TypeDef* UARTx, uint32_t RxIPClock);
 void UART_LPRxCmd(UART_TypeDef* UARTx, uint32_t NewState);
 uint32_t UART_LPRxMonBaudCtrlRegGet(UART_TypeDef* UARTx);
 uint32_t UART_LPRxMonitorSatusGet(UART_TypeDef* UARTx);


  



 
 void UART_IrDAStructInit(IrDA_InitTypeDef * IrDA_InitStruct);
 void UART_IrDAInit(UART_TypeDef* UARTx, IrDA_InitTypeDef * IrDA_InitStruct);
 void UART_IrDACmd(UART_TypeDef* UARTx, uint32_t NewState);



 


 




 
 


 
 
 


 
#line 637 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_uart.h"
 

 


 


 

 


 





 

 


 								

 

 


 


 

 


 
#line 688 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_uart.h"
 

 


 



 

 


 


 

 


 













																	 


 

 


 







 

 


 



 

 


 


 

 


 




 

 


 



 

 


 
 


 
 



 



  

 
typedef struct
{		
	uint32_t LOW_POWER_RX_ENABLE;	 
} UARTCFG_TypeDef;

typedef struct
{
	UART_TypeDef* UARTx;
	uint32_t Tx_HandshakeInterface;
	uint32_t Rx_HandshakeInterface;
	IRQn_Type	IrqNum;
} UART_DevTable;

extern UARTCFG_TypeDef uart_config[];
extern const UART_DevTable UART_DEV_TABLE[3];
extern uint32_t UART_StateTx[3];
extern uint32_t UART_StateRx[3];
extern const uint32_t BAUDRATE_TABLE_40M[][3];



static inline void
UART_SetTxFlag(uint32_t UartIdx, uint32_t Flag)
{
	UART_StateTx[UartIdx] = Flag;
}

static inline void
UART_SetRxFlag(uint32_t UartIdx, uint32_t Flag)
{	
	UART_StateRx[UartIdx] = Flag;
}

static inline uint32_t
UART_GetTxFlag(uint32_t UartIdx)
{
	return (UART_StateTx[UartIdx]);
}

static inline uint32_t
UART_GetRxFlag(uint32_t UartIdx)
{
	return (UART_StateRx[UartIdx]);
}

 
#line 63 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_i2c.h"
















 






 



 
 






































































































































 
  
 


 



 
typedef struct {
	uint32_t	I2CIdx;         
 
					
	uint32_t	I2CMaster;      
 
					
	uint32_t	I2CAddrMod;     
 
					
	uint32_t	I2CSpdMod;      
 	
					
	uint32_t	I2CRXTL;        


 
				
	uint32_t	I2CTXTL;        


 
	uint32_t	I2CMstReSTR;     
				
	uint32_t	I2CMstGC;        
				
	uint32_t	I2CMstStartB;    
				
	uint32_t	I2CSlvNoAck;     
				
 	uint32_t	I2CSlvAckGC;      
	
	uint32_t	I2CAckAddr;     


 
				
	uint32_t	I2CSlvSetup;       


 
				
	uint32_t	I2CSdaHd;       


 
					
	uint32_t	I2CClk;          
				
	uint32_t	I2CIPClk;		 
					
	uint32_t	I2CFilter;       

	uint32_t	I2CTxDMARqLv;   


 
				
	uint32_t	I2CRxDMARqLv;   


  
				
	uint32_t	I2CDMAMod;     	
 
					
	uint32_t	I2CAckAddr1;    
    
}I2C_InitTypeDef;


 

 


 



 




 



 






 
  


 
#line 281 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_i2c.h"


 



 




 



 
#line 303 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_i2c.h"


 



  



 



 

 


 



 
 void I2C_Init(I2C_TypeDef *I2Cx, I2C_InitTypeDef* I2C_InitStruct);
 void I2C_Cmd(I2C_TypeDef *I2Cx, uint8_t NewState);
 void I2C_ClearAllINT(I2C_TypeDef *I2Cx);
 uint32_t I2C_GetRawINT(I2C_TypeDef *I2Cx);
 uint32_t I2C_GetINT(I2C_TypeDef *I2Cx);
 uint8_t I2C_CheckFlagState(I2C_TypeDef *I2Cx, uint32_t I2C_FLAG);
 void I2C_INTConfig(I2C_TypeDef *I2Cx, uint32_t I2C_IT, uint32_t NewState);
 void I2C_ClearINT(I2C_TypeDef *I2Cx, uint32_t INTrAddr);
 void I2C_SetSpeed(I2C_TypeDef *I2Cx, uint32_t SpdMd, uint32_t I2Clk, uint32_t I2CIPClk);
 void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct);
 uint8_t I2C_ReceiveData(I2C_TypeDef *I2Cx);
 void I2C_PinMuxInit(uint8_t I2CIdx, uint8_t PinMux);
 void I2C_PinMuxDeInit(uint8_t I2CIdx, uint8_t PinMux);


 



 
 void I2C_MasterSendNullData(I2C_TypeDef *I2Cx, uint8_t* pBuf, uint8_t  I2CCmd, uint8_t  I2CStop, uint8_t  I2CReSTR);
 void I2C_MasterSend(I2C_TypeDef *I2Cx, uint8_t* pBuf, uint8_t  I2CCmd, uint8_t  I2CStop, uint8_t  I2CReSTR);
 void I2C_MasterWrite(I2C_TypeDef *I2Cx, uint8_t* pBuf, uint8_t len);
 void I2C_MasterReadDW(I2C_TypeDef *I2Cx, uint8_t* pBuf, uint8_t len);
 uint8_t I2C_MasterRead(I2C_TypeDef *I2Cx, uint8_t* pBuf, uint8_t len);
 void I2C_MasterRepeatRead(I2C_TypeDef* I2Cx, uint8_t* pWriteBuf, uint8_t Writelen, uint8_t* pReadBuf, uint8_t Readlen);
 void I2C_SetSlaveAddress(I2C_TypeDef *I2Cx, uint16_t Address);


 



 
 void I2C_SlaveWrite(I2C_TypeDef *I2Cx, uint8_t* pBuf, uint8_t len);
 void I2C_SlaveRead(I2C_TypeDef *I2Cx, uint8_t* pBuf, uint8_t len);
 void I2C_SlaveSend(I2C_TypeDef *I2Cx, uint8_t Data);


 



 
 void I2C_DMAControl(I2C_TypeDef *I2Cx, uint32_t DmaCtrl, uint8_t NewState);
 void I2C_DmaMode1Config(I2C_TypeDef *I2Cx, uint32_t I2C_DmaCmd, uint32_t I2C_DmaBLen);
 void I2C_DmaMode2Config(I2C_TypeDef *I2Cx, uint32_t I2C_DmaCmd, uint32_t I2C_DmaBLen);
 BOOL I2C_TXGDMA_Init(uint8_t Index, GDMA_InitTypeDef *GDMA_InitStruct, void *CallbackData, IRQ_FUN CallbackFunc, uint8_t *pTxBuf, int TxCount);
 BOOL I2C_RXGDMA_Init(uint8_t Index, GDMA_InitTypeDef *GDMA_InitStruct, void *CallbackData, IRQ_FUN CallbackFunc, uint8_t *pRxBuf, int RxCount);


 
 


 
 void I2C_Sleep_Cmd(I2C_TypeDef *I2Cx, uint32_t NewStatus);
 void I2C_WakeUp(I2C_TypeDef *I2Cx);


 



 
  

 
 


 
 
 


 
#line 410 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_i2c.h"
 

 


 




 

 


 

 

 


 





 

 


 
#line 459 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_i2c.h"
 

 


 
#line 480 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_i2c.h"
 

 


 
#line 501 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_i2c.h"
 

 


 

 

 


 
#line 522 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_i2c.h"
 

 


 

 

 


 
#line 551 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_i2c.h"
 

 


 

 

 


 


 

 


 

 

 


 

 

 


 




 

 


 

 

 


 


 

 


 


 

 


 

 
 



 



 

 













typedef struct
{
	I2C_TypeDef* I2Cx;
	uint32_t Tx_HandshakeInterface;
	uint32_t Rx_HandshakeInterface;
	IRQn_Type IrqNum;
} I2C_DevTable;

extern const I2C_DevTable I2C_DEV_TABLE[2];
extern uint32_t I2C_SLAVEWRITE_PATCH;
extern uint32_t IC_FS_SCL_HCNT_TRIM;
extern uint32_t IC_FS_SCL_LCNT_TRIM;



 
#line 64 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_i2s.h"
















 






 




 


















































 

 



 



 
typedef struct {
	uint32_t I2S_SlaveMode;		
 

	uint32_t I2S_WordLen;		
 

	uint32_t I2S_Justify; 		
 

	uint32_t I2S_EndianSwap; 	
 

	uint32_t I2S_ChNum;			
 

	uint32_t I2S_PageNum;		
 

	uint32_t I2S_PageSize;		
 

	uint32_t I2S_Rate; 			
 

	uint32_t I2S_TRxAct;		
 

	uint32_t I2S_InterLoopback;
 
} I2S_InitTypeDef;


 

 



 



 








 



 








 



 











 



 









 



 










 



 









 



 
#line 232 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_i2s.h"

#line 245 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_i2s.h"



 



 



 
 void I2S_Init(I2S_TypeDef* I2Sx, I2S_InitTypeDef* I2S_InitStruct);
 void I2S_Cmd(I2S_TypeDef* I2Sx, uint8_t  NewState);
 void I2S_INTConfig(I2S_TypeDef* I2Sx, uint32_t I2STxIntrMSK, uint32_t I2SRxIntrMSK);
 void I2S_SetRate(I2S_TypeDef* I2Sx, uint32_t I2S_Rate);
 void I2S_SetWordLen(I2S_TypeDef* I2Sx, uint32_t I2S_WordLen);
 void I2S_SetChNum(I2S_TypeDef* I2Sx, uint32_t I2S_ChNum);
 void I2S_SetPageNum(I2S_TypeDef* I2Sx, uint32_t I2S_PageNum);
 void I2S_SetPageSize(I2S_TypeDef* I2Sx, uint32_t I2S_PageSize);
 void I2S_SetDirection(I2S_TypeDef* I2Sx, uint32_t I2S_TRxAct);
 void I2S_INTClear(I2S_TypeDef* I2Sx, uint32_t I2STxIntrClr, uint32_t I2SRxIntrClr);
 void I2S_INTClearAll(I2S_TypeDef* I2Sx);
 void I2S_ISRGet(I2S_TypeDef* I2Sx,	uint32_t* I2STxIsr, uint32_t* I2SRxIsr);
 void I2S_SetDMABuf(I2S_TypeDef* I2Sx, uint8_t *I2STxData, uint8_t *I2SRxData);
 uint32_t I2S_GetTxPage(I2S_TypeDef* I2Sx);
 void I2S_TxPageDMA_EN(I2S_TypeDef* I2Sx, uint32_t I2STxIdx);
 void I2S_RxPageDMA_EN(I2S_TypeDef* I2Sx, uint32_t I2SRxIdx);
 void I2S_TxDmaCmd(I2S_TypeDef* I2Sx, uint32_t NewState);
 void I2S_RxDmaCmd(I2S_TypeDef* I2Sx, uint32_t NewState);


 

 
 


 
 
 


 
#line 297 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_i2s.h"
 

 


 



 

 


 
#line 321 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_i2s.h"
 

 


 
#line 336 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_i2s.h"
 

 


 

 
 



 



 



 
#line 65 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_adc.h"
















 






 




 




















































































 

 



 



 
typedef struct {
	uint32_t ADC_CompOnly;		
 

	uint32_t ADC_OneShotEn;		
 

	uint32_t ADC_OverWREn;		
 

	uint32_t ADC_Endian;			
 

	uint32_t ADC_BurstSz;		

 

	uint32_t ADC_OneShotTD;   	

 

	uint32_t ADC_SampleClk;		 

	uint32_t ADC_DbgSel;		 
} ADC_InitTypeDef;


 

 



 



 












 




 












 




 








 



 




 



 
#line 227 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_adc.h"


 



 



 
 void ADC_Init(ADC_InitTypeDef* ADC_InitStruct);
 void ADC_InitStruct(ADC_InitTypeDef *ADC_InitStruct);
 uint32_t ADC_Read(void);
 uint32_t ADC_GetISR(void);
 void ADC_Cmd(uint32_t ADCEn);
 void ADC_INTConfig(uint32_t IntrMSK, uint32_t NewState);
 void ADC_INTClear(void);
 void ADC_INTClearPendingBits(uint32_t Mask);
 void ADC_SetAnalog(ADC_InitTypeDef* ADC_InitStruct);
 void ADC_SetComp(uint8_t ChanIdx, uint16_t ADCCompTD, uint16_t ADCCompCtrl);
 void ADC_SetOneShot(uint32_t NewState, uint32_t PeriodMs, uint32_t InterruptThresh);
 void ADC_ReceiveBuf(uint32_t *pBuf);
 void ADC_SetAudio(uint32_t NewState);
 uint32_t ADC_RXGDMA_Init(GDMA_InitTypeDef *GDMA_InitStruct, void *CallbackData, IRQ_FUN CallbackFunc, uint8_t* pDataBuf, uint32_t DataLen);


 

 
 


 
 
 


 

 

 


 
#line 281 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_adc.h"
 

 


 
#line 295 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_adc.h"
 

 


 





 

 


 





 

 


 





 
 



 



 

 
extern uint32_t ADC_AnaparAd[6];



 
#line 66 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_sdio.h"
















 






 




 

 


 


 
typedef struct {
	 
	uint32_t TXBD_BAR;			 
	uint32_t TXBD_RING_SIZE; 	 
	uint32_t TX_BUFFER_SIZE; 	 

	 
	uint32_t RXBD_BAR;			 
	uint32_t RXBD_RING_SIZE; 	 
	uint32_t RXBD_FREE_TH;		 
} SDIO_InitTypeDef;


 
  
 



 



  
#line 79 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_sdio.h"


 




  
#line 104 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_sdio.h"


 



  







 



  



 



  
#line 138 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_sdio.h"


 



 



 
 void SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct);
 void SDIO_Init(SDIO_InitTypeDef* SDIOInit_Struct);
 void SDIO_INTClear(void);
 void SDIO_INTConfig(uint16_t IntMask, uint32_t NewState);
 uint8_t SDIO_RPWM1_Get(void);
 uint16_t SDIO_RPWM2_Get(void);
 void SDIO_CPWM1_Set(uint8_t Val);
 void SDIO_CPWM2_Set(uint16_t Val, uint32_t Newstate);
 uint16_t SDIO_RXBD_RPTR_Get(void);
 void SDIO_RXBD_WPTR_Set(uint16_t Val);
 uint16_t SDIO_TXBD_WPTR_Get(void);
 void SDIO_TXBD_RPTR_Set(uint16_t Val);
 void SDIO_DMA_Reset(void);


 



 


 

#line 179 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_sdio.h"

 
#line 207 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_sdio.h"

 


 
#line 223 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_sdio.h"





 


 


#line 67 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_wdg.h"
















 






 




 

























































 

 



 



 
typedef struct
{
	uint32_t CountProcess; 		
 

	uint32_t DivFacProcess; 	
 
} WDG_InitTypeDef;


 



 
 void WDG_Scalar(uint32_t Period, uint32_t *pCountProcess, uint32_t *pDivFacProcess);
 void WDG_Init(WDG_InitTypeDef *WDG_InitStruct);
 void WDG_IrqInit(void *handler, uint32_t Id);
 void WDG_Cmd(uint32_t NewState);
 void WDG_Refresh(void);


 
  

 
 


 
 
 


 



 
 



 



  


 
#line 68 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_usb.h"
















 






 




 






















































 

 



 


 
typedef struct {
	 
	uint32_t TXBD_BAR;			 

	uint32_t TXBD_RING_SIZE; 	
 

	uint32_t TX_BUFFER_SIZE; 	
 

	uint32_t TX_BLK_SIZE;		
 

	uint32_t TX_MIT_TIME;		
 

	uint32_t TX_MIT_PKT_CNT; 	
 

	 
	uint32_t RXBD_BAR;			 

	uint32_t RXBD_RING_SIZE; 	
 

	uint32_t RX_BUFFER_SIZE; 	
 

	uint32_t RX_BLK_SIZE;		
 

	uint32_t RX_MIT_TIME;		
 

	uint32_t RX_MIT_PKT_CNT; 	
 
} USOC_InitTypeDef;



 
typedef struct {
	uint32_t pktSize:14; 		 

	uint32_t status:2;			
 

	uint32_t seqNum:16;			 

	uint32_t address;			
 
}USOC_TX_BD, *PUSOC_TX_BD;



 
typedef struct {
	uint32_t pktSize:14; 		 

	uint32_t status:2;			
 

	uint32_t seqNum:16;			 

	uint32_t address;			
 
} USOC_RX_BD, *PUSOC_RX_BD;



 

 



 



  








 



  








 



 





 



 





 



 






 



 






 



 






 



 




 



  



 
 void USOC_Cmd(USOC_REG_TypeDef * usoc_reg, uint32_t NewStatus);
 void USOC_PHY_Cmd(USOC_REG_TypeDef * usoc_reg, uint32_t NewStatus);
 void USOC_MODE_Cfg(USOC_REG_TypeDef * usoc_reg, uint32_t mode);
 void USOC_TXBD_SWIDX_Cfg(USOC_REG_TypeDef * usoc_reg, uint32_t index);
 uint32_t USOC_TXBD_SWIDX_Get(USOC_REG_TypeDef * usoc_reg);
 void USOC_RXBD_SWIDX_Cfg(USOC_REG_TypeDef * usoc_reg, uint32_t index);
 uint32_t USOC_RXBD_SWIDX_Get(USOC_REG_TypeDef * usoc_reg);
 uint32_t USOC_TXBD_HWIDX_Get(USOC_REG_TypeDef * usoc_reg);
 uint32_t USOC_RXBD_HWIDX_Get(USOC_REG_TypeDef * usoc_reg);
 void USOC_INTCfg(USOC_REG_TypeDef * usoc_reg, uint32_t mask);
 void USOC_INTClr(USOC_REG_TypeDef * usoc_reg, uint32_t mask);
 uint32_t USOC_INTGet(USOC_REG_TypeDef * usoc_reg);
 void USOC_StructInit(USOC_InitTypeDef* USOCInit_Struct);
 void USOC_Init(USOC_REG_TypeDef * usoc_reg, USOC_InitTypeDef* USOCInit_Struct);
 void USOC_POWER_On(void);
 void USOC_CH_Cmd(USOC_REG_TypeDef * usoc_reg, uint32_t ch, uint32_t NewStatus);
 void USOC_SW_RST(USOC_REG_TypeDef * usoc_reg);
 void USOC_TXSTUCK_Cfg(USOC_REG_TypeDef * usoc_reg, uint32_t NewStatus, uint32_t TVal);
 void USOC_RXSTUCK_Cfg(USOC_REG_TypeDef * usoc_reg, uint32_t NewStatus, uint32_t RVal);



 
  
 
 


 
 
 


 
#line 313 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_usb.h"
 

 


 
#line 327 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_usb.h"





 

 


 													










 

 


 


 

 


 








 

 


 
#line 388 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_usb.h"

#line 395 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_usb.h"

#line 402 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_usb.h"

#line 409 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_usb.h"
 

 


 



 

 


 



 

 


 


 

 


 


 

 


 



 

 


 


 

 


 



 
 



 



  


 
#line 69 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_dongle.h"
















 






 




 

































































 


 



 



 
typedef struct {
	void (*usb_dongle_interrupt)(void);    
} DONGLE_InitTypeDef;



 
typedef void (*DONGLE_PATCH_FUN)(void);


 



  

 



 
#line 135 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_dongle.h"


 



 




 
 void USOC_DongleSpecialCmd(uint8_t cmd_val);
 void USOC_DongleCmd(void);
 void USOC_DongleIsr(void *DATA);
 uint32_t USOC_PHY_Write(uint8_t addr, uint8_t data);
 uint32_t USOC_PHY_Read(uint8_t addr, uint8_t *data);
 void USOC_PHY_Autoload(void);
 void USOC_DongleInit(DONGLE_PATCH_FUN patch_func);
 void USOC_SIE_INTConfig(uint32_t SIE_INT, uint32_t NewState);
 void USOC_SIE_INTClear(void);
void USOC_DongleIsr_RAM(void);
void USOC_DongleReOpen_RAM(void);
void USOC_DongleInitPatch_RAM(void);
void USOC_Dongle_InitThread(void *param);


 
  


 



  



 

 
 








#line 210 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_dongle.h"

 









 
#line 70 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_rtc.h"
















 






 




 





































































 

 



 



 
typedef struct {
	uint32_t RTC_HourFormat;   
 

	uint32_t RTC_AsynchPrediv; 
 

	uint32_t RTC_SynchPrediv;  
 
} RTC_InitTypeDef;



 
typedef struct
{
	uint16_t RTC_Days;	 

	uint8_t RTC_Hours;    


 

	uint8_t RTC_Minutes;  
 

	uint8_t RTC_Seconds;  
 

	uint8_t RTC_H12_PMAM;      
 
}RTC_TimeTypeDef; 



 
typedef struct
{
	RTC_TimeTypeDef RTC_AlarmTime;      

	uint32_t RTC_AlarmMask;            
 
	uint32_t RTC_Alarm2Mask;            
 
}RTC_AlarmTypeDef;


 

 



  



  





 



  






 



  



 



  



 



  






 



  





 



  
#line 232 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_rtc.h"


 



  





 



  





 



  



 



  











 



  




 






 



  
#line 307 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_rtc.h"

#line 316 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_rtc.h"
















 



 



 
 void RTC_BypassShadowCmd(uint32_t NewState);
 void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct);
 uint32_t RTC_Init(RTC_InitTypeDef* RTC_InitStruct);
 void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct);
 uint32_t RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct);
 void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct);
 uint32_t RTC_SetAlarm(uint32_t RTC_Format, RTC_AlarmTypeDef* RTC_AlarmStruct);
 void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct);
 void RTC_GetAlarm(uint32_t RTC_Format, RTC_AlarmTypeDef* RTC_AlarmStruct);
 void RTC_AlarmCmd(uint32_t NewState);
 void RTC_AlarmClear(void);
 void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation);
 uint32_t RTC_GetStoreOperation(void);
 void RTC_OutputConfig(uint32_t RTC_Output);
 uint32_t RTC_SmoothCalibConfig(uint32_t CalibSign, uint32_t Value, uint32_t CalibPeriod, uint32_t Calib_Enable);


 

 
 


 
 
 


 
#line 378 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_rtc.h"
 

 


 
#line 392 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_rtc.h"
 

 


 









 

 


 


 

 


 




 

 


 












 

 


 


 

 


 

 
 



  



 

   
#line 476 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8711b_rtc.h"



 
#line 72 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_delay.h"





















 






 




 





















 



 
 void SYSTIMER_Init(void);
 uint32_t SYSTIMER_TickGet(void);
 uint32_t SYSTIMER_GetPassTime(uint32_t start);
 void DelayUs(uint32_t us);
 void DelayMs(uint32_t ms);
 void DelayNop(uint32_t count);



 
  


 



  


 
#line 73 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"


#line 84 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b.h"
















 







typedef struct {
	uint32_t signature[2];
	uint32_t image_size;							
	uint32_t image_addr;

	 
	uint32_t reserved[4];
} IMAGE_HEADER;

typedef struct {
	uint32_t OTA2_FlashAddr;
	uint32_t Valid_Image2;							
	uint32_t OTA1_ForceGpio;
	uint32_t Rsvd1;

	uint32_t RDP_FlashAddr;
	uint32_t RDP_Len;  
	uint32_t Rsvd2;
	uint32_t Rsvd3;

	uint16_t Spic_Mode;
	uint16_t Spic_Speed;
	uint16_t Flash_ID;
	uint16_t Flash_Size;
	uint16_t Flash_Status;
	uint16_t Rsvd4;
	uint32_t Rsvd5;

	 
	uint32_t UlogRate;
	uint32_t UlogDbgEn;
	uint32_t UlogRsvd2;
	uint32_t UlogRsvd3;
	
	 
	uint32_t JtagErrMap;
	uint8_t JtagKey[8];
	uint32_t JtagRsvd1;

	uint32_t RSIPMask1;
	uint32_t RSIPMask2;
	uint32_t RSIPRsvd1;
	uint32_t RSIPRsvd2;
	
} SYSTEM_DATA;










 

 
  void io_assert_failed(uint8_t* file, uint32_t line);




#line 14 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\ameba_soc.h"


 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\app\\monitor\\include\\rtl_consol_ram.h"







 




void ReRegisterPlatformLogUart(void);
void RtlConsolTaskRam(void *Data);
#line 19 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\ameba_soc.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_ota.h"















 








 









typedef struct {
	uint32_t	status_code;
	uint32_t	header_len;
	uint8_t		*body;
	uint32_t	body_len;
	uint8_t		*header_bak;
	uint32_t	parse_status;
} http_response_result_t;




 

 


 





 
typedef struct
{
	uint32_t	FwVer;	
 
	uint32_t	HdrNum;
 
}update_file_hdr;



 
typedef struct
{
	uint8_t	ImgId[4];	
 
	uint32_t	ImgHdrLen;	
 
	uint32_t	Checksum;	
 
	uint32_t  ImgLen;		 
	uint32_t  Offset;		 
	uint32_t  FlashOffset;     
}update_file_img_hdr;



 
typedef struct
{
	uint32_t ImgId;		 

	uint32_t	FlashAddr;	
 
	uint32_t	ImgOffset;	
 
	uint32_t	ImageLen;	 
}update_dw_info;



 
typedef struct
{
	update_file_hdr	FileHdr;			 
	update_file_img_hdr	FileImgHdr;	 
	update_file_img_hdr	FileRdpHdr;	 
	uint32_t RdpStatus;
}update_ota_target_hdr;



 
typedef struct
{
	uint8_t	ImgId[5];				 
}update_file_img_id;




 

 



  


  
#line 135 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\fwlib\\include\\rtl8710b_ota.h"






 



  




 



 

 


 
uint32_t OTA_Change(uint32_t OTAIdx);

void* ota_update_malloc(unsigned int size);
void ota_update_free(void *buf);


void ota_platform_reset(void);
int ota_write_ota2_addr(uint32_t ota_addr);
uint32_t ota_get_cur_index(void);

uint32_t recv_file_info_from_server(uint8_t * Recvbuf, uint32_t len, int socket);
uint32_t recv_ota_file_hdr(uint8_t * Recvbuf, uint32_t * len, update_ota_target_hdr * pOtaTgtHdr, int socket);
uint32_t get_ota_tartget_header(uint8_t* buf, uint32_t len, update_ota_target_hdr * pOtaTgtHdr, uint8_t * ImgId);
void erase_ota_target_flash(uint32_t addr, uint32_t len);
int32_t download_new_fw_from_server(uint32_t addr, int socket, update_ota_target_hdr * pOtaTgtHdr, uint8_t * signature);
uint32_t verify_ota_checksum(uint32_t addr, uint32_t len, uint8_t * signature, update_ota_target_hdr * pOtaTgtHdr);
uint32_t change_ota_signature(uint32_t addr, uint8_t * signature, uint32_t ota_target_index);
uint32_t get_ota_address(uint32_t ota_target_index, uint32_t * new_addr, update_ota_target_hdr * pOtaTgtHdr);






 



 



 


int parse_http_response(uint8_t *response, uint32_t response_len, http_response_result_t *result);
int update_ota_http_connect_server(int server_socket, char *host, int port);
int http_read_socket( int socket, uint8_t *recevie_buf, int buf_len );






 
int http_update_ota(char *host, int port, char *resource);



 
#line 20 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\ameba_soc.h"

#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_pmu.h"











#line 28 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_pmu.h"


typedef enum {
	PMU_OS					=0,
	PMU_WLAN_DEVICE		=1,
	PMU_LOGUART_DEVICE	=2,
	PMU_SDIO_DEVICE		=3,

	PMU_UART0_DEVICE		=4,
	PMU_UART1_DEVICE		=5,
	PMU_I2C0_DEVICE		=6,
	PMU_I2C1_DEVICE		=7,
	PMU_USOC_DEVICE		=8,
	PMU_DONGLE_DEVICE	=9,
	PMU_RTC_DEVICE		=10,
	PMU_CONSOL_DEVICE	=11,
	PMU_ADC_DEVICE	=12,
	PMU_WAKWLOCK_TIMEOUT=13,
	PMU_DEV_USER_BASE	=16,

	PMU_MAX				=31
} PMU_DEVICE;

enum SLEEP_TYPE {
	SLEEP_PG	= 0,
	SLEEP_CG	= 1,
};





typedef uint32_t (*PSM_HOOK_FUN)( unsigned int, void* param_ptr );










 
void pmu_acquire_wakelock(uint32_t nDeviceId);






 
void pmu_release_wakelock(uint32_t nDeviceId);




 
uint32_t pmu_get_wakelock_status(void);

#line 112 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_pmu.h"








 
uint32_t pmu_set_sysactive_time(uint32_t timeout_ms);

void pmu_add_wakeup_event(uint32_t event);
void pmu_del_wakeup_event(uint32_t event);

void pmu_register_sleep_callback(uint32_t nDeviceId, PSM_HOOK_FUN sleep_hook_fun, void* sleep_param_ptr, PSM_HOOK_FUN wakeup_hook_fun, void* wakeup_param_ptr);
void pmu_unregister_sleep_callback(uint32_t nDeviceId);

#line 136 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_pmu.h"

#line 23 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\ameba_soc.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\misc\\rtl8710b_freertos_pmu.h"








typedef struct
{
	uint32_t					nDeviceId;
	PSM_HOOK_FUN		sleep_hook_fun;
	void*				sleep_param_ptr;
	PSM_HOOK_FUN		wakeup_hook_fun;
	void*				wakeup_param_ptr;
}PSM_DD_HOOK_INFO;

typedef struct
{
	uint32_t					nDeviceId;
	PSM_HOOK_FUN		late_resume_hook_fun;
	void*				late_resume_param_ptr;
}PSM_DD_DELAY_HOOK_INFO;








 
uint32_t pmu_yield_os_check(void);
uint32_t pmu_sysactive_timer_init(void);
void pmu_register_delay_callback(uint32_t nDeviceId, PSM_HOOK_FUN late_resume_hook_fun, void* late_resume_param_ptr);
void pmu_unregister_delay_callback(uint32_t nDeviceId);
uint32_t pmu_exec_sleep_hook_funs(void);
void pmu_exec_wakeup_hook_funs(uint32_t nDeviceIdMax);
uint32_t pmu_set_sleep_type(uint32_t type);

 extern uint32_t LWIP_Get_Dynamic_Sleep_Interval();


extern uint32_t tickless_debug;
extern uint32_t tick_last_tcp;
#line 24 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\ameba_soc.h"






#line 36 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\cmsis\\device\\cmsis.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\cmsis\\device\\cmsis_nvic.h"





























 










#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\cmsis\\device\\cmsis.h"





























 

#line 42 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\cmsis\\device\\cmsis_nvic.h"





void NVIC_SetVector(IRQn_Type IRQn, uint32_t vector);
uint32_t NVIC_GetVector(IRQn_Type IRQn);





#line 37 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\cmsis\\device\\cmsis.h"

#line 20 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\mbed\\targets\\hal\\rtl8711b\\objects.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\mbed\\targets\\hal\\rtl8711b\\PortNames.h"














 







typedef enum {
	PortA = 0,
	PortB = 1,
} PortName;

#line 21 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\mbed\\targets\\hal\\rtl8711b\\objects.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\mbed\\targets\\hal\\rtl8711b\\PeripheralNames.h"














 









typedef enum {
	UART_0 = (int)((UART_TypeDef *) 0x40040000),
	UART_1 = (int)((UART_TypeDef *) 0x40040400),
	UART_2 = (int)((UART_TypeDef *) 0x40003000),
} UARTName;

typedef enum {
	ADC0_0 = 0,
	ADC0_1,
	ADC0_2,
	ADC0_3
} ADCName;

typedef enum {
	SPI_0 = (int)((SPI_TypeDef *) 0x40042000),
	SPI_1 = (int)((SPI_TypeDef *) 0x40042400),
} SPIName;

typedef enum {
	I2C_0 = (int)((I2C_TypeDef *) 0x40044000),
	I2C_1 = (int)((I2C_TypeDef *) 0x40044400),
} I2CName;

typedef enum {
	PWM_0 = 1,
	PWM_1,
	PWM_2,
	PWM_3,
	PWM_4,
	PWM_5
} PWMName;





#line 22 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\mbed\\targets\\hal\\rtl8711b\\objects.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\mbed\\targets\\hal\\rtl8711b\\PinNames.h"














typedef enum {
	PORT_A = 0,
	PORT_B = 1,
} GPIO_PORT;

typedef enum {
	PIN_INPUT=0,
	PIN_OUTPUT
} PinDirection;

 
typedef enum {
	PA_0  = (PORT_A<<5|0),
	PA_1  = (PORT_A<<5|1),
	PA_2  = (PORT_A<<5|2),
	PA_3  = (PORT_A<<5|3),
	PA_4  = (PORT_A<<5|4),
	PA_5  = (PORT_A<<5|5),
	PA_6  = (PORT_A<<5|6),
	PA_7  = (PORT_A<<5|7),
	PA_8  = (PORT_A<<5|8),
	PA_9  = (PORT_A<<5|9),
	PA_10  = (PORT_A<<5|10),
	PA_11  = (PORT_A<<5|11),
	PA_12  = (PORT_A<<5|12),
	PA_13  = (PORT_A<<5|13),
	PA_14  = (PORT_A<<5|14),
	PA_15  = (PORT_A<<5|15),
	PA_16  = (PORT_A<<5|16),
	PA_17  = (PORT_A<<5|17),
	PA_18  = (PORT_A<<5|18),
	PA_19  = (PORT_A<<5|19),
	PA_20  = (PORT_A<<5|20),
	PA_21  = (PORT_A<<5|21),
	PA_22  = (PORT_A<<5|22),
	PA_23  = (PORT_A<<5|23),
	PA_24  = (PORT_A<<5|24),
	PA_25  = (PORT_A<<5|25),
	PA_26  = (PORT_A<<5|26),
	PA_27  = (PORT_A<<5|27),
	PA_28  = (PORT_A<<5|28),
	PA_29  = (PORT_A<<5|29),
	PA_30  = (PORT_A<<5|30),
	PA_31  = (PORT_A<<5|31),
	
	PB_0  = (PORT_B<<5|0),
	PB_1  = (PORT_B<<5|1),
	PB_2  = (PORT_B<<5|2),
	PB_3  = (PORT_B<<5|3),
	PB_4  = (PORT_B<<5|4),
	PB_5  = (PORT_B<<5|5),
	PB_6  = (PORT_B<<5|6),
	PB_7  = (PORT_B<<5|7),
	PB_8  = (PORT_B<<5|8),

	VBAT_MEAS = (0x7<<5|2),
	AD_1 = PA_19, 
	AD_2 = VBAT_MEAS, 
	AD_3 = PA_20, 
	
	
	NC = (uint32_t)0xFFFFFFFF
} PinName;

typedef enum {
	PullNone  = 0, 
	PullUp    = 1,
	PullDown  = 2,
	OpenDrain = 3, 
	PullDefault = PullNone
} PinMode;







#line 23 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\common\\mbed\\targets\\hal\\rtl8711b\\objects.h"






typedef struct gpio_irq_s {
	PinName pin;
} gpio_irq_t;

typedef struct gpio_s {
	PinName pin;
} gpio_t;

struct port_s {
	PortName port;
	uint32_t mask;
};

struct serial_s {
	uint8_t uart_idx;
	uint32_t tx_len;
	uint32_t rx_len;
};

struct spi_s {
	 
	uint32_t spi_idx;

	 
	uint32_t irq_handler;
	uint32_t irq_id;
	uint32_t	state;
	uint8_t	sclk;
	uint32_t bus_tx_done_handler;
	uint32_t bus_tx_done_irq_id;
};

struct pwmout_s {
	uint8_t pwm_idx;
	uint32_t period;
	float pulse;
};

struct i2c_s {
	uint32_t i2c_idx;
	I2C_TypeDef * I2Cx;
};

struct flash_s {
	FLASH_InitTypeDef SpicInitPara;
};

struct analogin_s {
	uint8_t	adc_idx;
};

struct gtimer_s {
	void *handler;
	uint32_t hid;
	uint8_t timer_id;
	uint8_t is_periodcal;    
};

struct i2s_s {
	uint8_t i2s_idx;
	uint8_t sampling_rate;
	uint8_t channel_num;
	uint8_t word_length;
	uint8_t direction;
};

struct gdma_s {
	uint8_t index;
	uint8_t ch_num;
	IRQ_FUN user_cb;
	uint32_t user_cb_data;
};





#line 47 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\mbed\\targets\\hal\\rtl8711b\\device.h"

#line 30 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\mbed\\hal_ext\\flash_api.h"









 




typedef struct flash_s flash_t;






 
void flash_erase_sector(flash_t *obj, uint32_t address);






 
void flash_erase_block(flash_t * obj, uint32_t address);








 
int flash_read_word(flash_t *obj, uint32_t address, uint32_t * data);








 
int flash_write_word(flash_t *obj, uint32_t address, uint32_t data);









 
int flash_stream_read(flash_t *obj, uint32_t address, uint32_t len, uint8_t * data);








 
int flash_stream_write(flash_t *obj, uint32_t address, uint32_t len, uint8_t * data);








    
void flash_write_protect(flash_t *obj, uint32_t protect);





    
int flash_get_status(flash_t * obj);









   
int flash_set_status(flash_t * obj, uint32_t data);





 
void flash_reset_status(flash_t * obj);








 
int flash_burst_write(flash_t * obj, uint32_t address, uint32_t Length, uint8_t * data);








 
int flash_burst_read(flash_t * obj, uint32_t address, uint32_t Length, uint8_t * data);







 
int flash_set_extend_addr(flash_t * obj, uint32_t data);






 
int flash_get_extend_addr(flash_t * obj);







 
int flash_read_id(flash_t *obj, uint8_t *buf, uint8_t len);







 
int flash_read_unique_id(flash_t *obj, uint8_t *buf, uint8_t len);








 
void flash_set_lock_mode(uint32_t mode);






 
void flash_global_lock(void);






 
void flash_global_unlock(void);






 
void flash_individual_lock(uint32_t address);






 
void flash_individual_unlock(uint32_t address);







 
int flash_read_individual_lock_state(uint32_t address);










 
void flash_erase_chip(flash_t *obj);



 





#line 62 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\misc\\rtl8710b_ota.c"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\os_dep\\include\\device_lock.h"







 




typedef enum _RT_DEV_LOCK_E
{
	RT_DEV_LOCK_EFUSE = 0,
	RT_DEV_LOCK_FLASH = 1,
	RT_DEV_LOCK_CRYPTO = 2,
	RT_DEV_LOCK_PTA = 3,
	RT_DEV_LOCK_WLAN = 4,
	RT_DEV_LOCK_MAX = 5
}RT_DEV_LOCK_E;

void device_mutex_lock(RT_DEV_LOCK_E device);
void device_mutex_unlock(RT_DEV_LOCK_E device);

#line 63 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\misc\\rtl8710b_ota.c"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/netdb.h"



























 







#line 1 "F:\\IAR\\arm\\inc\\c\\stddef.h"
 
 
#line 39 "F:\\IAR\\arm\\inc\\c\\stddef.h"

#line 49 "F:\\IAR\\arm\\inc\\c\\stddef.h"





 
#line 37 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/netdb.h"








 













 












struct hostent {
    char  *h_name;       
    char **h_aliases;   
 
    int    h_addrtype;   
    int    h_length;     
    char **h_addr_list; 
 

};

struct addrinfo {
    int               ai_flags;       
    int               ai_family;      
    int               ai_socktype;    
    int               ai_protocol;    
    socklen_t         ai_addrlen;     
    struct sockaddr  *ai_addr;        
    char             *ai_canonname;   
    struct addrinfo  *ai_next;        
};



 
extern int h_errno;


struct hostent *lwip_gethostbyname(const char *name);
int lwip_gethostbyname_r(const char *name, struct hostent *ret, char *buf,
                size_t buflen, struct hostent **result, int *h_errnop);
void lwip_freeaddrinfo(struct addrinfo *ai);
int lwip_getaddrinfo(const char *nodename,
       const char *servname,
       const struct addrinfo *hints,
       struct addrinfo **res);

#line 117 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\network\\lwip\\lwip_v1.4.1\\src\\include\\lwip/netdb.h"







#line 65 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\misc\\rtl8710b_ota.c"









 
_Pragma( "location=\".img2_custom_signature\"")
const unsigned char cus_sig_demo[32] = "Customer Signature-modelxxx";











typedef struct
{
	uint32_t	ip_addr;
	uint16_t	port;
}update_cfg_local_t;
const update_file_img_id OtaImgId[2] = 
{
	{"OTA1"},
	{"OTA2"}
};

const uint8_t RdpImg[4] = "RDP";


#line 111 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\misc\\rtl8710b_ota.c"

sys_thread_t TaskOTA = 0;

void* ota_update_malloc(unsigned int size)
{
	return pvPortMalloc(size);
}


void ota_update_free(void *buf)
{
	vPortFree(buf);
}





 
void ota_platform_reset(void)
{
	

	 
	
	CPU_ClkSet(2);
	osDelay(100);


	 
	NVIC_SystemReset();	
}




 
int ota_write_ota2_addr(uint32_t ota_addr)
{
	uint32_t data;
	 
	data = ((uint32_t)(*((volatile uint32_t*)(0x08000000 + 0x9000))));
	rtl_printf("\n\r[%s] data 0x%x ota_addr 0x%x", __FUNCTION__, data, ota_addr);

	device_mutex_lock(RT_DEV_LOCK_FLASH);
	 
	if ((data != 0xFFFFFFFF) && (data != ota_addr)) {
		FLASH_EreaseDwordsXIP(0x9000, 1);
		FLASH_TxData12BXIP(0x9000, 4, (uint8_t*)&ota_addr);
	}
	device_mutex_unlock(RT_DEV_LOCK_FLASH);

	return 0;
}

 
uint32_t ota_get_cur_index(void)
{
	uint32_t check_addr = (uint32_t)cus_sig_demo;

	if (check_addr == 0x0800B000 + 0x20)
		return 0;
	else
		return 1;
}








 
uint32_t recv_file_info_from_server(uint8_t * Recvbuf, uint32_t len, int socket)
{
	int read_bytes = 0;
	uint32_t TempLen;
	uint8_t * buf;
	
	 
	buf = Recvbuf;
	TempLen = len;
	while(TempLen > 0) {
		read_bytes = lwip_read(socket,buf,TempLen);
		if(read_bytes < 0){
			rtl_printf("\n\r[%s] read socket failed\n", __FUNCTION__);
			goto error;
		}
		if(read_bytes == 0) {
			break;
		}
		TempLen -= read_bytes;
		buf += read_bytes;
	}

	return 1;
error:
	return 0;
}







 
uint32_t recv_ota_file_hdr(uint8_t * Recvbuf, uint32_t * len, update_ota_target_hdr * pOtaTgtHdr, int socket)
{
	int read_bytes = 0;
	uint32_t TempLen;
	uint8_t * buf;
	update_file_hdr * pOtaFileHdr;
	update_file_img_hdr * pOtaFileImgHdr;
	
	 
	buf = Recvbuf;
	TempLen = 16;
	while(TempLen > 0) {
		read_bytes = lwip_read(socket,buf,TempLen);
		if(read_bytes < 0){
			rtl_printf("\n\r[%s] read socket failed\n", __FUNCTION__);
			goto error;
		}
		if(read_bytes == 0) {
			break;
		}
		TempLen -= read_bytes;
		buf += read_bytes;
	}

	pOtaFileHdr = (update_file_hdr *)Recvbuf;
	pOtaFileImgHdr = (update_file_img_hdr *)(Recvbuf + 8);

	pOtaTgtHdr->FileHdr.FwVer = pOtaFileHdr->FwVer;
	pOtaTgtHdr->FileHdr.HdrNum = pOtaFileHdr->HdrNum;

	 
	buf = Recvbuf + 16;
	TempLen =  (pOtaFileHdr->HdrNum * pOtaFileImgHdr->ImgHdrLen) - 8;
	while(TempLen > 0) {
		read_bytes = lwip_read(socket,buf,TempLen);
		if(read_bytes < 0){
			rtl_printf("\n\r[%s] read socket failed\n", __FUNCTION__);
			goto error;
		}
		if(read_bytes == 0) {
			break;
		}
		TempLen -= read_bytes;
		buf += read_bytes;
	}

	*len = (pOtaFileHdr->HdrNum * pOtaFileImgHdr->ImgHdrLen) + 8;

	return 1;
error:
	return 0;
}







 
uint32_t get_ota_tartget_header(uint8_t* buf, uint32_t len, update_ota_target_hdr * pOtaTgtHdr, uint8_t * ImgId)
{
	update_file_img_hdr * ImgHdr;
	update_file_hdr * FileHdr;
	uint8_t * pTempAddr;
	uint32_t i;
	uint32_t ImageFg = 0;

	pOtaTgtHdr->RdpStatus = 0;

	 
	if((len < (sizeof(update_file_img_hdr) + 8)) || (!buf)) {
		goto error;
	}

	FileHdr = (update_file_hdr *)buf;
	ImgHdr = (update_file_img_hdr *)(buf + 8);
	pTempAddr = buf + 8;

	if(len < (FileHdr->HdrNum * ImgHdr->ImgHdrLen + 8)) {
		goto error;
	}

	 
	for(i = 0; i < FileHdr->HdrNum; i++) {
		pTempAddr = buf + 8 + ImgHdr->ImgHdrLen * i;

		 
		if(_strncmp(ImgId, pTempAddr, 4) == 0) {
			ImageFg = 1;
			_memcpy((uint8_t*)(&pOtaTgtHdr->FileImgHdr), pTempAddr, sizeof(update_file_img_hdr));
			continue;
		}

		 
		if(_strncmp(RdpImg, pTempAddr, 3) == 0) {
			do { if ((ConfigDebugErr & 0x40000000)) DiagPrintf("\r" "there exists RDP image in firmware file\n");}while(0);
			pOtaTgtHdr->RdpStatus = 1;
			ImageFg = 1;
			_memcpy((uint8_t*)(&pOtaTgtHdr->FileRdpHdr), pTempAddr, sizeof(update_file_img_hdr));
			continue;
		}
		
		if(i == FileHdr->HdrNum - 1) {
			if(ImageFg == 0) {
				rtl_printf("\n\r[%s] no matched image\n", __FUNCTION__);
				goto error;
			}
		}
	}

	return 1;
error:
	return 0;
}





 
void erase_ota_target_flash( uint32_t addr, uint32_t len)
{
	uint32_t NewImg2BlkSize;
	uint32_t i;
	flash_t * flash;
	 
	rtl_printf("\n\r[%s] NewImg2Len %d  ", __FUNCTION__, len);
	NewImg2BlkSize = ((len - 1)/4096) + 1;

	rtl_printf("\n\r[%s] NewImg2BlkSize %d  0x%8x", __FUNCTION__, NewImg2BlkSize, NewImg2BlkSize);
	device_mutex_lock(RT_DEV_LOCK_FLASH);
	for( i = 0; i < NewImg2BlkSize; i++)
		flash_erase_sector(flash, addr -0x08000000 + i * 4096);
	device_mutex_unlock(RT_DEV_LOCK_FLASH);
}







 
int32_t download_new_fw_from_server(uint32_t addr, int socket, update_ota_target_hdr * pOtaTgtHdr, uint8_t * signature)
{
	uint8_t * alloc;
	uint8_t * buf;
	int32_t size = 0;
	int read_bytes;
	int read_bytes_buf;
	uint32_t TempLen;
	flash_t flash;
	uint32_t ImageCnt;
	update_dw_info DownloadInfo[2];
	 
	uint32_t OtaFg = 0;
	uint32_t IncFg = 0;
	int32_t RemainBytes;
	uint32_t SigCnt = 0;
	uint32_t TempCnt = 0;	
	uint32_t i;
	int32_t OtaImgSize;

	 
	alloc = ota_update_malloc(512);

	buf = alloc;

	 
	_memset((uint8_t *)&DownloadInfo, 0, 2*sizeof(update_dw_info));

	 
	if(pOtaTgtHdr->RdpStatus == 1) {
		ImageCnt = 2;
		if(pOtaTgtHdr->FileImgHdr.Offset < pOtaTgtHdr->FileRdpHdr.Offset) {
			DownloadInfo[0].ImgId = 0;
			
 
			DownloadInfo[0].FlashAddr = addr -0x08000000 + 8;
			DownloadInfo[0].ImageLen = pOtaTgtHdr->FileImgHdr.ImgLen - 8; 
			DownloadInfo[0].ImgOffset = pOtaTgtHdr->FileImgHdr.Offset;
			DownloadInfo[1].ImgId = 1;
			DownloadInfo[1].FlashAddr = 0x080FF000 - 0x08000000;
			DownloadInfo[1].ImageLen = pOtaTgtHdr->FileRdpHdr.ImgLen;
			DownloadInfo[1].ImgOffset = pOtaTgtHdr->FileRdpHdr.Offset;
		} else {
			DownloadInfo[0].ImgId = 1;
			DownloadInfo[0].FlashAddr = 0x080FF000 - 0x08000000;
			DownloadInfo[0].ImageLen = pOtaTgtHdr->FileRdpHdr.ImgLen;
			DownloadInfo[0].ImgOffset = pOtaTgtHdr->FileRdpHdr.Offset;	
			DownloadInfo[1].ImgId = 0;
			
 
			DownloadInfo[1].FlashAddr = addr -0x08000000 + 8;
			DownloadInfo[1].ImageLen = pOtaTgtHdr->FileImgHdr.ImgLen - 8; 
			DownloadInfo[1].ImgOffset = pOtaTgtHdr->FileImgHdr.Offset;
		}
	}else {
			ImageCnt = 1;
			DownloadInfo[0].ImgId = 0;
			
 
			DownloadInfo[0].FlashAddr = addr -0x08000000 + 8;
			DownloadInfo[0].ImageLen = pOtaTgtHdr->FileImgHdr.ImgLen - 8; 
			DownloadInfo[0].ImgOffset = pOtaTgtHdr->FileImgHdr.Offset;		
	}

	 
	TempLen = (pOtaTgtHdr->FileHdr.HdrNum * pOtaTgtHdr->FileImgHdr.ImgHdrLen) + sizeof(update_file_hdr);

	rtl_printf("\n\r OTA Image Address = %x\n", addr);
	if(pOtaTgtHdr->RdpStatus == 1) {	
		rtl_printf("\n\r RDP Image Address = %x\n", 0x080FF000);
	}
	
	 
	for(i = 0; i < ImageCnt; i++) {
		 
		RemainBytes = DownloadInfo[i].ImageLen;
		 
		while(RemainBytes > 0){
			buf = alloc;
			if(IncFg == 1) {
				IncFg = 0;
				read_bytes = read_bytes_buf;
			} else {
				_memset(buf, 0, 512);
				read_bytes = lwip_read(socket,buf,512);
				if(read_bytes == 0){
					break; 
				}
				if(read_bytes < 0){
					OtaImgSize = -1;
					rtl_printf("\n\r[%s] Read socket failed", __FUNCTION__);
					goto exit;
				}
				read_bytes_buf = read_bytes;
				TempLen += read_bytes;
			}
			
			if(TempLen > DownloadInfo[i].ImgOffset) {
				if(!OtaFg) {   				 
					OtaFg = 1;
					TempCnt = TempLen -DownloadInfo[i].ImgOffset;
					if(DownloadInfo[i].ImgId == 0) {
						if(TempCnt < 8) {
							SigCnt = TempCnt;
						} else {
							SigCnt = 8;
						}

						_memcpy(signature, buf + read_bytes -TempCnt, SigCnt);

						if((SigCnt < 8) || (TempCnt -8 == 0)) {
							continue;
						}

						buf = buf + (read_bytes -TempCnt + 8);
						read_bytes = TempCnt -8;
					} else {
						buf = buf + read_bytes -TempCnt;
						read_bytes = TempCnt;
					}
				} else {					 
					if(DownloadInfo[i].ImgId == 0) {
						if(SigCnt < 8) {
							if(read_bytes < (8 -SigCnt)) {
								_memcpy(signature + SigCnt, buf, read_bytes);
								SigCnt += read_bytes;
								continue;
							} else {
								_memcpy(signature + SigCnt, buf, (8 -SigCnt));
								buf = buf + (8 - SigCnt);
								read_bytes -= (8 - SigCnt) ;
								SigCnt = 8;
								if(!read_bytes) {
									continue;
								}
							}
						}
					}
				}
				
				RemainBytes -= read_bytes;
				if(RemainBytes < 0) {
					read_bytes = read_bytes -(-RemainBytes);
				}
				device_mutex_lock(RT_DEV_LOCK_FLASH);
				if(flash_stream_write(&flash, DownloadInfo[i].FlashAddr + size, read_bytes, buf) < 0){
					rtl_printf("\n\r[%s] Write sector failed", __FUNCTION__);
					device_mutex_unlock(RT_DEV_LOCK_FLASH);
					goto exit;
				}
				device_mutex_unlock(RT_DEV_LOCK_FLASH);
				size += read_bytes;
			}

		}
		 
		if(DownloadInfo[i].ImgId == 0) {
			OtaImgSize = size;
		}
		 
		size = 0;
		OtaFg = 0;
		IncFg = 1;
	}

exit:

	ota_update_free(alloc);

	return OtaImgSize;
	
}







 
uint32_t verify_ota_checksum(uint32_t addr, uint32_t len, uint8_t * signature, update_ota_target_hdr * pOtaTgtHdr)
{
	uint32_t i;
	flash_t flash;
	uint32_t flash_checksum=0;
	uint32_t rdp_checksum=0;

	uint32_t read_custom_sig[8];

	uint32_t NewImg2BlkSize;
	NewImg2BlkSize = ((len - 1)/4096) + 1;
	uint8_t * pTempbuf;
	int k;
	int rlen;


	 
	OTF_Mask(1, (addr - 0x08000000), NewImg2BlkSize, 0);

	 
	_memcpy(read_custom_sig, (void const*)(addr + 0x20), 32);
	rtl_printf("\n\r[%s] read_custom_sig %s\n", __FUNCTION__ , (char*)read_custom_sig);
	Cache_Flush();

	if (prvStrCmp((const unsigned char *) (char*)read_custom_sig, (const unsigned char *) cus_sig_demo)) {
		goto error;
	}


	
 
	OTF_Mask(1, (addr - 0x08000000), NewImg2BlkSize, 1);

	pTempbuf = ota_update_malloc(512);

	 
	for(i=0;i<len;i+=512){
		rlen = (len-i)>512?512:(len-i);
		flash_stream_read(&flash, addr - 0x08000000+i+8, rlen, pTempbuf);
		Cache_Flush();
		for(k=0;k<rlen;k++)
			flash_checksum+=pTempbuf[k];
	}
	 
	for(i = 0; i < 8; i++) {
		flash_checksum += signature[i];
	}

	rtl_printf("\n\rUpdate file size = %d flash checksum 0x%8x attached checksum 0x%8x\n", len, flash_checksum, pOtaTgtHdr->FileImgHdr.Checksum);

	 
	if(pOtaTgtHdr->RdpStatus == 1) {
		for(i = 0; i < pOtaTgtHdr->FileRdpHdr.ImgLen; i++) {
			flash_stream_read(&flash, 0x080FF000 - 0x08000000+i, 1, pTempbuf);
			Cache_Flush();
			rdp_checksum += pTempbuf[0];
		}
	}

	OTF_Mask(1, (addr - 0x08000000), NewImg2BlkSize, 0);

	ota_update_free(pTempbuf);

	if(flash_checksum != pOtaTgtHdr->FileImgHdr.Checksum) {
		rtl_printf("\n\r OTA image checksum error!!!\n");
		goto error;
	} else {
		rtl_printf("\n\r OTA image checksum ok!!!\n");
	}

	if(pOtaTgtHdr->RdpStatus == 1) {
		if(rdp_checksum != pOtaTgtHdr->FileRdpHdr.Checksum) {
			rtl_printf("\n\r RDP image checksum error!!!\n");
			goto error;
		} else {
			rtl_printf("\n\r RDP image checksum ok!!!\n");
		}
	}

	return 1;
error:
	return 0;	
}




 
uint32_t change_ota_signature(uint32_t addr, uint8_t * signature, uint32_t ota_target_index)
{
	flash_t flash;
	device_mutex_lock(RT_DEV_LOCK_FLASH);
	 
	if(flash_stream_write(&flash, addr - 0x08000000, 8, signature) < 0){
		rtl_printf("\n\r[%s] Write sector failed", __FUNCTION__);
		device_mutex_unlock(RT_DEV_LOCK_FLASH);
		goto error;
	}
	OTA_Change(ota_target_index);
	device_mutex_unlock(RT_DEV_LOCK_FLASH);
	rtl_printf("\n\r[%s] Update OTA success!", __FUNCTION__);	
	return 1;
error:
	return 0;
}



 
uint32_t get_ota_address(uint32_t ota_target_index, uint32_t * new_addr, update_ota_target_hdr * pOtaTgtHdr)
{
	IMAGE_HEADER *OTA1Hdr = 0;
	uint32_t OTA1Len = 0;
	IMAGE_HEADER *FlashImgDataHdr = 0;
	uint32_t ota2_addr;

	ota2_addr = ((uint32_t)(*((volatile uint32_t*)(0x08000000 + 0x9000))));

	rtl_printf("ota2_addr = %x\n", ota2_addr);

	

 
	if(ota2_addr == 0xffffffff) {
		ota_write_ota2_addr((0x08080000));
		ota2_addr = ((uint32_t)(*((volatile uint32_t*)(0x08000000 + 0x9000))));
	}

	if((ota2_addr%4096) != 0) {
		rtl_printf("\n\r[%s] ota addr in sys data space not 4k aligned 0x%x", __FUNCTION__, ota2_addr);
		goto error;
	}

	if(ota_target_index == 1) {
		 
		OTA1Hdr = (IMAGE_HEADER *)(0x0800B000);
		OTA1Len = OTA1Hdr->image_size;	
		FlashImgDataHdr = (IMAGE_HEADER *)((uint32_t)OTA1Hdr + OTA1Len + 0x20);
		if ((ota2_addr < ((uint32_t)FlashImgDataHdr + FlashImgDataHdr->image_size + 0x20)) && ((ota2_addr & 0xfff) == 0)) {
			rtl_printf("\n\r[%s] illegal ota addr 0x%x", __FUNCTION__, ota2_addr);
			goto error;
		}
		*new_addr = ota2_addr;
	} else {
		*new_addr = 0x0800B000;
		 
		if(pOtaTgtHdr->FileImgHdr.ImgLen > (ota2_addr - *new_addr)) {
			rtl_printf("\n\r[%s] illegal new image length 0x%x", __FUNCTION__, pOtaTgtHdr->FileImgHdr.ImgLen);
			goto error;
		}
	}

	
 

		 
		if((*new_addr) != pOtaTgtHdr->FileImgHdr.FlashOffset){
			rtl_printf("\n\r[%s] pOtaTgtHdr->FileImgHdr.FlashOffset = %p\n", __FUNCTION__, pOtaTgtHdr->FileImgHdr.FlashOffset);
			 

				goto error;

		}


	if(*new_addr == 0xFFFFFFFF) {
		rtl_printf("\n\r[%s] update address is invalid \n", __FUNCTION__);
		goto error;	
	}

	return 1;
	
error:
	return 0;	
}











 
static void ota_update_single_img_local_task(void *param)
{
	int server_socket;
	struct sockaddr_in server_addr;
	unsigned char *buf, *alloc;
	int read_bytes = 0, size = 0;
	update_cfg_local_t *cfg = (update_cfg_local_t *)param;
	flash_t flash;
	uint32_t NewImg2Len = 0, NewImg2Addr = 0, file_info[3];
	int ret = -1 ;
	uint32_t ota_target_index = 1;
	update_ota_target_hdr OtaTargetHdr;
	char * pImgId;
	uint32_t RevHdrLen;
	uint8_t signature[9] = {0};

	_memset((uint8_t *)&OtaTargetHdr, 0, sizeof(update_ota_target_hdr));

	rtl_printf("\n\r[%s] Update task start\n", __FUNCTION__);
	alloc = ota_update_malloc(512);
	if(!alloc){
		rtl_printf("\n\r[%s] Alloc buffer failed", __FUNCTION__);
		goto update_ota_exit;
	}

	  
	server_socket = lwip_socket(2,1,0);
	if(server_socket < 0){
		rtl_printf("\n\r[%s] Create socket failed", __FUNCTION__);
		goto update_ota_exit;
	}
	server_addr.sin_family = 2;
	server_addr.sin_addr.s_addr = cfg->ip_addr;
	server_addr.sin_port = cfg->port;

	if(lwip_connect(server_socket,(struct sockaddr *)&server_addr,sizeof(server_addr)) == -1){
		rtl_printf("\n\r[%s] socket connect failed", __FUNCTION__);
		goto update_ota_exit;
	}
	
	(ConfigDebugInfo &= ~(0x00001000));
	 
	if (ota_get_cur_index() == 0) {
		ota_target_index = 1;



	} else {
		ota_target_index = 0;



	}




	 
	


 
	 
	_memset(file_info, 0, sizeof(file_info));
	if(!recv_file_info_from_server((uint8_t *)file_info, sizeof(file_info), server_socket)) {
		rtl_printf("\n\r[%s] receive file_info failed", __FUNCTION__);
		goto update_ota_exit;
	}

	rtl_printf("file_info[0] (checksum)= %p\n", file_info[0]);
	rtl_printf("file_info[1] (NULL)= %p\n", file_info[1]);
	rtl_printf("file_info[2] (file size)= %p\n", file_info[2]);

	 
	if(!recv_ota_file_hdr(alloc, &RevHdrLen, &OtaTargetHdr, server_socket)) {
		rtl_printf("\n\r[%s] rev firmware header failed", __FUNCTION__);
		goto update_ota_exit;
	}

	pImgId = (char *)(&OtaImgId[ota_target_index]);
	rtl_printf("\n\rTempBuf = %s\n",pImgId);

	 
	if(!get_ota_tartget_header(alloc, RevHdrLen, &OtaTargetHdr, pImgId)) {
		rtl_printf("\n\rget OTA header failed\n");
		goto update_ota_exit;
	}

	ota_update_free(alloc);

	 
	if(!get_ota_address(ota_target_index, &NewImg2Addr, &OtaTargetHdr)) {
		rtl_printf("\n\rget OTA address failed\n");
		goto update_ota_exit;
	}

	 
	NewImg2Len = OtaTargetHdr.FileImgHdr.ImgLen;

	 
	 
	erase_ota_target_flash(NewImg2Addr, NewImg2Len);
	 
	if(OtaTargetHdr.RdpStatus == 1) {
		device_mutex_lock(RT_DEV_LOCK_FLASH);
		flash_erase_sector(&flash, 0x080FF000 - 0x08000000);
		device_mutex_unlock(RT_DEV_LOCK_FLASH);
	}


	 
	size = download_new_fw_from_server(NewImg2Addr, server_socket, &OtaTargetHdr, signature);
	if((size < 0) || (size != (OtaTargetHdr.FileImgHdr.ImgLen - 8))) {
		rtl_printf("\n\rdownload new firmware failed\n");
		goto update_ota_exit;
	}

	rtl_printf("\nsize = %x\n", size);
	rtl_printf("\nbuffer signature is: = %s",signature);

	  
	if(verify_ota_checksum(NewImg2Addr, size, signature, &OtaTargetHdr)){
		if(!change_ota_signature(NewImg2Addr, signature, ota_target_index)) {
			rtl_printf("\n%s: change signature failed\n");
			goto update_ota_exit;
		}
		ret = 0;
	} else {
		
 

		device_mutex_lock(RT_DEV_LOCK_FLASH);
		flash_erase_sector(&flash, NewImg2Addr - 0x08000000);
		device_mutex_unlock(RT_DEV_LOCK_FLASH);

	}

update_ota_exit:
	if(alloc)
		ota_update_free(alloc);
	if(server_socket >= 0)
		lwip_close(server_socket);
	if(param)
		ota_update_free(param);
	
	TaskOTA = 0;	
	rtl_printf("\n\r[%s] Update task exit", __FUNCTION__);	
	 
	if(!ret){
		rtl_printf("\n\r[%s] Ready to reboot", __FUNCTION__);	
		ota_platform_reset();
	}
	vTaskDelete(0);	
	return;

}

#line 1113 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\misc\\rtl8710b_ota.c"




int update_ota_local(char *ip, int port)
{
	update_cfg_local_t *pUpdateCfg;
	
	if(TaskOTA){
		rtl_printf("\n\r[%s] Update task has created.", __FUNCTION__);
		return 0;
	}
	pUpdateCfg = ota_update_malloc(sizeof(update_cfg_local_t));
	if(pUpdateCfg == 0){
		rtl_printf("\n\r[%s] Alloc update cfg failed", __FUNCTION__);
		return -1;
	}
	pUpdateCfg->ip_addr = ipaddr_addr(ip);
	pUpdateCfg->port = lwip_ntohs(port);

	if(xTaskGenericCreate( ( ota_update_single_img_local_task ), ( "OTA_server" ), ( 1024 ), ( pUpdateCfg ), ( ( ( UBaseType_t ) 0U ) + 1 ), ( &TaskOTA ), ( 0 ), ( 0 ) ) != ( ( ( BaseType_t ) 1 ) )){
	  	ota_update_free(pUpdateCfg);
		rtl_printf("\n\r[%s] Create update task failed", __FUNCTION__);
	}
#line 1143 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\misc\\rtl8710b_ota.c"
	return 0;
}



#line 1184 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\misc\\rtl8710b_ota.c"


void cmd_update(int argc, char **argv)
{


	int port;
	if(argc != 3){
		rtl_printf("\n\r[%s] Usage: update IP PORT", __FUNCTION__);
		return;
	}
	port = prvAtoi(argv[2]);
	update_ota_local(argv[1], port);
#line 1205 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\misc\\rtl8710b_ota.c"
}

 
void cmd_ota_image(bool cmd)
{
	if (cmd == 1)
		OTA_Change(1);
	else
		OTA_Change(0);
}



uint32_t http_ota_target_index = 1;









 
int update_ota_http_connect_server(int server_socket, char *host, int port){
	struct sockaddr_in server_addr;
	struct hostent *server;
	
	server_socket = lwip_socket(2,1,0);
	if(server_socket < 0){
		rtl_printf("\n\r[%s] Create socket failed", __FUNCTION__);
		return -1;
	}
	rtl_printf("[%s] Create socket: %d success!\n", __FUNCTION__, server_socket);
	server = lwip_gethostbyname(host);
	if(server == 0){ 
		rtl_printf("[ERROR] Get host ip failed\n");
		return -1;
	}

	_memset(&server_addr, 0, sizeof(server_addr));
	server_addr.sin_family = 2;
	server_addr.sin_port = lwip_htons(port);
	_memcpy(&server_addr . sin_addr . s_addr, server->h_addr_list[0], server->h_length);

	if (lwip_connect(server_socket,(struct sockaddr *)&server_addr,sizeof(server_addr)) < 0){
		rtl_printf("\n\r[%s] Socket connect failed", __FUNCTION__);
		return -1;
	 }

	return server_socket;
}











 
int parse_http_response(uint8_t *response, uint32_t response_len, http_response_result_t *result) {
	uint32_t i, p, q, m;
	uint32_t header_end = 0;

	
	if(0 == result->parse_status){
		uint8_t status[4] = {0};
		i = p = q = m = 0;
		for (; i < response_len; ++i) {
			if (' ' == response[i]) {
				++m;
				if (1 == m) {
					p = i;
				} 
				else if (2 == m) {
					q = i;
					break;
				}
			}
		}
		if (!p || !q || q-p != 4) {
			return -1;
		}
		_memcpy(status, response +p+1, 3);
		result->status_code = prvAtoi((char const *)status);
		if(result->status_code == 200)
			result->parse_status = 1;
		else{
			rtl_printf("\n\r[%s] The http response status code is %d", __FUNCTION__, result->status_code);
			return -1;
		}
	}

	
	if(3 == result->parse_status){
		p = q = 0;
		for (i = 0; i < response_len; ++i) {
			if (response[i] == '\r' && response[i+1] == '\n' &&
				response[i+2] == '\r' && response[i+3] == '\n') {
				header_end = i+4;
				result->parse_status = 4;
				result->header_len = header_end;
				result->body = response + header_end;
				break;
			}
		}
		if (3 == result->parse_status) {
			result->header_bak = ota_update_malloc(32 + 1);
			_memset(result->header_bak, 0, prvStrLen((const unsigned char *) result->header_bak));
			_memcpy(result->header_bak, response + response_len - 32, 32);
		}
	}

	
	if(1 == result->parse_status){
		uint32_t content_length = 0;
		const uint8_t *content_length_buf1 = "CONTENT-LENGTH";
		const uint8_t *content_length_buf2 = "Content-Length";
		const uint32_t content_length_buf_len = prvStrLen((const unsigned char *) content_length_buf1);
		p = q = 0;
		
		for (i = 0; i < response_len; ++i) {
			if (response[i] == '\r' && response[i+1] == '\n') {
				q = i;
				if (!_memcmp(response +p, content_length_buf1, content_length_buf_len) ||
						!_memcmp(response +p, content_length_buf2, content_length_buf_len)) {
					int j1 = p+content_length_buf_len, j2 = q-1;
					while ( j1 < q && (*(response+j1) == ':' || *(response+j1) == ' ') ) ++j1;
					while ( j2 > j1 && *(response+j2) == ' ') --j2;
					uint8_t len_buf[12] = {0};
					_memcpy(len_buf, response +j1, j2-j1+1);
					result->body_len = prvAtoi((char const *)len_buf);
					result->parse_status = 2;
				}
				p = i+2;
			}
			if (response[i] == '\r' && response[i+1] == '\n' &&
					response[i+2] == '\r' && response[i+3] == '\n') {
				header_end = i+4;
				if(result->parse_status == 2){
					result->parse_status = 4;
					result->header_len = header_end;
					result->body = response + header_end;
				}
				else {
					rtl_printf("\n\r[%s] No Content-Length in header", __FUNCTION__);
					return -1;
				}
				break;
			}	
		}
		
		if (1 == result->parse_status) {
			result->header_bak = ota_update_malloc(32 + 1);
			_memset(result->header_bak, 0, prvStrLen((const unsigned char *) result->header_bak));
			_memcpy(result->header_bak, response + response_len - 32, 32);
		}
		else if (2 == result->parse_status) {
			result->parse_status = 3;
			result->header_bak = ota_update_malloc(32 + 1);
			_memset(result->header_bak, 0, prvStrLen((const unsigned char *) result->header_bak));
			_memcpy(result->header_bak, response + response_len - 32, 32);
		}
	}

	return result->parse_status;
}



 
uint32_t update_ota_prepare_addr(void)
{
	
	uint32_t NewImg2Addr = 0; 
	IMAGE_HEADER *FlashImgDataHdr = 0;
	IMAGE_HEADER *OTA1Hdr = 0;
	uint32_t OTA1Len = 0;
	uint32_t ota2_addr = 0x08080000;

	 



	ota2_addr = 0x08080000;

	
	if((ota2_addr%4096) != 0) {
		rtl_printf("\n[%s] ota addr in sys data space not 4k aligned 0x%x\n", __FUNCTION__, ota2_addr);
		return 0xFFFFFFFF;
	}
	if(ota2_addr <= 0x08080000) {
		ota2_addr = 0x08080000;
	}

	(ConfigDebugInfo &= ~(0x00001000));
	 
	if (ota_get_cur_index() == 0) {
		http_ota_target_index = 1;
		rtl_printf("OTA2 address space will be upgraded\n");
	} else {
		http_ota_target_index = 0;
		rtl_printf("OTA1 address space will be upgraded\n");
	}	

	if(http_ota_target_index == 1) {
		 
		OTA1Hdr = (IMAGE_HEADER *)(0x0800B000);
		OTA1Len = OTA1Hdr->image_size;	
		FlashImgDataHdr = (IMAGE_HEADER *)((uint32_t)OTA1Hdr + OTA1Len + 0x20);
		if ((ota2_addr > ((uint32_t)FlashImgDataHdr + FlashImgDataHdr->image_size + 0x20)) && ((ota2_addr & 0xfff) == 0)) {
			ota_write_ota2_addr(ota2_addr);
		} else {
			rtl_printf("\n[%s] illegal ota addr 0x%x\n", __FUNCTION__, ota2_addr);
			return 0xFFFFFFFF;
		}
		NewImg2Addr = ota2_addr;
	} else {
		NewImg2Addr = 0x0800B000;
	}
	
	return NewImg2Addr;
}

static int restore_ota_file_hdr(int writelen, int len, uint8_t *buf, int socketid)
{
	int TempLen = 0, read_bytes = 0;
	if (writelen < len) {
		TempLen = len - writelen;
		while(TempLen) {
			read_bytes = lwip_recv(socketid,buf,TempLen,0);
			if(read_bytes < 0){
				rtl_printf("[%s] read socket failed\n", __FUNCTION__);
				return -1;
			}
			if(read_bytes == 0) {
				writelen = len;
				break;
			}
			TempLen -= read_bytes;
			buf += read_bytes;
		}
		writelen = len;
	}
	writelen -= len;
	return writelen;
}











 
int http_read_socket( int socket, uint8_t *recevie_buf, int buf_len )
{
	int bytes_rcvd = -1; 
	if( socket < 0 ) {
		rtl_printf("[%s], socket is invalid\n", __FUNCTION__);
		return bytes_rcvd;
	}
	_memset(recevie_buf, 0, buf_len);  

	bytes_rcvd = lwip_recv(socket,recevie_buf,buf_len,0);
	if(bytes_rcvd <= 0) {
		rtl_printf("[%s], Close HTTP Socket[%d].\n", socket, __FUNCTION__);
		return -2;
	}
	return bytes_rcvd;
}

int http_update_ota(char *host, int port, char *resource)
{
	int server_socket = -1;
	unsigned char *buf, *alloc=0, *request=0;
	int read_bytes = 0, i = 0;
	uint32_t address;
	uint32_t NewImg2Len = 0, NewImg2Addr = 0;
	int ret = -1;
	http_response_result_t rsp_result = {0};

	int writelen = 0;
	int templen = 0;
	int RevHdrLen = 0;
	uint8_t *TempBuf = 0;
	uint32_t NewImg2BlkSize = 0;
	flash_t	flash;
	int ota_total_len = 0;
	static int RemainBytes = 0;
	uint32_t TempCnt = 0;
	static uint32_t SigCnt = 0;
	static unsigned long tick1, tick2;
	
	update_ota_target_hdr http_ota_target_hdr;
	uint8_t http_signature[9] = {0};
	int http_size = 0;
	
	alloc = (unsigned char *)ota_update_malloc(512);
	if(!alloc){
		rtl_printf("[%s] Alloc buffer failed\n", __FUNCTION__);
		goto update_ota_exit;
	}

	
	server_socket = update_ota_http_connect_server(server_socket, host, port);
	if(server_socket == -1){
		goto update_ota_exit;
	}

	NewImg2Addr = update_ota_prepare_addr();
	if(NewImg2Addr == -1){
		rtl_printf("[%s] illegal ota addr 0x%x\n", __FUNCTION__, NewImg2Addr);
		goto update_ota_exit;
	}
	
	 
	if(NewImg2Addr != 0xFFFFFFFF){
		uint32_t idx = 0;
		int data_len = 0;
		rtl_printf("\n\r");
		
		 
		request = (unsigned char *) ota_update_malloc(prvStrLen((const unsigned char *) "GET /") + prvStrLen((const unsigned char *) resource) + prvStrLen((const unsigned char *) " HTTP/1.1\r\nHost: ") 
			+ prvStrLen((const unsigned char *) host) + prvStrLen((const unsigned char *) "\r\n\r\n") + 1);
		rtl_sprintf(request, "GET /%s HTTP/1.1\r\nHost: %s\r\n\r\n", resource, host);

		ret = lwip_write(server_socket,request,prvStrLen((const unsigned char *) request));
		if(ret < 0){
			rtl_printf("[%s] Send HTTP request failed\n", __FUNCTION__);
			goto update_ota_exit;
		}

		while (3 >= rsp_result.parse_status){
			if(0 == rsp_result.parse_status){
				_memset(alloc, 0, 512);
				read_bytes = lwip_read(server_socket,alloc,512);
				if(read_bytes <= 0){
					rtl_printf("[%s] Read socket failed\n", __FUNCTION__);
					goto update_ota_exit;
				}
	
				idx = read_bytes;
				_memset(&rsp_result, 0, sizeof(rsp_result));
				if(parse_http_response(alloc, idx, &rsp_result) == -1){
					goto update_ota_exit;
				}
			} else if ((1 == rsp_result.parse_status) || (3 == rsp_result.parse_status)){
				_memset(alloc, 0, 512);
				_memcpy(alloc, rsp_result . header_bak, 32);
				ota_update_free(rsp_result.header_bak);
				rsp_result.header_bak = 0;
				read_bytes = lwip_read(server_socket,alloc + 32,(512 - 32));
				if(read_bytes <= 0){
					rtl_printf("[%s] Read socket failed\n", __FUNCTION__);
					goto update_ota_exit;
				}
	
				idx = read_bytes + 32;

				if (parse_http_response(alloc, read_bytes + 32, &rsp_result) == -1){
					goto update_ota_exit;
				}
			}
		}
		
		if (0 == rsp_result.body_len) {
			rtl_printf("[%s] New firmware size = 0 !\n", __FUNCTION__);
			goto update_ota_exit;
		} else {
			rtl_printf("[%s] Download new firmware begin, total size : %d\n", __FUNCTION__, rsp_result.body_len);
		}
		
		buf = alloc + idx;
		writelen = idx - rsp_result.header_len;
		writelen = restore_ota_file_hdr(writelen, 16, buf,  server_socket);

		if (writelen < 0) {
			rtl_printf("[%s] read socket failed\n", __FUNCTION__);
		   	goto update_ota_exit;
		}

		buf = alloc + rsp_result.header_len;
		_memcpy((uint8_t*)(&http_ota_target_hdr . FileHdr), buf, sizeof(http_ota_target_hdr . FileHdr));
		_memcpy((uint8_t*)(&http_ota_target_hdr . FileImgHdr), buf+8, 8);

		 
		buf = alloc + rsp_result.header_len + 16 + writelen;
		templen =  (http_ota_target_hdr.FileHdr.HdrNum * http_ota_target_hdr.FileImgHdr.ImgHdrLen) - 8;
		writelen = restore_ota_file_hdr(writelen, templen, buf,  server_socket);
		if (writelen < 0) {
			rtl_printf("[%s] read socket failed\n", __FUNCTION__);
		 	goto update_ota_exit;
		}
		 
		buf =  alloc + rsp_result.header_len;
		RevHdrLen = (http_ota_target_hdr.FileHdr.HdrNum * http_ota_target_hdr.FileImgHdr.ImgHdrLen) + 8;
		TempBuf = (uint8_t *)(&OtaImgId[http_ota_target_index]);
		rtl_printf("TempBuf = %s\n", TempBuf);
		if (!get_ota_tartget_header(buf, RevHdrLen, &http_ota_target_hdr, TempBuf)) {
			rtl_printf("Get OTA header failed\n");
			goto update_ota_exit;
		}

		 
		NewImg2Len = http_ota_target_hdr.FileImgHdr.ImgLen;
		NewImg2BlkSize = ((NewImg2Len - 1)/4096) + 1;
		
		 
		if(http_ota_target_index== 0) {
			if(http_ota_target_hdr.FileImgHdr.ImgLen > (0x08080000 - 0x0800B000)) {
				rtl_printf("\n\r[%s] illegal new image length 0x%x", __FUNCTION__, http_ota_target_hdr.FileImgHdr.ImgLen);
				goto update_ota_exit;
			}
		}

		 
		rtl_printf("[%s] NewImg2BlkSize %d\n", __FUNCTION__, NewImg2BlkSize);
		device_mutex_lock(RT_DEV_LOCK_FLASH);
		for( i = 0; i < NewImg2BlkSize; i++)
			flash_erase_sector(&flash, NewImg2Addr -0x08000000 + i * 4096);
		device_mutex_unlock(RT_DEV_LOCK_FLASH);

		
 
		OTF_Mask(1, (NewImg2Addr - 0x08000000), NewImg2BlkSize, 1);
		
 
		address = NewImg2Addr -0x08000000 + 8;
		templen = (http_ota_target_hdr.FileHdr.HdrNum * http_ota_target_hdr.FileImgHdr.ImgHdrLen) + sizeof(http_ota_target_hdr.FileHdr);
		RemainBytes = http_ota_target_hdr.FileImgHdr.ImgLen - 8;
		if (writelen > 0) {
			writelen = idx - rsp_result.header_len;
		} else {
			writelen = templen;
		}

		buf = alloc + rsp_result.header_len;
  		ota_total_len += writelen;
		 
		do {
			if (ota_total_len > http_ota_target_hdr.FileImgHdr.Offset) {
				tick1 = xTaskGetTickCount();
				 
				TempCnt = ota_total_len - http_ota_target_hdr.FileImgHdr.Offset;
				if (TempCnt < 8) {
					SigCnt = TempCnt;
				} else {
					SigCnt = 8;
				}
				_memcpy(http_signature, buf + writelen - TempCnt, SigCnt);
				if((SigCnt < 8) || (TempCnt -8 == 0)) {
					while (SigCnt < 8) {
						writelen = http_read_socket(server_socket, alloc, 8 -SigCnt);
					        if(writelen < 0 ) {
					          	rtl_printf("[%s], socket recv ota file fail!recived: %d\n", __func__, ota_total_len);
							goto update_ota_exit;
					        }
						_memcpy(http_signature + SigCnt, alloc, writelen);
						SigCnt += writelen;
					};
					ota_total_len += (8 - TempCnt);
				} else {
					device_mutex_lock(RT_DEV_LOCK_FLASH);
					if(flash_stream_write(&flash, address + http_size, TempCnt -8, (buf + writelen-TempCnt + 8) ) < 0){
						rtl_printf("[%s] Write sector failed\n", __FUNCTION__);
						device_mutex_unlock(RT_DEV_LOCK_FLASH);
						goto update_ota_exit;
					}
					device_mutex_unlock(RT_DEV_LOCK_FLASH);
					http_size += TempCnt -8;
					RemainBytes -= http_size; 
				}
				rtl_printf("signature: %s, RemainBytes: %d, flash address: %d, http_size: %d\n", http_signature, RemainBytes, address, http_size);
				 
				while (RemainBytes) {
					writelen = http_read_socket(server_socket, alloc, 512);
				        if(writelen < 0 ) {
						rtl_printf("[%s], socket recv ota file fail!recived: %d\n", __func__, ota_total_len);
						goto update_ota_exit;
				        }
					ota_total_len += writelen;
					RemainBytes -= writelen;
					if (RemainBytes <= 0) {
						writelen = writelen - (-RemainBytes);
						RemainBytes = 0;
					}
					device_mutex_lock(RT_DEV_LOCK_FLASH);
					if (flash_stream_write(&flash, address + http_size, writelen, alloc) < 0){
						rtl_printf("[%s] Write sector failed\n", __FUNCTION__);
						device_mutex_unlock(RT_DEV_LOCK_FLASH);
						goto update_ota_exit;
					}
					device_mutex_unlock(RT_DEV_LOCK_FLASH);
					http_size += writelen;
					tick2 = xTaskGetTickCount();
					if (tick2 - tick1 > 1000) {
						rtl_printf("Download OTA file: %d Bytes, RemainBytes = %d Bytes\n", http_size, RemainBytes);
						tick1 = tick2;
					}
				}
			}

			if (RemainBytes) {
				writelen = http_read_socket(server_socket, alloc, 512);
					if(writelen < 0 ) {
						rtl_printf("[%s], socket recv ota file fail!recived:0x%x\n", __func__, ota_total_len);
						goto update_ota_exit;
					}
				ota_total_len += writelen;
				buf = alloc;
			}
		} while( RemainBytes );

		rtl_printf("[%s] Download new firmware %d bytes completed\n", __FUNCTION__, idx);
		rtl_printf("signature: %s, size = %d, OtaTargetHdr.FileImgHdr.ImgLen = %d\n", http_signature, http_size, http_ota_target_hdr.FileImgHdr.ImgLen);
		  
		if(verify_ota_checksum(NewImg2Addr, http_size, http_signature, &http_ota_target_hdr)){
			if(!change_ota_signature(NewImg2Addr, http_signature, http_ota_target_index)) {
				ret = -1;
				rtl_printf("\n[%s], change signature failed\n", __FUNCTION__);
			}
			rtl_printf("\n\r[%s] Update OTA success!", __FUNCTION__);
			ret = 0;
		} else {
		 
			device_mutex_lock(RT_DEV_LOCK_FLASH);
			flash_erase_sector(&flash, NewImg2Addr - 0x08000000);
			device_mutex_unlock(RT_DEV_LOCK_FLASH);
			rtl_printf("\n\r[%s] The checksume is wrong!\n\r", __FUNCTION__);
			ret = -1;
			goto update_ota_exit;
		}
	}
update_ota_exit:
	if(alloc)
		ota_update_free(alloc);
	if(request)
		ota_update_free(request);
	if(server_socket >= 0)
		lwip_close(server_socket);
	return ret;
}




