#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_service.c"
 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"































































 






 
#line 1 "F:\\IAR\\arm\\inc\\c\\stddef.h"
 
 




  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"















 

#line 103 "F:\\IAR\\arm\\inc\\c\\ycheck.h"









#line 11 "F:\\IAR\\arm\\inc\\c\\stddef.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\yvals.h"
 
 





  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 12 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 









  


                 




















 


   
#line 59 "F:\\IAR\\arm\\inc\\c\\yvals.h"





#line 70 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 
#line 1 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"



























 





  #pragma system_include


 
#line 1 "F:\\IAR\\arm\\INC\\c\\DLib_Config_Normal.h"
 
 





  #pragma system_include


 

#line 40 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"
   
#line 47 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"

 
#line 1 "F:\\IAR\\arm\\inc\\c\\DLib_Product.h"




   #pragma system_include







 




 


 



 



 


 




 
#line 45 "F:\\IAR\\arm\\inc\\c\\DLib_Product.h"

 


 


 






 




 


 


 
#line 99 "F:\\IAR\\arm\\inc\\c\\DLib_Product.h"







#line 51 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"











 












 
























 













 























































































































 






 














 
























 


















 
















 








 















 

#line 351 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"













 













 












 














 












 












 












 












 

















 

















 






















 















 








 














 

#line 566 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"












 












 












 












 












 












 












 












 












 










 







 












 







 








 



















































 
















 




#line 812 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"





 

#line 826 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"


   
#line 836 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"

#line 844 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"
  







 









 








 







 






 

#line 899 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"




 







 






 















 

   
#line 943 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"









 

  #pragma language = save 
  #pragma language = extended





  #pragma language = restore










 








 







 
#line 997 "F:\\IAR\\arm\\inc\\c\\DLib_Defaults.h"





 







#line 73 "F:\\IAR\\arm\\inc\\c\\yvals.h"











                 




















 
#line 147 "F:\\IAR\\arm\\inc\\c\\yvals.h"





                 


 




 
 
#line 170 "F:\\IAR\\arm\\inc\\c\\yvals.h"

 




 






 






 
#line 233 "F:\\IAR\\arm\\inc\\c\\yvals.h"











                 
#line 292 "F:\\IAR\\arm\\inc\\c\\yvals.h"









#line 308 "F:\\IAR\\arm\\inc\\c\\yvals.h"








#line 1 "F:\\IAR\\arm\\inc\\c\\xencoding_limits.h"
 
 





  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 12 "F:\\IAR\\arm\\inc\\c\\xencoding_limits.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\yvals.h"
 
 

#line 711 "F:\\IAR\\arm\\inc\\c\\yvals.h"




 
#line 13 "F:\\IAR\\arm\\inc\\c\\xencoding_limits.h"

                                 


#line 24 "F:\\IAR\\arm\\inc\\c\\xencoding_limits.h"




#line 42 "F:\\IAR\\arm\\inc\\c\\xencoding_limits.h"

                                 














#line 317 "F:\\IAR\\arm\\inc\\c\\yvals.h"



                 

                 
#line 335 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 
#line 360 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 
                 




#line 382 "F:\\IAR\\arm\\inc\\c\\yvals.h"


                 

                                 







  #pragma language=save
  #pragma language=extended
  typedef long long _Longlong;
  typedef unsigned long long _ULonglong;
  #pragma language=restore
#line 405 "F:\\IAR\\arm\\inc\\c\\yvals.h"






  typedef unsigned short int _Wchart;
  typedef unsigned short int _Wintt;


#line 424 "F:\\IAR\\arm\\inc\\c\\yvals.h"

#line 432 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 


typedef signed int  _Ptrdifft;
typedef unsigned int     _Sizet;

 


                 







 
  typedef struct __va_list
  {
    char  *_Ap;
  } __va_list;

  typedef __va_list __Va_list;





__intrinsic __nounwind void __iar_Atexit(void (*)(void));



  typedef struct
  {        
    unsigned int _Wchar;
    unsigned int _State;
  } _Mbstatet;
#line 481 "F:\\IAR\\arm\\inc\\c\\yvals.h"










typedef struct
{        

  _Longlong _Off;     



  _Mbstatet _Wstate;
} _Fpost;







                 

#line 1 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"













 





  #pragma system_include






 






















































































 

 



#line 157 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"

  
 

   





  


#line 176 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"





#line 187 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"





  #pragma language=save 
  #pragma language=extended
  __intrinsic __nounwind void __iar_dlib_perthread_initialize(void  *);
  __intrinsic __nounwind void  *__iar_dlib_perthread_allocate(void);
  __intrinsic __nounwind void __iar_dlib_perthread_destroy(void);
  __intrinsic __nounwind void __iar_dlib_perthread_deallocate(void  *);









  #pragma segment = "__DLIB_PERTHREAD" 
  #pragma segment = "__DLIB_PERTHREAD_init" 


























#line 242 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"

   
  void  *__iar_dlib_perthread_access(void  *);
  #pragma language=restore



























     
  









   






  





  
  typedef void *__iar_Rmtx;
  

  
  __intrinsic __nounwind void __iar_system_Mtxinit(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_system_Mtxdst(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_system_Mtxlock(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_system_Mtxunlock(__iar_Rmtx *m);

  __intrinsic __nounwind void __iar_file_Mtxinit(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_file_Mtxdst(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_file_Mtxlock(__iar_Rmtx *m);
  __intrinsic __nounwind void __iar_file_Mtxunlock(__iar_Rmtx *m);

  
 
  __intrinsic __nounwind void __iar_clearlocks(void);


#line 323 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"

  





  

#line 341 "F:\\IAR\\arm\\inc\\c\\DLib_Threads.h"

  typedef unsigned _Once_t;



  













#line 510 "F:\\IAR\\arm\\inc\\c\\yvals.h"

#line 520 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 
#line 528 "F:\\IAR\\arm\\inc\\c\\yvals.h"


                 

  
  
    
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock_Locale(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock_Malloc(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock_Stream(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock_Debug(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock_StaticGuard(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Locksyslock(unsigned int);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock_Locale(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock_Malloc(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock_Stream(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock_Debug(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock_StaticGuard(void);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlocksyslock(unsigned int);

  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Initdynamicfilelock(__iar_Rmtx *);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Dstdynamicfilelock(__iar_Rmtx *);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Lockdynamicfilelock(__iar_Rmtx *);
  _Pragma("object_attribute = __weak") __intrinsic __nounwind void __iar_Unlockdynamicfilelock(__iar_Rmtx *);
  
  
#line 568 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 
#line 576 "F:\\IAR\\arm\\inc\\c\\yvals.h"

#line 694 "F:\\IAR\\arm\\inc\\c\\yvals.h"

                 





#line 709 "F:\\IAR\\arm\\inc\\c\\yvals.h"






 
#line 12 "F:\\IAR\\arm\\inc\\c\\stddef.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\ysizet.h"
 
 





  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 12 "F:\\IAR\\arm\\inc\\c\\ysizet.h"



                 




typedef _Sizet size_t;




typedef unsigned int __data_size_t;











#line 13 "F:\\IAR\\arm\\inc\\c\\stddef.h"



                 








                 




  typedef _Ptrdifft ptrdiff_t;




  typedef _Wchart wchar_t;




#line 49 "F:\\IAR\\arm\\inc\\c\\stddef.h"





 
#line 73 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"













 
#line 1 "F:\\IAR\\arm\\inc\\c\\stdint.h"
 
 




  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 11 "F:\\IAR\\arm\\inc\\c\\stdint.h"



 

  typedef signed char   int8_t;
  typedef unsigned char uint8_t;



  typedef signed short int   int16_t;
  typedef unsigned short int uint16_t;



  typedef signed int   int32_t;
  typedef unsigned int uint32_t;



  #pragma language=save
  #pragma language=extended
  typedef signed long long int   int64_t;
  typedef unsigned long long int uint64_t;
  #pragma language=restore



 
typedef signed char   int_least8_t;
typedef unsigned char uint_least8_t;

typedef signed short int   int_least16_t;
typedef unsigned short int uint_least16_t;

typedef signed int   int_least32_t;
typedef unsigned int uint_least32_t;

 

  #pragma language=save
  #pragma language=extended
  typedef signed long long int int_least64_t;
  #pragma language=restore


  #pragma language=save
  #pragma language=extended
  typedef unsigned long long int uint_least64_t;
  #pragma language=restore




 
typedef signed int   int_fast8_t;
typedef unsigned int uint_fast8_t;

typedef signed int   int_fast16_t;
typedef unsigned int uint_fast16_t;

typedef signed int   int_fast32_t;
typedef unsigned int uint_fast32_t;


  #pragma language=save
  #pragma language=extended
  typedef signed long long int int_fast64_t;
  #pragma language=restore


  #pragma language=save
  #pragma language=extended
  typedef unsigned long long int uint_fast64_t;
  #pragma language=restore


 
#pragma language=save
#pragma language=extended
typedef signed long long int   intmax_t;
typedef unsigned long long int uintmax_t;
#pragma language=restore


 
typedef signed long int   intptr_t;
typedef unsigned long int uintptr_t;

 



typedef int __data_intptr_t; typedef unsigned int __data_uintptr_t;


 






























































































 

































#line 258 "F:\\IAR\\arm\\inc\\c\\stdint.h"




 
#line 88 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"





 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"


































































 

#line 1 "F:\\IAR\\arm\\inc\\c\\stdint.h"
 
 
#line 235 "F:\\IAR\\arm\\inc\\c\\stdint.h"

#line 258 "F:\\IAR\\arm\\inc\\c\\stdint.h"




 
#line 73 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"
extern uint32_t SystemCoreClock; 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"


 




 



 








 
#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"



 
#line 42 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"



 
#line 52 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"



 
#line 62 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\inc\\platform_autoconf.h"



 





 





 





 





 





 





 





 





 





 





 




 





 







 





 






 





 




 




 




 







 




 




 




 






 




 




 




 




 








 
#line 76 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"











 

#line 108 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"






#line 127 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"







extern void freertos_pre_sleep_processing(unsigned int *expected_idle_time);
extern void freertos_post_sleep_processing(unsigned int *expected_idle_time);
extern int  freertos_ready_to_sleep();

 


 


 




 






                                                        



 





 
#line 176 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"

 
#line 184 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\FreeRTOSConfig.h"



 





 




 


 





#line 95 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"

 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\projdefs.h"































































 







 
typedef void (*TaskFunction_t)( void * );

 










 








#line 98 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"

 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\portable.h"































































 



 







 










































































































































































#line 254 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\portable.h"

#line 262 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\portable.h"







#line 276 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\portable.h"











































 
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\portable\\IAR\\ARM_CM4F\\portmacro.h"































































 

















 

 
#line 92 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\portable\\IAR\\ARM_CM4F\\portmacro.h"

typedef uint32_t StackType_t;
typedef long BaseType_t;
typedef unsigned long UBaseType_t;





	typedef uint32_t TickType_t;


 

 



 

 
extern void vPortYield( void );





 

 






	 




	 



	 

#line 1 "F:\\IAR\\arm\\inc\\c\\intrinsics.h"








 




#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 15 "F:\\IAR\\arm\\inc\\c\\intrinsics.h"


  #pragma system_include




 





 









#pragma language=save
#pragma language=extended

__intrinsic __nounwind void    __no_operation(void);

__intrinsic __nounwind void    __disable_interrupt(void);
__intrinsic __nounwind void    __enable_interrupt(void);

typedef unsigned long __istate_t;

__intrinsic __nounwind __istate_t __get_interrupt_state(void);
__intrinsic __nounwind void __set_interrupt_state(__istate_t);



 
__intrinsic __nounwind unsigned long __get_PSR( void );
__intrinsic __nounwind unsigned long __get_IPSR( void );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __get_MSP( void );
__intrinsic __nounwind void          __set_MSP( unsigned long );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __get_PSP( void );
__intrinsic __nounwind void          __set_PSP( unsigned long );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __get_PRIMASK( void );
__intrinsic __nounwind void          __set_PRIMASK( unsigned long );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __get_CONTROL( void );
__intrinsic __nounwind void          __set_CONTROL( unsigned long );



 
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __get_FAULTMASK( void );
__intrinsic __nounwind void          __set_FAULTMASK(unsigned long);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __get_BASEPRI( void );
__intrinsic __nounwind void          __set_BASEPRI( unsigned long );

#line 80 "F:\\IAR\\arm\\inc\\c\\intrinsics.h"

__intrinsic __nounwind void __disable_fiq(void);
__intrinsic __nounwind void __enable_fiq(void);


 

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SWP( unsigned long, volatile unsigned long * );
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned char __SWPB( unsigned char, volatile unsigned char * );

typedef unsigned long __ul;





 
__intrinsic __nounwind void          __MCR( unsigned __constrange(0,15) coproc, unsigned __constrange(0,8) opcode_1, __ul src,
                                 unsigned __constrange(0,15) CRn, unsigned __constrange(0,15) CRm, unsigned __constrange(0,8) opcode_2 );
__intrinsic __nounwind unsigned long __MRC( unsigned __constrange(0,15) coproc, unsigned __constrange(0,8) opcode_1,
                                 unsigned __constrange(0,15) CRn, unsigned __constrange(0,15) CRm, unsigned __constrange(0,8) opcode_2 );
__intrinsic __nounwind void          __MCR2( unsigned __constrange(0,15) coproc, unsigned __constrange(0,8) opcode_1, __ul src,
                                  unsigned __constrange(0,15) CRn, unsigned __constrange(0,15) CRm, unsigned __constrange(0,8) opcode_2 );
__intrinsic __nounwind unsigned long __MRC2( unsigned __constrange(0,15) coproc, unsigned __constrange(0,8) opcode_1,
                                  unsigned __constrange(0,15) CRn, unsigned __constrange(0,15) CRm, unsigned __constrange(0,8) opcode_2 );

 
__intrinsic __nounwind void __LDC( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src);
__intrinsic __nounwind void __LDCL( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src);
__intrinsic __nounwind void __LDC2( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src);
__intrinsic __nounwind void __LDC2L( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src);

 
__intrinsic __nounwind void __STC( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst);
__intrinsic __nounwind void __STCL( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst);
__intrinsic __nounwind void __STC2( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst);
__intrinsic __nounwind void __STC2L( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst);

 
__intrinsic __nounwind void __LDC_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src,
                              unsigned __constrange(0,255) option);

__intrinsic __nounwind void __LDCL_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src,
                               unsigned __constrange(0,255) option);

__intrinsic __nounwind void __LDC2_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src,
                               unsigned __constrange(0,255) option);

__intrinsic __nounwind void __LDC2L_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul const *src,
                                unsigned __constrange(0,255) option);

 
__intrinsic __nounwind void __STC_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst,
                              unsigned __constrange(0,255) option);

__intrinsic __nounwind void __STCL_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst,
                               unsigned __constrange(0,255) option);

__intrinsic __nounwind void __STC2_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst,
                               unsigned __constrange(0,255) option);

__intrinsic __nounwind void __STC2L_noidx( unsigned __constrange(0,15) coproc, unsigned __constrange(0,15) CRn, volatile __ul *dst,
                                unsigned __constrange(0,255) option);


 
__intrinsic __nounwind unsigned long __get_APSR( void );
__intrinsic __nounwind void          __set_APSR( unsigned long );






 
__intrinsic __nounwind unsigned long __get_FPSCR( void );
__intrinsic __nounwind void __set_FPSCR( unsigned long );

 
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned char __CLZ( unsigned long );

 

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind signed long __QADD( signed long, signed long );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind signed long __QDADD( signed long, signed long );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind signed long __QSUB( signed long, signed long );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind signed long __QDSUB( signed long, signed long );

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind signed long __QDOUBLE( signed long );

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind int         __QFlag( void );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind void __reset_Q_flag( void );


_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind int         __QCFlag( void );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind void __reset_QC_flag( void );

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind signed long __SMUL( signed short, signed short );

 
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __REV( unsigned long );
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind signed long __REVSH( short );

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __REV16( unsigned long );
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __RBIT( unsigned long );

_Pragma("function_effects = no_state, no_write(1), always_returns") __intrinsic __nounwind unsigned char  __LDREXB( volatile unsigned char const * );
_Pragma("function_effects = no_state, no_write(1), always_returns") __intrinsic __nounwind unsigned short __LDREXH( volatile unsigned short const * );
_Pragma("function_effects = no_state, no_write(1), always_returns") __intrinsic __nounwind unsigned long  __LDREX ( volatile unsigned long const * );
_Pragma("function_effects = no_state, no_write(1), always_returns") __intrinsic __nounwind unsigned long long __LDREXD( volatile unsigned long long const * );

_Pragma("function_effects = no_state, no_read(2), always_returns") __intrinsic __nounwind unsigned long  __STREXB( unsigned char, volatile unsigned char * );
_Pragma("function_effects = no_state, no_read(2), always_returns") __intrinsic __nounwind unsigned long  __STREXH( unsigned short, volatile unsigned short * );
_Pragma("function_effects = no_state, no_read(2), always_returns") __intrinsic __nounwind unsigned long  __STREX ( unsigned long, volatile unsigned long * );
_Pragma("function_effects = no_state, no_read(2), always_returns") __intrinsic __nounwind unsigned long  __STREXD( unsigned long long, volatile unsigned long long * );

__intrinsic __nounwind void __CLREX( void );

__intrinsic __nounwind void __SEV( void );
__intrinsic __nounwind void __WFE( void );
__intrinsic __nounwind void __WFI( void );
__intrinsic __nounwind void __YIELD( void );

__intrinsic __nounwind void __PLI( volatile void const * );
__intrinsic __nounwind void __PLD( volatile void const * );
__intrinsic __nounwind void __PLDW( volatile void const * );

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind   signed long __SSAT     (unsigned long val,
                                      unsigned int __constrange( 1, 32 ) sat );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __USAT     (unsigned long val,
                                      unsigned int __constrange( 0, 31 ) sat );




 
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SEL( unsigned long op1, unsigned long op2 );

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SADD8    (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SADD16   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SSUB8    (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SSUB16   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SADDSUBX (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SSUBADDX (unsigned long pair1, unsigned long pair2);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHADD8   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHADD16  (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHSUB8   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHSUB16  (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHADDSUBX(unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHSUBADDX(unsigned long pair1, unsigned long pair2);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QADD8    (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QADD16   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QSUB8    (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QSUB16   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QADDSUBX (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QSUBADDX (unsigned long pair1, unsigned long pair2);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UADD8    (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UADD16   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __USUB8    (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __USUB16   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UADDSUBX (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __USUBADDX (unsigned long pair1, unsigned long pair2);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHADD8   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHADD16  (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHSUB8   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHSUB16  (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHADDSUBX(unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHSUBADDX(unsigned long pair1, unsigned long pair2);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQADD8   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQADD16  (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQSUB8   (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQSUB16  (unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQADDSUBX(unsigned long pair1, unsigned long pair2);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQSUBADDX(unsigned long pair1, unsigned long pair2);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __USAD8(unsigned long x, unsigned long y );
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __USADA8(unsigned long x, unsigned long y,
                                   unsigned long acc );

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SSAT16   (unsigned long pair,
                                      unsigned int __constrange( 1, 16 ) sat );
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __USAT16   (unsigned long pair,
                                      unsigned int __constrange( 0, 15 ) sat );

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMUAD (unsigned long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMUSD (unsigned long x, unsigned long y);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMUADX(unsigned long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMUSDX(unsigned long x, unsigned long y);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLAD (unsigned long x, unsigned long y, long sum);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLSD (unsigned long x, unsigned long y, long sum);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLADX(unsigned long x, unsigned long y, long sum);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLSDX(unsigned long x, unsigned long y, long sum);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLALD (unsigned long pair1,
                                 unsigned long pair2,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLALDX(unsigned long pair1,
                                 unsigned long pair2,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLSLD (unsigned long pair1,
                                 unsigned long pair2,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLSLDX(unsigned long pair1,
                                 unsigned long pair2,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __PKHBT(unsigned long x,
                                  unsigned long y,
                                  unsigned __constrange(0,31) count);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __PKHTB(unsigned long x,
                                  unsigned long y,
                                  unsigned __constrange(0,32) count);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLABB(unsigned long x, unsigned long y, long acc);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLABT(unsigned long x, unsigned long y, long acc);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLATB(unsigned long x, unsigned long y, long acc);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLATT(unsigned long x, unsigned long y, long acc);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLAWB(long x, unsigned long y, long acc);
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind long __SMLAWT(long x, unsigned long y, long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMMLA (long x, long y, long acc);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMMLAR(long x, long y, long acc);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMMLS (long x, long y, long acc);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMMLSR(long x, long y, long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMMUL (long x, long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMMULR(long x, long y);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMULBB(unsigned long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMULBT(unsigned long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMULTB(unsigned long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMULTT(unsigned long x, unsigned long y);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMULWB(long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SMULWT(long x, unsigned long y);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SXTAB (long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long __SXTAH (long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UXTAB (unsigned long x, unsigned long y);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UXTAH (unsigned long x, unsigned long y);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long long __UMAAL(unsigned long x,
                                       unsigned long y,
                                       unsigned long a,
                                       unsigned long b);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLALBB(unsigned long x,
                                 unsigned long y,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLALBT(unsigned long x,
                                 unsigned long y,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLALTB(unsigned long x,
                                 unsigned long y,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long __SMLALTT(unsigned long x,
                                 unsigned long y,
                                 long long acc);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UXTB16(unsigned long x);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UXTAB16(unsigned long acc, unsigned long x);

_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SXTB16(unsigned long x);
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SXTAB16(unsigned long acc, unsigned long x);

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SASX(unsigned long, unsigned long) ;
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __SSAX(unsigned long, unsigned long) ;
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHASX(unsigned long, unsigned long) ;
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __SHSAX(unsigned long, unsigned long) ;
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QASX(unsigned long, unsigned long) ;
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __QSAX(unsigned long, unsigned long) ;

_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UASX(unsigned long, unsigned long) ;
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __USAX(unsigned long, unsigned long) ;
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHASX(unsigned long, unsigned long) ;
_Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind unsigned long __UHSAX(unsigned long, unsigned long) ;
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQASX(unsigned long, unsigned long) ;
_Pragma("function_effects = hidden_state, always_returns") __intrinsic __nounwind unsigned long __UQSAX(unsigned long, unsigned long) ;


 
__intrinsic __nounwind void __DMB(void);
__intrinsic __nounwind void __DSB(void);
__intrinsic __nounwind void __ISB(void);

 
__intrinsic __nounwind unsigned long __TT(unsigned long);
__intrinsic __nounwind unsigned long __TTT(unsigned long);
__intrinsic __nounwind unsigned long __TTA(unsigned long);
__intrinsic __nounwind unsigned long __TTAT(unsigned long);




__intrinsic __nounwind unsigned long __get_LR(void);
__intrinsic __nounwind void __set_LR(unsigned long);

__intrinsic __nounwind unsigned long __get_SP(void);
__intrinsic __nounwind void __set_SP(unsigned long);

#pragma language=restore










#line 140 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\portable\\IAR\\ARM_CM4F\\portmacro.h"



 

 
extern void vPortEnterCritical( void );
extern void vPortExitCritical( void );
extern uint32_t ulPortSetInterruptMask( void );
extern void vPortClearInterruptMask( uint32_t ulNewMask );

#line 157 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\portable\\IAR\\ARM_CM4F\\portmacro.h"
 

 

	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );



 



 


 






 




 
#pragma diag_suppress=Pe191
#pragma diag_suppress=Pa082







#line 322 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\portable.h"






























#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\mpu_wrappers.h"































































 





 
#line 144 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\mpu_wrappers.h"










#line 353 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\portable.h"






 



	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) ;


 
typedef struct HeapRegion
{
	uint8_t *pucStartAddress;
	size_t xSizeInBytes;
} HeapRegion_t;











 
void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions );




 
void *pvPortMalloc( size_t xSize ) ;
void vPortFree( void *pv ) ;
void vPortInitialiseBlocks( void ) ;
size_t xPortGetFreeHeapSize( void ) ;
size_t xPortGetMinimumEverFreeHeapSize( void ) ;




 
BaseType_t xPortStartScheduler( void ) ;





 
void vPortEndScheduler( void ) ;







 











#line 101 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"





 















































































































































#line 256 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"

 


























































 

	
 




	
 




	
 




	
 














	
 




	



 




	


 




	


 




	


 







 





























































































































































































































#line 633 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"






























































































 




#line 748 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\FreeRTOS.h"

	
 












#line 3 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_service.c"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\task.h"































































 









#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\list.h"































































 



























 
































 









 
struct xLIST_ITEM
{
	 TickType_t xItemValue;			 
	struct xLIST_ITEM *  pxNext;		 
	struct xLIST_ITEM *  pxPrevious;	 
	void * pvOwner;										 
	void *  pvContainer;				 
};
typedef struct xLIST_ITEM ListItem_t;					 

struct xMINI_LIST_ITEM
{
	 TickType_t xItemValue;
	struct xLIST_ITEM *  pxNext;
	struct xLIST_ITEM *  pxPrevious;
};
typedef struct xMINI_LIST_ITEM MiniListItem_t;



 
typedef struct xLIST
{
	 UBaseType_t uxNumberOfItems;
	ListItem_t *  pxIndex;		 
	MiniListItem_t xListEnd;						 
} List_t;







 








 








 









 








 







 







 







 








 




 





















 
#line 280 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\list.h"

















 










 







 






 











 
void vListInitialise( List_t * const pxList );









 
void vListInitialiseItem( ListItem_t * const pxItem );











 
void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem );



















 
void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem );













 
UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove );







#line 75 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\task.h"







 















 
typedef void * TaskHandle_t;




 
typedef BaseType_t (*TaskHookFunction_t)( void * );

 
typedef enum
{
	eRunning = 0,	 
	eReady,			 
	eBlocked,		 
	eSuspended,		 
	eDeleted		 
} eTaskState;



 
typedef struct xTIME_OUT
{
	BaseType_t xOverflowCount;
	TickType_t  xTimeOnEntering;
} TimeOut_t;



 
typedef struct xMEMORY_REGION
{
	void *pvBaseAddress;
	uint32_t ulLengthInBytes;
	uint32_t ulParameters;
} MemoryRegion_t;



 
typedef struct xTASK_PARAMETERS
{
	TaskFunction_t pvTaskCode;
	const char * const pcName;	 
	uint16_t usStackDepth;
	void *pvParameters;
	UBaseType_t uxPriority;
	StackType_t *puxStackBuffer;
	MemoryRegion_t xRegions[ 1 ];
} TaskParameters_t;


 
typedef struct xTASK_STATUS
{
	TaskHandle_t xHandle;			 
	const char *pcTaskName;			   
	UBaseType_t xTaskNumber;		 
	eTaskState eCurrentState;		 
	UBaseType_t uxCurrentPriority;	 
	UBaseType_t uxBasePriority;		 
	uint32_t ulRunTimeCounter;		 



	uint16_t usStackHighWaterMark;	 
} TaskStatus_t;

 
typedef enum
{
	eAbortSleep = 0,		 
	eStandardSleep,			 
	eNoTasksWaitingTimeout	 
} eSleepModeStatus;






 









 













 













 









 









 




 







 
















































































 




































































 















































 
void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) ;







































 
void vTaskDelete( TaskHandle_t xTaskToDelete ) ;



 














































 
void vTaskDelay( const TickType_t xTicksToDelay ) ;

























































 
void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) ;













































 
UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) ;
















 
eTaskState eTaskGetState( TaskHandle_t xTask ) ;








































 
void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) ;

















































 
void vTaskSuspend( TaskHandle_t xTaskToSuspend ) ;















































 
void vTaskResume( TaskHandle_t xTaskToResume ) ;



























 
BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) ;



 



























 
void vTaskStartScheduler( void ) ;






















































 
void vTaskEndScheduler( void ) ;

















































 
void vTaskSuspendAll( void ) ;




















































 
BaseType_t xTaskResumeAll( void ) ;



 









 
TickType_t xTaskGetTickCount( void ) ;














 
TickType_t xTaskGetTickCountFromISR( void ) ;












 
UBaseType_t uxTaskGetNumberOfTasks( void ) ;












 
char *pcTaskGetTaskName( TaskHandle_t xTaskToQuery ) ;  



















 
UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) ;






 
#line 1141 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\task.h"











 
BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) ;







 
TaskHandle_t xTaskGetIdleTaskHandle( void );

































































































 
UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime );













































 
void vTaskList( char * pcWriteBuffer ) ;  




















































 
void vTaskGetRunTimeStats( char *pcWriteBuffer ) ;  



 















 
BaseType_t xTaskIncrementTick( void ) ;































 
void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) ;
void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) ;











 
void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait ) ;
























 
BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) ;
BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) ;








 
void vTaskSwitchContext( void ) ;




 
TickType_t uxTaskResetEventItemValue( void ) ;



 
TaskHandle_t xTaskGetCurrentTaskHandle( void ) ;



 
void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) ;




 
BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) ;




 
void vTaskMissedYield( void ) ;




 
BaseType_t xTaskGetSchedulerState( void ) ;




 
void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) ;




 
BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) ;




 
BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) ;  



 
UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) ;




 
void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) ;








 
void vTaskStepTick( const TickType_t xTicksToJump ) ;














 
eSleepModeStatus eTaskConfirmSleepModeStatus( void ) ;




 
void *pvTaskIncrementMutexHeldCount( void );








#line 4 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_service.c"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\timers.h"































































 










 

 







 





 
#line 100 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\timers.h"













 
typedef void * TimerHandle_t;



 
typedef void (*TimerCallbackFunction_t)( TimerHandle_t xTimer );




 
typedef void (*PendedFunction_t)( void *, uint32_t );

































































































































 
TimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) ;  




















 
void *pvTimerGetTimerID( TimerHandle_t xTimer ) ;



































 
BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer ) ;









 
TaskHandle_t xTimerGetTimerDaemonTaskHandle( void );


















































 









































 















































































 





































 



























































































































 





















































































 






























































 








































































 





















































































 


























































































 
BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken );

 






























 
BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait );









 
const char * pcTimerGetTimerName( TimerHandle_t xTimer );  




 
BaseType_t xTimerCreateTimerTask( void ) ;
BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait ) ;








#line 5 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_service.c"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\semphr.h"































































 








#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\queue.h"































































 


















 
typedef void * QueueHandle_t;





 
typedef void * QueueSetHandle_t;





 
typedef void * QueueSetMemberHandle_t;

 




 
#line 112 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\queue.h"
























































 

















































































 

















































































 



















































































 


















































































 























































































 
BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition ) ;






























































































 
































 
BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void * const pvBuffer ) ;



























































































 


































































































 
BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeek ) ;













 
UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue ) ;















 
UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue ) ;












 
void vQueueDelete( QueueHandle_t xQueue ) ;




































































 






































































 






















































































 









































































 













































































 
BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition ) ;























































































 
BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken ) ;




 
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue ) ;
BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue ) ;
UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue ) ;















 
BaseType_t xQueueAltGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, BaseType_t xCopyPosition );
BaseType_t xQueueAltGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, BaseType_t xJustPeeking );













 
BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken );
BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxTaskWoken );
BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait );
BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait );





 
QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType ) ;
QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount ) ;
void* xQueueGetMutexHolder( QueueHandle_t xSemaphore ) ;




 
BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait ) ;
BaseType_t xQueueGiveMutexRecursive( QueueHandle_t pxMutex ) ;






 























 













 







 
QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType ) ;
















































 
QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength ) ;






















 
BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) ;

















 
BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) ;


































 
QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait ) ;



 
QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet ) ;

 
void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait ) ;
BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue ) ;
void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber ) ;
UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue ) ;
uint8_t ucQueueGetQueueType( QueueHandle_t xQueue ) ;








#line 74 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\semphr.h"

typedef QueueHandle_t SemaphoreHandle_t;


















































 
#line 135 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_v8.1.2\\Source\\include\\semphr.h"













































 


































































 




























































































 














 






























































 



















































































 













 


























































































 

































 














































 






















































 






























































 













 














 





#line 6 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_service.c"

#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\os_dep\\include\\osdep_service.h"















 






 

 



 


















 

 




								
								
								
								
								

								
								
#line 72 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\os_dep\\include\\osdep_service.h"

#line 1 "F:\\IAR\\arm\\inc\\c\\stdio.h"
 
 




  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 11 "F:\\IAR\\arm\\inc\\c\\stdio.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\ysizet.h"
 
 

#line 30 "F:\\IAR\\arm\\inc\\c\\ysizet.h"







#line 13 "F:\\IAR\\arm\\inc\\c\\stdio.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\ystdio.h"
 
 




  #pragma system_include







#line 58 "F:\\IAR\\arm\\inc\\c\\ystdio.h"
  

 

__intrinsic __nounwind int remove(const char *);
__intrinsic __nounwind int rename(const char *, const char *);














 
#line 14 "F:\\IAR\\arm\\inc\\c\\stdio.h"



 
#pragma rtmodel="__dlib_file_descriptor","0"

                 








#line 66 "F:\\IAR\\arm\\inc\\c\\stdio.h"

#line 88 "F:\\IAR\\arm\\inc\\c\\stdio.h"

#line 99 "F:\\IAR\\arm\\inc\\c\\stdio.h"










                 
typedef _Fpost fpos_t;

                 
#pragma language=save
#pragma language=extended

#line 125 "F:\\IAR\\arm\\inc\\c\\stdio.h"

#line 177 "F:\\IAR\\arm\\inc\\c\\stdio.h"


              
_Pragma("function_effects = no_read(1), always_returns")    __intrinsic __nounwind char * __gets(char *, int);
_Pragma("function_effects = no_read(1), always_returns")    __intrinsic __nounwind char * gets(char *);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind void perror(const char *);
_Pragma("function_effects = no_write(1), always_returns")    _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int printf(const char *, ...);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind int puts(const char *);
_Pragma("function_effects = no_write(1), always_returns")    _Pragma("__scanf_args") _Pragma("library_default_requirements _Scanf = unknown")  __intrinsic __nounwind int scanf(const char *, ...);
_Pragma("function_effects = no_read(1), no_write(2), always_returns") _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int sprintf(char *, 
                                                 const char *, ...);
_Pragma("function_effects = no_write(1,2), always_returns") _Pragma("__scanf_args") _Pragma("library_default_requirements _Scanf = unknown")  __intrinsic __nounwind int sscanf(const char *, 
                                                const char *, ...);
             __intrinsic __nounwind char * tmpnam(char *);
              
             __intrinsic __nounwind int __ungetchar(int);
_Pragma("function_effects = no_write(1), always_returns")    _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int vprintf(const char *,
                                                 __Va_list);

  _Pragma("function_effects = no_write(1), always_returns")    _Pragma("__scanf_args") _Pragma("library_default_requirements _Scanf = unknown")  __intrinsic __nounwind int vscanf(const char *, 
                                                  __Va_list);
  _Pragma("function_effects = no_write(1,2), always_returns") _Pragma("__scanf_args") _Pragma("library_default_requirements _Scanf = unknown")  __intrinsic __nounwind int vsscanf(const char *, 
                                                   const char *, 
                                                   __Va_list);

_Pragma("function_effects = no_read(1), no_write(2), always_returns")  _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int vsprintf(char *, 
                                                   const char *,
                                                   __Va_list);
               
_Pragma("function_effects = no_write(1), always_returns")      __intrinsic __nounwind size_t __write_array(const void *, size_t, size_t);

  _Pragma("function_effects = no_read(1), no_write(3), always_returns") _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int snprintf(char *, size_t, 
                                                    const char *, ...);
  _Pragma("function_effects = no_read(1), no_write(3), always_returns") _Pragma("__printf_args") _Pragma("library_default_requirements _Printf = unknown") __intrinsic __nounwind int vsnprintf(char *, size_t,
                                                     const char *, 
                                                     __Va_list);


              __intrinsic __nounwind int getchar(void);
              __intrinsic __nounwind int putchar(int);



#pragma language=restore

#line 238 "F:\\IAR\\arm\\inc\\c\\stdio.h"




#line 292 "F:\\IAR\\arm\\inc\\c\\stdio.h"




 
#line 74 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\os_dep\\include\\osdep_service.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"


 




 



 








 
#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 42 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 52 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 62 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 





 





 





 





 





 





 





 





 





 





 




 





 







 





 






 





 




 




 




 







 




 




 




 






 




 




 




 




 








 
#line 76 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\os_dep\\include\\osdep_service.h"
#line 101 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\os_dep\\include\\osdep_service.h"

#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_service.h"







#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform\\dlist.h"













 









 

struct list_head {
	struct list_head *next, *prev;
};















 
static inline void __list_add(struct list_head *newitem,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = newitem;
	newitem->next = next;
	newitem->prev = prev;
	prev->next = newitem;
}








 
static inline void list_add(struct list_head *newitem, struct list_head *head)
{
	__list_add(newitem, head, head->next);
}








 
static inline void list_add_tail(struct list_head *newitem, struct list_head *head)
{
	__list_add(newitem, head->prev, head);
}







 
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
	prev->next = next;
}





 
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = (struct list_head *) 0;
	entry->prev = (struct list_head *) 0;
}




 
static inline void list_del_init(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	do { (entry)->next = (entry); (entry)->prev = (entry); } while (0); 
}





 
static inline void list_move(struct list_head *list, struct list_head *head)
{
        __list_del(list->prev, list->next);
        list_add(list, head);
}





 
static inline void list_move_tail(struct list_head *list,
				  struct list_head *head)
{
        __list_del(list->prev, list->next);
        list_add_tail(list, head);
}




 
static inline int list_empty(struct list_head *head)
{
	return head->next == head;
}

static inline void __list_splice(struct list_head *list,
				 struct list_head *head)
{
	struct list_head *first = list->next;
	struct list_head *last = list->prev;
	struct list_head *at = head->next;

	first->prev = head;
	head->next = first;

	last->next = at;
	at->prev = last;
}





 
static inline void list_splice(struct list_head *list, struct list_head *head)
{
	if (!list_empty(list))
		__list_splice(list, head);
}







 
static inline void list_splice_init(struct list_head *list,
				    struct list_head *head)
{
	if (!list_empty(list)) {
		__list_splice(list, head);
		do { (list)->next = (list); (list)->prev = (list); } while (0);
	}
}






 










 









 







 



        	





 









 











 






#line 9 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_service.h"




#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"





 









#line 22 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"

#line 150 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"

#line 1 "F:\\IAR\\arm\\inc\\c\\stdio.h"
 
 
#line 241 "F:\\IAR\\arm\\inc\\c\\stdio.h"

#line 292 "F:\\IAR\\arm\\inc\\c\\stdio.h"




 
#line 162 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\stdlib.h"
 
 





  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 12 "F:\\IAR\\arm\\inc\\c\\stdlib.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\ysizet.h"
 
 

#line 30 "F:\\IAR\\arm\\inc\\c\\ysizet.h"







#line 14 "F:\\IAR\\arm\\inc\\c\\stdlib.h"


 
#pragma rtmodel="__dlib_full_locale_support",   "0"





extern int __aeabi_MB_CUR_MAX(void);


#line 34 "F:\\IAR\\arm\\inc\\c\\stdlib.h"





                 













                 





typedef struct
{        
  int quot;
  int rem;
} div_t;

typedef struct
{        
  long quot;
  long rem;
} ldiv_t;



    #pragma language=save
    #pragma language=extended
    typedef struct
    {      
      _Longlong quot;
      _Longlong rem;
    } lldiv_t;
    #pragma language=restore



                 
  
__intrinsic __nounwind int atexit(void (*)(void));

  __intrinsic __noreturn __nounwind void _Exit(int) ;

__intrinsic __noreturn __nounwind void exit(int) ;
__intrinsic __nounwind char * getenv(const char *);
__intrinsic __nounwind int system(const char *);



             __intrinsic __noreturn __nounwind void abort(void) ;
_Pragma("function_effects = no_state, always_returns")     __intrinsic __nounwind int abs(int);
             __intrinsic __nounwind void * calloc(size_t, size_t);
_Pragma("function_effects = no_state, always_returns")     __intrinsic __nounwind div_t div(int, int);
             __intrinsic __nounwind void free(void *);
_Pragma("function_effects = no_state, always_returns")     __intrinsic __nounwind long labs(long);
_Pragma("function_effects = no_state, always_returns")     __intrinsic __nounwind ldiv_t ldiv(long, long);


    #pragma language=save
    #pragma language=extended
    _Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind long long llabs(long long);
    _Pragma("function_effects = no_state, always_returns") __intrinsic __nounwind lldiv_t lldiv(long long, long long);
    #pragma language=restore


             __intrinsic __nounwind void * malloc(size_t);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind int mblen(const char *, size_t);
_Pragma("function_effects = no_read(1), no_write(2), always_returns") __intrinsic __nounwind size_t mbstowcs(wchar_t *, 
                                          const char *, size_t);
_Pragma("function_effects = no_read(1), no_write(2), always_returns") __intrinsic __nounwind int mbtowc(wchar_t *, const char *, 
                                     size_t);
             __intrinsic __nounwind int rand(void);
             __intrinsic __nounwind void srand(unsigned int);
             __intrinsic __nounwind void * realloc(void *, size_t);
_Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long strtol(const char *, 
                                      char **, int);
_Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind unsigned long strtoul(const char *, char **, int);
_Pragma("function_effects = no_read(1), no_write(2), always_returns") __intrinsic __nounwind size_t wcstombs(char *, 
                                          const wchar_t *, size_t);
_Pragma("function_effects = no_read(1), always_returns")    __intrinsic __nounwind int wctomb(char *, wchar_t);


    #pragma language=save
    #pragma language=extended
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long long strtoll(const char *, char **, int);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind unsigned long long strtoull(const char *, 
                                                          char **, int);
    #pragma language=restore





#line 188 "F:\\IAR\\arm\\inc\\c\\stdlib.h"



    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind unsigned long __iar_Stoul(const char *, char **, 
                                                        int);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind float         __iar_Stof(const char *, char **, long);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind double        __iar_Stod(const char *, char **, long);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long double   __iar_Stold(const char *, char **, 
                                                          long);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long          __iar_Stolx(const char *, char **, int, 
                                                        int *);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind unsigned long __iar_Stoulx(const char *, char **,
                                                         int, int *);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind float         __iar_Stofx(const char *, char **, 
                                                        long, int *);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind double        __iar_Stodx(const char *, char **, 
                                                        long, int *);
    _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long double   __iar_Stoldx(const char *, char **, 
                                                         long, int *);

      #pragma language=save
      #pragma language=extended
      _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind _Longlong   __iar_Stoll(const char *, char **, 
                                                        int);
      _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind _ULonglong   __iar_Stoull(const char *, char **, 
                                                          int);
      _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind _Longlong    __iar_Stollx(const char *, char **, 
                                                          int, int *);
      _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind _ULonglong   __iar_Stoullx(const char *, char **, 
                                                           int, int *);
      #pragma language=restore








typedef int _Cmpfun(const void *, const void *);

_Pragma("function_effects = no_write(1,2), always_returns") __intrinsic void * bsearch(const void *, 
                                                   const void *, size_t,
                                                   size_t, _Cmpfun *);
             __intrinsic void qsort(void *, size_t, size_t, 
                                               _Cmpfun *);
             __intrinsic void __qsortbbl(void *, size_t, size_t, 
                                                    _Cmpfun *);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind double atof(const char *);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind int atoi(const char *);
_Pragma("function_effects = no_write(1), always_returns")    __intrinsic __nounwind long atol(const char *);


    #pragma language=save
    #pragma language=extended
    _Pragma("function_effects = no_write(1), always_returns") __intrinsic __nounwind long long atoll(const char *);
    #pragma language=restore

  _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind float strtof(const char *, 
                                         char **);
  _Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind long double strtold(const char *, char **);

_Pragma("function_effects = no_write(1), no_read(2), always_returns") __intrinsic __nounwind double strtod(const char *, 
                                        char **);
                                        

                                        
               __intrinsic __nounwind size_t __iar_Mbcurmax(void);

  _Pragma("function_effects = no_state, always_returns")     __intrinsic __nounwind int __iar_DLib_library_version(void);

  


#line 276 "F:\\IAR\\arm\\inc\\c\\stdlib.h"



  
  typedef void _Atexfun(void);
  
#line 304 "F:\\IAR\\arm\\inc\\c\\stdlib.h"


                 
    #pragma inline=no_body
    double atof(const char *_S)
    {       
      return (__iar_Stod(_S, 0, 0));
    }

    #pragma inline=no_body
    int atoi(const char *_S)
    {       
      return ((int)__iar_Stoul(_S, 0, 10));
    }

    #pragma inline=no_body
    long atol(const char *_S)
    {       
      return ((long)__iar_Stoul(_S, 0, 10));
    }



        #pragma language=save
        #pragma language=extended
        #pragma inline=no_body
        long long atoll(const char *_S)
        {       



            return ((long long)__iar_Stoull(_S, 0, 10));

        }
        #pragma language=restore



    #pragma inline=no_body
    double strtod(const char * _S, char ** _Endptr)
    {       
      return (__iar_Stod(_S, _Endptr, 0));
    }


      #pragma inline=no_body
      float strtof(const char * _S, char ** _Endptr)
      {       
        return (__iar_Stof(_S, _Endptr, 0));
      }

      #pragma inline=no_body
      long double strtold(const char * _S, char ** _Endptr)
      {       
        return (__iar_Stold(_S, _Endptr, 0));
      }


    #pragma inline=no_body
    long strtol(const char * _S, char ** _Endptr, 
                int _Base)
    {       
      return (__iar_Stolx(_S, _Endptr, _Base, 0));
    }

    #pragma inline=no_body
    unsigned long strtoul(const char * _S, char ** _Endptr, 
                          int _Base)
    {       
      return (__iar_Stoul(_S, _Endptr, _Base));
    }



        #pragma language=save
        #pragma language=extended
        #pragma inline=no_body
        long long strtoll(const char * _S, char ** _Endptr,
                          int _Base)
        {       



            return (__iar_Stoll(_S, _Endptr, _Base));

        }

        #pragma inline=no_body
        unsigned long long strtoull(const char * _S, 
                                    char ** _Endptr, int _Base)
        {       



            return (__iar_Stoull(_S, _Endptr, _Base));

        }
        #pragma language=restore





  #pragma inline=no_body
  int abs(int i)
  {       
    return (i < 0 ? -i : i);
  }

  #pragma inline=no_body
  long labs(long i)
  {       
    return (i < 0 ? -i : i);
  }



      #pragma language=save
      #pragma language=extended
      #pragma inline=no_body
      long long llabs(long long i)
      {       
        return (i < 0 ? -i : i);
      }
      #pragma language=restore



#line 465 "F:\\IAR\\arm\\inc\\c\\stdlib.h"




#line 494 "F:\\IAR\\arm\\inc\\c\\stdlib.h"




 
#line 163 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\string.h"
 
 




  #pragma system_include


#line 1 "F:\\IAR\\arm\\inc\\c\\ycheck.h"
 
 

 


  #pragma system_include







 























 






#line 67 "F:\\IAR\\arm\\inc\\c\\ycheck.h"

#line 11 "F:\\IAR\\arm\\inc\\c\\string.h"
#line 1 "F:\\IAR\\arm\\inc\\c\\ysizet.h"
 
 

#line 30 "F:\\IAR\\arm\\inc\\c\\ysizet.h"







#line 13 "F:\\IAR\\arm\\inc\\c\\string.h"

#line 1 "F:\\IAR\\arm\\inc\\c\\DLib_Product_string.h"








 





  #pragma system_include




  
  

  





 


  




 



#line 47 "F:\\IAR\\arm\\inc\\c\\DLib_Product_string.h"



  


 


  #pragma inline=forced_no_body
  __intrinsic __nounwind void * memcpy(void * _D, const void * _S, size_t _N)
  {
    __aeabi_memcpy(_D, _S, _N);
    return _D;
  }


  #pragma inline=forced_no_body
  __intrinsic __nounwind void * memmove(void * _D, const void * _S, size_t _N)
  {
    __aeabi_memmove(_D, _S, _N);
    return _D;
  }


  #pragma inline=forced_no_body
  __intrinsic __nounwind void * memset(void * _D, int _C, size_t _N)
  {
    __aeabi_memset(_D, _N, _C);
    return _D;
  }

  
  



#line 16 "F:\\IAR\\arm\\inc\\c\\string.h"



                 




                 

_Pragma("function_effects = no_state, no_write(1,2), always_returns")   __intrinsic __nounwind int        memcmp(const void *, const void *,
                                                size_t);
_Pragma("function_effects = no_state, no_read(1), no_write(2), returns 1, always_returns") __intrinsic __nounwind void *     memcpy(void *, 
                                                const void *, size_t);
_Pragma("function_effects = no_state, no_read(1), no_write(2), returns 1, always_returns") __intrinsic __nounwind void *     memmove(void *, const void *, size_t);
_Pragma("function_effects = no_state, no_read(1), returns 1, always_returns")    __intrinsic __nounwind void *     memset(void *, int, size_t);
_Pragma("function_effects = no_state, no_write(2), returns 1, always_returns")    __intrinsic __nounwind char *     strcat(char *, 
                                                const char *);
_Pragma("function_effects = no_state, no_write(1,2), always_returns")   __intrinsic __nounwind int        strcmp(const char *, const char *);
_Pragma("function_effects = no_write(1,2), always_returns")     __intrinsic __nounwind int        strcoll(const char *, const char *);
_Pragma("function_effects = no_state, no_read(1), no_write(2), returns 1, always_returns") __intrinsic __nounwind char *     strcpy(char *, 
                                                const char *);
_Pragma("function_effects = no_state, no_write(1,2), always_returns")   __intrinsic __nounwind size_t     strcspn(const char *, const char *);
                 __intrinsic __nounwind char *     strerror(int);
_Pragma("function_effects = no_state, no_write(1), always_returns")      __intrinsic __nounwind size_t     strlen(const char *);
_Pragma("function_effects = no_state, no_write(2), returns 1, always_returns")    __intrinsic __nounwind char *     strncat(char *, 
                                                 const char *, size_t);
_Pragma("function_effects = no_state, no_write(1,2), always_returns")   __intrinsic __nounwind int        strncmp(const char *, const char *, 
                                                 size_t);
_Pragma("function_effects = no_state, no_read(1), no_write(2), returns 1, always_returns") __intrinsic __nounwind char *     strncpy(char *, 
                                                 const char *, size_t);
_Pragma("function_effects = no_state, no_write(1,2), always_returns")   __intrinsic __nounwind size_t     strspn(const char *, const char *);
_Pragma("function_effects = no_write(2), always_returns")        __intrinsic __nounwind char *     strtok(char *, 
                                                const char *);
_Pragma("function_effects = no_write(2), always_returns")        __intrinsic __nounwind size_t     strxfrm(char *, 
                                                 const char *, size_t);


  _Pragma("function_effects = no_write(1), always_returns")      __intrinsic __nounwind char *   strdup(const char *);
  _Pragma("function_effects = no_write(1,2), always_returns")   __intrinsic __nounwind int      strcasecmp(const char *, const char *);
  _Pragma("function_effects = no_write(1,2), always_returns")   __intrinsic __nounwind int      strncasecmp(const char *, const char *, 
                                                   size_t);
  _Pragma("function_effects = no_state, no_write(2), always_returns")    __intrinsic __nounwind char *   strtok_r(char *, const char *, char **);
  _Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind size_t   strnlen(char const *, size_t);




#line 81 "F:\\IAR\\arm\\inc\\c\\string.h"
  _Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind void *memchr(const void *_S, int _C, size_t _N);
  _Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind char *strchr(const char *_S, int _C);
  _Pragma("function_effects = no_state, no_write(1,2), always_returns") __intrinsic __nounwind char *strpbrk(const char *_S, const char *_P);
  _Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind char *strrchr(const char *_S, int _C);
  _Pragma("function_effects = no_state, no_write(1,2), always_returns") __intrinsic __nounwind char *strstr(const char *_S, const char *_P);




                 


                 

_Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind void *__iar_Memchr(const void *, int, size_t);
_Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind char *__iar_Strchr(const char *, int);
               __intrinsic __nounwind char *__iar_Strerror(int, char *);
_Pragma("function_effects = no_state, no_write(1,2), always_returns") __intrinsic __nounwind char *__iar_Strpbrk(const char *, const char *);
_Pragma("function_effects = no_state, no_write(1), always_returns")    __intrinsic __nounwind char *__iar_Strrchr(const char *, int);
_Pragma("function_effects = no_state, no_write(1,2), always_returns") __intrinsic __nounwind char *__iar_Strstr(const char *, const char *);


                 
#line 168 "F:\\IAR\\arm\\inc\\c\\string.h"
                 
    #pragma inline
    void *memchr(const void *_S, int _C, size_t _N)
    {
      return (__iar_Memchr(_S, _C, _N));
    }

    #pragma inline
    char *strchr(const char *_S, int _C)
    {
      return (__iar_Strchr(_S, _C));
    }

    #pragma inline
    char *strpbrk(const char *_S, const char *_P)
    {
      return (__iar_Strpbrk(_S, _P));
    }

    #pragma inline
    char *strrchr(const char *_S, int _C)
    {
      return (__iar_Strrchr(_S, _C));
    }

    #pragma inline
    char *strstr(const char *_S, const char *_P)
    {
      return (__iar_Strstr(_S, _P));
    }


  #pragma inline
  char *strerror(int _Err)
  {
    return (__iar_Strerror(_Err, 0));
  }

#line 451 "F:\\IAR\\arm\\inc\\c\\string.h"






#line 479 "F:\\IAR\\arm\\inc\\c\\string.h"




 
#line 164 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
	#include <stdarg.h>  
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"







 




#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"


 




 



 








 
#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 42 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 52 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 62 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 





 





 





 





 





 





 





 





 





 





 




 





 







 





 






 





 




 




 




 







 




 




 




 






 




 




 




 




 








 
#line 14 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"


















 




#line 1 "F:\\IAR\\arm\\inc\\c\\stdint.h"
 
 
#line 235 "F:\\IAR\\arm\\inc\\c\\stdint.h"

#line 258 "F:\\IAR\\arm\\inc\\c\\stdint.h"




 
#line 25 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"






















		













typedef unsigned int	        uint;
typedef	signed int		        sint;


typedef signed long long        __int64_t;
typedef unsigned long long      __uint64_t;


#line 77 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"





typedef unsigned char           BOOL;


typedef unsigned char           bool;








typedef struct { volatile int counter; } atomic_t;

typedef enum _RTK_STATUS_ {
    _EXIT_SUCCESS = 0,
    _EXIT_FAILURE = 1
}RTK_STATUS, *PRTK_STATUS;

#line 107 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"


typedef void * PVOID;


typedef     uint32_t dma_addr_t;

typedef     void (*proc_t)(void*);

typedef     unsigned int __kernel_size_t;
typedef     int __kernel_ssize_t;

typedef 	__kernel_size_t	SIZE_T;	
typedef	    __kernel_ssize_t	SSIZE_T;

























#line 178 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"







#line 201 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"











 




#line 228 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"

#line 241 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"







 




















































#line 307 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"






#line 319 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"





#line 331 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"

		


		


	


	
#line 348 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"
	
#line 355 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"

#line 363 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"
			









#line 379 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"

#line 386 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"

#line 394 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"








#line 411 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"




typedef unsigned char	BOOLEAN,*PBOOLEAN,boolean;







 








								
								
								
								
								

								
								
#line 449 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"












#line 480 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\fwlib\\include\\basic_types.h"







typedef struct _RAM_START_FUNCTION_ {
    void (*RamStartFun) (void);
	void (*RamWakeupFun) (void);
}RAM_START_FUNCTION, *PRAM_START_FUNCTION;

typedef struct _RAM_FUNCTION_START_TABLE_ {
	void (*RamStartFun) (void);
	void (*RamWakeupFun) (void);
	void (*RamPatchFun0) (void);
	void (*RamPatchFun1) (void);
	void (*RamPatchFun2) (void);
	void (*FlashStartFun) (void);
}RAM_FUNCTION_START_TABLE, *PRAM_FUNCTION_START_TABLE;

#line 15 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"

#line 1 "F:\\IAR\\arm\\inc\\c\\stddef.h"
 
 
#line 39 "F:\\IAR\\arm\\inc\\c\\stddef.h"

#line 49 "F:\\IAR\\arm\\inc\\c\\stddef.h"





 
#line 17 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\app\\monitor\\include\\rtl_trace.h"















 







 




 



 

 
typedef enum {
	MODULE_OS		= 0,   
	MODULE_BOOT		= 1,   
	MODULE_GDMA	= 2,   
	MODULE_GPIO		= 3,   
	MODULE_TIMER	= 4,   
	MODULE_I2C		= 5,   
	MODULE_I2S		= 6,   
	MODULE_PWM		= 7,   
	MODULE_SDIO		= 8,   
	MODULE_SPI		= 9,   
	MODULE_FLASH	= 10,  
	MODULE_UART		= 11,  
	MODULE_USOC		= 12,  
	MODULE_IPSEC	= 13,  
	MODULE_ADC		= 14,  
	MODULE_EFUSE	= 15,  
	MODULE_MONIT	= 16,  
	MODULE_MISC		= 17,  

	MODULE_NUMs            
} MODULE_DEFINE;

 
typedef enum {
	LEVEL_ERROR	= 0,  
	LEVEL_WARN	= 1,  
	LEVEL_INFO		= 2,  
	LEVEL_TRACE	= 3,  
	LEVEL_NUMs		= 4   
} LEVEL_DEFINE;


 



 

 
 
extern uint32_t ConfigDebug[];
 


















 
void LOG_MASK_MODULE(uint32_t module, uint32_t level, uint32_t new_status);
void LOG_MASK(uint32_t config[]);
void LOG_PRINTF(uint32_t module, uint32_t level, uint32_t line, const char*fmt, ...);



 
#line 120 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\app\\monitor\\include\\rtl_trace.h"



 



 



 


 
#line 18 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"

extern uint32_t ConfigDebugClose;
extern uint32_t ConfigDebugErr;
extern uint32_t ConfigDebugInfo;
extern uint32_t ConfigDebugWarn;

extern uint32_t CfgSysDebugErr;
extern uint32_t CfgSysDebugInfo;
extern uint32_t CfgSysDebugWarn;










#line 57 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"

extern  uint32_t DiagPrintf(const char *fmt, ...);
uint32_t DiagSPrintf(uint8_t *buf, const char *fmt, ...);
int prvDiagPrintf(const char *fmt, ...);
int prvDiagSPrintf(char *buf, const char *fmt, ...);






























#line 100 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"








































#line 153 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"

#line 161 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\diag.h"

typedef enum {
	DBG_CFG_ERR=0,
	DBG_CFG_WARN=1,
	DBG_CFG_INFO=2
} DBG_CFG_TYPE;

typedef struct {
	uint8_t cmd_name[16];
	uint32_t	cmd_type;
} DBG_CFG_CMD;

typedef enum _CONSOLE_OP_STAGE_ {
	ROM_STAGE = 0,
	RAM_STAGE = 1
}CONSOLE_OP_STAGE;

#line 166 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\strproc.h"







 




#line 1 "F:\\IAR\\arm\\inc\\c\\stddef.h"
 
 
#line 39 "F:\\IAR\\arm\\inc\\c\\stddef.h"

#line 49 "F:\\IAR\\arm\\inc\\c\\stddef.h"





 
#line 14 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\strproc.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\va_list.h"







 




#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"


 




 



 








 
#line 32 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 42 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 52 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 
#line 62 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\inc\\platform_autoconf.h"



 





 





 





 





 





 





 





 





 





 





 




 





 







 





 






 





 




 




 




 







 




 




 




 






 




 




 




 




 








 
#line 14 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\va_list.h"


#line 36 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\va_list.h"

#line 15 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\strproc.h"

#line 24 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\strproc.h"

extern  SIZE_T _strlen(const char *s);
extern  int _strcmp(const char *cs, const char *ct);
extern  char *_strncpy(char *dest, const char *src, size_t count);
extern  char *_strcpy(char *dest, const char *src);
extern  size_t _strlen(const char *s);
extern  size_t _strnlen(const char *s, size_t count);
extern  int _strncmp(const char *cs, const char *ct, size_t count);
extern  int _sscanf(const char *buf, const char *fmt, ...);
extern  char *_strsep(char **s, const char *ct);
extern  char *skip_spaces(const char *str);
extern  int skip_atoi(const char **s);
extern  int _vsscanf(const char *buf, const char *fmt, va_list args);
extern  unsigned long long simple_strtoull(const char *cp, char **endp, unsigned int base);
extern  long simple_strtol(const char *cp, char **endp, unsigned int base);
extern  long long simple_strtoll(const char *cp, char **endp, unsigned int base);
extern  unsigned long simple_strtoul(const char *cp, char **endp, unsigned int base);
extern  const char *_parse_integer_fixup_radix(const char *s, unsigned int *base);
extern  unsigned int _parse_integer(const char *s, unsigned int base, unsigned long long *p);
extern  uint64_t div_u64(uint64_t dividend, uint32_t divisor);
extern  int64_t div_s64(int64_t dividend, int32_t divisor);
extern  uint64_t div_u64_rem(uint64_t dividend, uint32_t divisor, uint32_t *remainder);
extern  int64_t div_s64_rem(int64_t dividend, int32_t divisor, int32_t *remainder);
extern  char *_strpbrk(const char *cs, const char *ct);
extern  char *_strchr(const char *s, int c);


extern  void
prvStrCpy(
      uint8_t  *pDES,
      const uint8_t  *pSRC
);

extern  uint32_t
prvStrLen(
      const   uint8_t  *pSRC
);

extern   uint8_t
prvStrCmp(
      const   uint8_t  *string1,
      const   uint8_t  *string2
);

extern  uint8_t*
StrUpr(
      uint8_t  *string
);

extern  int prvAtoi(
	 const char * s
);

extern   char * prvStrStr(
	 const char * str1, 
	 const char * str2
);

extern  char* prvStrtok(
	 char *str, 
	 const char* delim
);





 
static inline char _tolower(const char c)
{
    return c | 0x20;
}

 
static inline int isodigit(const char c)
{
    return c >= '0' && c <= '7';
}
#line 108 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\strproc.h"

#line 167 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\rtl_lib\\memproc.h"







 






 
extern  void *_memset( void *s, int c, SIZE_T n );
extern  void *_memcpy( void *s1, const void *s2, SIZE_T n );
extern  int _memcmp( const void *av, const void *bv, SIZE_T len );



#line 168 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\std_lib\\include\\rtl_lib.h"




 
 








extern int __rtl_errno;


void init_rom_libgloss_ram_map(void);






extern int rtl_printf( const char* fmt, ...);
extern int rtl_vprintf(const char *fmt, va_list ap);
extern int rtl_sprintf(char* str, const char* fmt, ...);
extern int rtl_snprintf(char* str, size_t size, const char* fmt, ...);
extern int rtl_vsnprintf(char *str, size_t size, const char *fmt, va_list ap);





extern void * rtl_memchr(const void * src_void , int c , size_t length);
extern int rtl_memcmp(const void * m1 , const void * m2 , size_t n);
extern void * rtl_memcpy(void * dst0 , const void * src0 , size_t len0);
extern void * rtl_memmove( void * dst_void , const void * src_void , size_t length);
extern void * rtl_memset(void * m , int c , size_t n);
extern char * rtl_strcat(char * s1 , const char * s2);
extern char * rtl_strchr(const char *s1 , int i);
extern int rtl_strcmp(const char *s1 ,	const char *s2);
extern char* rtl_strcpy(char *dst0 , const char *src0);
extern size_t rtl_strlen(const char *str);
extern char * rtl_strncat(char * s1 , const char * s2 , size_t n);
extern int rtl_strncmp(const char *s1 , const char *s2 , size_t n);
extern char * rtl_strncpy(char * dst0 , const char * src0 , size_t count);
extern char * rtl_strstr(const char *searchee , const char *lookfor);
extern char * rtl_strsep(char **source_ptr , const char *delim);
extern char * rtl_strtok(char * s , const char * delim);






extern double rtl_fabs(double);
extern float rtl_fabsf(float a);
extern float rtl_cos_f32(float a);
extern float rtl_sin_f32(float a);

extern float rtl_fadd(float a, float b);
extern float rtl_fsub(float a, float b);
extern float rtl_fmul(float a, float b);
extern float rtl_fdiv(float a, float b);

extern int rtl_fcmplt(float a, float b);
extern int rtl_fcmpgt(float a, float b);








extern double rtl_ftod(float f);

extern double rtl_ddiv(double a, double b);






typedef union
{
  float value;
  uint32_t 	word;
} ieee_float_shape_type;

 

#line 100 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\std_lib\\include\\rtl_lib.h"

 

#line 109 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\std_lib\\include\\rtl_lib.h"

static inline
float rtl_nanf(void)
{
	float x;

	do { ieee_float_shape_type sf_u; sf_u . word = (0x7fc00000); (x) = sf_u . value; } while (0);
	return x;
}






extern int rtl_sscanf_patch_test(void);
extern int rtl_lib_test( uint16_t argc,  uint8_t *argv[]);
extern int rtl_math_test( uint16_t argc,  uint8_t *argv[]);
extern int rtl_string_test( uint16_t argc,  uint8_t *argv[]);
















#line 171 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\std_lib\\libc\\rom\\string\\rom_libc_string.h"




 





#line 27 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\soc\\realtek\\8711b\\swlib\\std_lib\\libc\\rom\\string\\rom_libc_string.h"





extern  void * __rtl_memchr_v1_00(const void * src_void , int c , size_t length);
extern  int __rtl_memcmp_v1_00(const void * m1 , const void * m2 , size_t n);
extern  void * __rtl_memcpy_v1_00(void *  dst0 , const void *  src0 , size_t len0);
extern  void * __rtl_memmove_v1_00( void * dst_void , const void * src_void , size_t length);
extern  void * __rtl_memset_v1_00(void * m , int c , size_t n);
extern  char * __rtl_strcat_v1_00(char * s1 , const char * s2);
extern  char * __rtl_strchr_v1_00(const char *s1 , int i);
extern  int __rtl_strcmp_v1_00(const char *s1 ,	const char *s2);
extern  char* __rtl_strcpy_v1_00(char *dst0 , const char *src0);
extern  size_t __rtl_strlen_v1_00(const char *str);
extern  char * __rtl_strncat_v1_00(char * s1 , const char * s2 , size_t n);
extern  int __rtl_strncmp_v1_00(const char *s1 , const char *s2 , size_t n);
extern  char * __rtl_strncpy_v1_00(char * dst0 , const char * src0 , size_t count);
extern  char * __rtl_strstr_v1_00(const char *searchee , const char *lookfor);
extern  char * __rtl_strsep_v1_00(register char **source_ptr , register const char *delim);
extern  char * __rtl_strtok_v1_00(register char * s , register const char * delim);

#line 172 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"


#line 196 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
	
#line 218 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
	
#line 227 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
	



	
#line 240 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"
	
	
	






extern void *pvPortMalloc( size_t xWantedSize );
extern void vPortFree( void *pv );
#line 259 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\common\\api\\platform/platform_stdlib.h"


#line 18 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_service.h"






#line 30 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_service.h"





#line 68 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_service.h"




typedef char			osdepCHAR;
typedef float			osdepFLOAT;
typedef double			osdepDOUBLE;
typedef long			osdepLONG;
typedef short			osdepSHORT;
typedef unsigned long	osdepSTACK_TYPE;
typedef long			osdepBASE_TYPE;
typedef unsigned long	osdepTickType;

typedef void*	_timerHandle;
typedef void*	_sema;
typedef void*	_mutex;
typedef void*	_lock;
typedef void*	_queueHandle;
typedef void*	_xqueue;
typedef struct timer_list	_timer;

typedef	struct sk_buff		_pkt;
typedef unsigned char		_buffer;

#line 98 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_service.h"

struct	__queue	{
	struct	list_head	queue;
	_lock			lock;
};

typedef struct	__queue		_queue;
typedef struct	list_head	_list;
typedef unsigned long		_irqL;

typedef void*			_thread_hdl_;
typedef void			thread_return;
typedef void*			thread_context;





 


static inline _list *get_next(_list	*list)
{
	return list->next;
}	

static inline _list	*get_list_head(_queue	*queue)
{
	return (&(queue->queue));
}




#line 138 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_service.h"



void save_and_cli(void);
void restore_flags(void);
void cli(void);

























#line 176 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_service.h"

#line 192 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_service.h"





















 










 



 











 


  




extern void	rtw_init_listhead(_list *list);
extern uint32_t	rtw_is_list_empty(_list *phead);
extern void	rtw_list_insert_head(_list *plist, _list *phead);
extern void	rtw_list_insert_tail(_list *plist, _list *phead);
extern void	rtw_list_delete(_list *plist);


extern uint32_t random_seed;


#line 104 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\os_dep\\include\\osdep_service.h"









 


 







 
struct timer_list {
	_timerHandle 	timer_hdl;
	unsigned long	data;
	void (*function)(void *);
};



 
typedef thread_return (*thread_func_t)(thread_context context);
typedef void (*TIMER_FUN)(void *context);
typedef int (*event_handler_t)(char *buf, int buf_len, int flags, void *user_data);


struct task_struct {
	const char *task_name;
	_thread_hdl_ task;	 






	_sema wakeup_sema;
	_sema terminate_sema;


	uint32_t blocked; 
	uint32_t callback_running;
};

typedef struct {
	_xqueue event_queue;
	struct task_struct thread;
}rtw_worker_thread_t;

typedef struct
{
	event_handler_t function;
	char *buf;
	int buf_len;
	int flags;
	void *user_data;
} rtw_event_message_t;

struct worker_timer_entry {
	struct list_head 	list;
	_timerHandle 		timer_hdl;
	rtw_event_message_t	message;
	rtw_worker_thread_t	*worker_thread;
	uint32_t 				timeout; 
};

#line 194 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\os_dep\\include\\osdep_service.h"




 



#line 211 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\os_dep\\include\\osdep_service.h"






 
void init_mem_monitor(_list *pmem_table, int *used_num);






 
void deinit_mem_monitor(_list *pmem_table, int *used_num);









 
void add_mem_usage(_list *pmem_table, void *ptr, int size, int *used_num, int flag);








 
void del_mem_usage(_list *pmem_table, void *ptr, int *used_num, int flag);





 
int get_mem_usage(_list *pmem_table);
 



 
uint8_t*	_rtw_vmalloc(uint32_t sz);
uint8_t*	_rtw_zvmalloc(uint32_t sz);
void	_rtw_vmfree(uint8_t *pbuf, uint32_t sz);
uint8_t*	_rtw_zmalloc(uint32_t sz);
uint8_t*	_rtw_malloc(uint32_t sz);
void	_rtw_mfree(uint8_t *pbuf, uint32_t sz);






 
uint8_t*	rtw_vmalloc(uint32_t sz);






 
uint8_t*	rtw_zvmalloc(uint32_t sz);






 
void	rtw_vmfree(uint8_t *pbuf, uint32_t sz);






 
uint8_t*	rtw_zmalloc(uint32_t sz);





 
uint8_t*	rtw_malloc(uint32_t sz);






 
void	rtw_mfree(uint8_t *pbuf, uint32_t sz);
#line 322 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\os_dep\\include\\osdep_service.h"







 
void*	rtw_malloc2d(int h, int w, int size);








 
void	rtw_mfree2d(void *pbuf, int h, int w, int size);








 
void	rtw_memcpy(void* dst, void* src, uint32_t sz);










 
int	rtw_memcmp(void *dst, void *src, uint32_t sz);







 
void	rtw_memset(void *pbuf, int c, uint32_t sz);
 

 





 
void	rtw_init_listhead(_list *list);





 
uint32_t	rtw_is_list_empty(_list *phead);






 
void	rtw_list_insert_head(_list *plist, _list *phead);






 
void	rtw_list_insert_tail(_list *plist, _list *phead);






 
void	rtw_list_delete(_list *plist);
 


 





 
void	rtw_init_sema(_sema *sema, int init_val);





 
void	rtw_free_sema(_sema *sema);






 
void	rtw_up_sema(_sema	*sema);






 
void	rtw_up_sema_from_isr(_sema *sema);







 
uint32_t	rtw_down_sema(_sema *sema);








 
uint32_t	rtw_down_timeout_sema(_sema *sema, uint32_t timeout);
 

 




 
void	rtw_mutex_init(_mutex *pmutex);





 
void	rtw_mutex_free(_mutex *pmutex);





 
void	rtw_mutex_put(_mutex *pmutex);






 
void	rtw_mutex_get(_mutex *pmutex);








 
int	rtw_mutex_get_timeout(_mutex *pmutex, uint32_t timeout_ms);
 

 








 
void	rtw_enter_critical(_lock *plock, _irqL *pirqL);









 
void	rtw_exit_critical(_lock *plock, _irqL *pirqL);






 
void	rtw_enter_critical_from_isr(_lock *plock, _irqL *pirqL);






 
void	rtw_exit_critical_from_isr(_lock *plock, _irqL *pirqL);







 
void	rtw_enter_critical_bh(_lock *plock, _irqL *pirqL);






 
void	rtw_exit_critical_bh(_lock *plock, _irqL *pirqL);






 
int	rtw_enter_critical_mutex(_mutex *pmutex, _irqL *pirqL);






 
void	rtw_exit_critical_mutex(_mutex *pmutex, _irqL *pirqL);
 

 





 
void	rtw_spinlock_init(_lock *plock);





 
void	rtw_spinlock_free(_lock *plock);






 
void	rtw_spin_lock(_lock *plock);





 
void	rtw_spin_unlock(_lock *plock);








 
void	rtw_spinlock_irqsave(_lock *plock, _irqL *irqL);







 
void	rtw_spinunlock_irqsave(_lock *plock, _irqL *irqL);
 

 









 
int rtw_init_xqueue( _xqueue* queue, const char* name, uint32_t message_size, uint32_t number_of_messages );











 
int rtw_push_to_xqueue( _xqueue* queue, void* message, uint32_t timeout_ms );











 
int rtw_pop_from_xqueue( _xqueue* queue, void* message, uint32_t timeout_ms );






 
int rtw_deinit_xqueue( _xqueue* queue );





 
void	rtw_init_queue(_queue	*pqueue);
void	rtw_deinit_queue(_queue	*pqueue);
uint32_t	rtw_is_queue_empty(_queue *pqueue);





 
uint32_t	rtw_queue_empty(_queue	*pqueue);






 
uint32_t	rtw_end_of_queue_search(_list *queue, _list *pelement);
_list* rtw_get_queue_head(_queue	*queue);
 

 




 
uint32_t	rtw_get_current_time(void);





 
uint32_t	rtw_systime_to_ms(uint32_t systime);





 
uint32_t rtw_systime_to_sec(uint32_t systime);





 
uint32_t	rtw_ms_to_systime(uint32_t ms);





 
uint32_t	rtw_sec_to_systime(uint32_t sec);





 
int32_t	rtw_get_passing_time_ms(uint32_t start);






 
int32_t	rtw_get_time_interval_ms(uint32_t start, uint32_t end);
 





 
void	rtw_msleep_os(int ms);





 
void	rtw_usleep_os(int us);





 
uint32_t 	rtw_atoi(uint8_t* s);





 
void	rtw_mdelay_os(int ms);





 
void	rtw_udelay_os(int us);




 
void	rtw_yield_os(void);

 







 
void 	ATOMIC_SET(atomic_t *v, int i);






 
int		ATOMIC_READ(atomic_t *v);






 
void 	ATOMIC_ADD(atomic_t *v, int i);






 
void 	ATOMIC_SUB(atomic_t *v, int i);





 
void 	ATOMIC_INC(atomic_t *v);





 
void 	ATOMIC_DEC(atomic_t *v);






 
int 	ATOMIC_ADD_RETURN(atomic_t *v, int i);






 
int 	ATOMIC_SUB_RETURN(atomic_t *v, int i);





 
int 	ATOMIC_INC_RETURN(atomic_t *v);





 
int 	ATOMIC_DEC_RETURN(atomic_t *v);






 
int ATOMIC_DEC_AND_TEST(atomic_t *v);
 

uint64_t	rtw_modular64(uint64_t x, uint64_t y);






 
int	rtw_get_random_bytes(void* dst, uint32_t size);




 
uint32_t	rtw_getFreeHeapSize(void);

void	flush_signals_thread(void);






 
void	rtw_acquire_wakelock(void);






 
void	rtw_release_wakelock(void);
void rtw_wakelock_timeout(uint32_t timeout);

 














 
int	rtw_create_task(struct task_struct *task, const char *name, uint32_t  stack_size, uint32_t priority, thread_func_t func, void *thctx);





 
void rtw_delete_task(struct task_struct * task);





 
void rtw_wakeup_task(struct task_struct *task);








 
int rtw_create_worker_thread( rtw_worker_thread_t* worker_thread, uint8_t priority, uint32_t stack_size, uint32_t event_queue_size );





 
int rtw_delete_worker_thread( rtw_worker_thread_t* worker_thread );

#line 977 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\os_dep\\include\\osdep_service.h"





 
void	rtw_thread_enter(char *name);




 
void	rtw_thread_exit(void);






 
uint8_t		rtw_get_scheduler_state(void);

 






 













 
_timerHandle rtw_timerCreate( const signed char *pcTimerName, 
							  osdepTickType xTimerPeriodInTicks, 
							  uint32_t uxAutoReload, 
							  void * pvTimerID, 
							  TIMER_FUN pxCallbackFunction );












 
uint32_t rtw_timerDelete( _timerHandle xTimer, osdepTickType xBlockTime );









 
uint32_t rtw_timerIsTimerActive( _timerHandle xTimer );













 
uint32_t rtw_timerStop( _timerHandle xTimer, osdepTickType xBlockTime );















 
uint32_t rtw_timerChangePeriod( _timerHandle xTimer, 
							   osdepTickType xNewPeriod, 
							   osdepTickType xBlockTime );

void *rtw_timerGetID( _timerHandle xTimer );

uint32_t  rtw_timerStart( _timerHandle xTimer, osdepTickType xBlockTime );

uint32_t  rtw_timerStartFromISR( _timerHandle xTimer, 
								osdepBASE_TYPE *pxHigherPriorityTaskWoken );

uint32_t  rtw_timerStopFromISR( _timerHandle xTimer, 
							   osdepBASE_TYPE *pxHigherPriorityTaskWoken );

uint32_t  rtw_timerResetFromISR( _timerHandle xTimer, 
							   osdepBASE_TYPE *pxHigherPriorityTaskWoken );

uint32_t  rtw_timerChangePeriodFromISR( _timerHandle xTimer, 
							   osdepTickType xNewPeriod, 
							   osdepBASE_TYPE *pxHigherPriorityTaskWoken );

uint32_t  rtw_timerReset( _timerHandle xTimer, 
						osdepTickType xBlockTime );


 







	



inline static uint32_t _RND4(uint32_t sz)
{
	uint32_t	val;

	val = ((sz >> 2) + ((sz & 3) ? 1: 0)) << 2;
	
	return val;
}

inline static uint32_t _RND8(uint32_t sz)
{
	uint32_t	val;

	val = ((sz >> 3) + ((sz & 7) ? 1: 0)) << 3;
	
	return val;
}

inline static uint32_t _RND128(uint32_t sz)
{
	uint32_t	val;

	val = ((sz >> 7) + ((sz & 127) ? 1: 0)) << 7;
	
	return val;
}

inline static uint32_t _RND256(uint32_t sz)
{
	uint32_t	val;

	val = ((sz >> 8) + ((sz & 255) ? 1: 0)) << 8;
	
	return val;
}

inline static uint32_t _RND512(uint32_t sz)
{
	uint32_t	val;

	val = ((sz >> 9) + ((sz & 511) ? 1: 0)) << 9;
	
	return val;
}

inline static uint32_t bitshift(uint32_t bitmask)
{
	uint32_t i;

	for (i = 0; i <= 31; i++)
		if (((bitmask>>i) &  0x1) == 1) break;

	return i;
}

 

#line 1182 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\os_dep\\include\\osdep_service.h"

#line 1189 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\os_dep\\include\\osdep_service.h"

#line 1198 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\os_dep\\include\\osdep_service.h"

#line 1208 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\os_dep\\include\\osdep_service.h"

#line 1218 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\os_dep\\include\\osdep_service.h"

#line 1234 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\os_dep\\include\\osdep_service.h"






struct osdep_service_ops {
	uint8_t* (*rtw_vmalloc)(uint32_t sz);
	uint8_t* (*rtw_zvmalloc)(uint32_t sz);
	void (*rtw_vmfree)(uint8_t *pbuf, uint32_t sz);
	uint8_t* (*rtw_malloc)(uint32_t sz);
	uint8_t* (*rtw_zmalloc)(uint32_t sz);
	void (*rtw_mfree)(uint8_t *pbuf, uint32_t sz);
	void (*rtw_memcpy)(void* dst, void* src, uint32_t sz);
	int (*rtw_memcmp)(void *dst, void *src, uint32_t sz);
	void (*rtw_memset)(void *pbuf, int c, uint32_t sz);
	void (*rtw_init_sema)(_sema *sema, int init_val);
	void (*rtw_free_sema)(_sema *sema);
	void (*rtw_up_sema)(_sema *sema);
	void (*rtw_up_sema_from_isr)(_sema *sema);
	uint32_t (*rtw_down_timeout_sema)(_sema *sema, uint32_t timeout);
	void (*rtw_mutex_init)(_mutex *pmutex);
	void (*rtw_mutex_free)(_mutex *pmutex);
	void (*rtw_mutex_get)(_mutex *pmutex);
	int (*rtw_mutex_get_timeout)(_mutex *pmutex, uint32_t timeout_ms);
	void (*rtw_mutex_put)(_mutex *pmutex);
	void (*rtw_enter_critical)(_lock *plock, _irqL *pirqL);
	void (*rtw_exit_critical)(_lock *plock, _irqL *pirqL);
	void (*rtw_enter_critical_from_isr)(_lock *plock, _irqL *pirqL);
	void (*rtw_exit_critical_from_isr)(_lock *plock, _irqL *pirqL);
	void (*rtw_enter_critical_bh)(_lock *plock, _irqL *pirqL);
	void (*rtw_exit_critical_bh)(_lock *plock, _irqL *pirqL);
	int (*rtw_enter_critical_mutex)(_mutex *pmutex, _irqL *pirqL);
	void (*rtw_exit_critical_mutex)(_mutex *pmutex, _irqL *pirqL);
	void (*rtw_spinlock_init)(_lock *plock);
	void (*rtw_spinlock_free)(_lock *plock);
	void (*rtw_spin_lock)(_lock *plock);
	void (*rtw_spin_unlock)(_lock *plock);
	void (*rtw_spinlock_irqsave)(_lock *plock, _irqL *irqL);
	void (*rtw_spinunlock_irqsave)(_lock *plock, _irqL *irqL);
	int (*rtw_init_xqueue)( _xqueue* queue, const char* name, uint32_t message_size, uint32_t number_of_messages );
	int (*rtw_push_to_xqueue)( _xqueue* queue, void* message, uint32_t timeout_ms );
	int (*rtw_pop_from_xqueue)( _xqueue* queue, void* message, uint32_t timeout_ms );
	int (*rtw_deinit_xqueue)( _xqueue* queue );
	uint32_t	(*rtw_get_current_time)(void);
	uint32_t (*rtw_systime_to_ms)(uint32_t systime);
	uint32_t (*rtw_systime_to_sec)(uint32_t systime);
	uint32_t (*rtw_ms_to_systime)(uint32_t ms);
	uint32_t	(*rtw_sec_to_systime)(uint32_t sec);
	void (*rtw_msleep_os)(int ms);
	void (*rtw_usleep_os)(int us);
	void (*rtw_mdelay_os)(int ms);
	void (*rtw_udelay_os)(int us);
	void (*rtw_yield_os)(void);
	void (*ATOMIC_SET)(atomic_t *v, int i);
	int (*ATOMIC_READ)(atomic_t *v);
	void (*ATOMIC_ADD)(atomic_t *v, int i);
	void (*ATOMIC_SUB)(atomic_t *v, int i);
	void (*ATOMIC_INC)(atomic_t *v);
	void (*ATOMIC_DEC)(atomic_t *v);
	int (*ATOMIC_ADD_RETURN)(atomic_t *v, int i);
	int (*ATOMIC_SUB_RETURN)(atomic_t *v, int i);
	int (*ATOMIC_INC_RETURN)(atomic_t *v);
	int (*ATOMIC_DEC_RETURN)(atomic_t *v);
	uint64_t (*rtw_modular64)(uint64_t x, uint64_t y);
	int (*rtw_get_random_bytes)(void* dst, uint32_t size);
	uint32_t (*rtw_getFreeHeapSize)(void);
	int (*rtw_create_task)(struct task_struct *task, const char *name, uint32_t stack_size, uint32_t priority, thread_func_t func, void *thctx);
	void (*rtw_delete_task)(struct task_struct *task);
	void (*rtw_wakeup_task)(struct task_struct *task);
	
#line 1311 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\os_dep\\include\\osdep_service.h"
	void (*rtw_thread_enter)(char *name);
	void (*rtw_thread_exit)(void);
	_timerHandle (*rtw_timerCreate)( const signed char *pcTimerName, 
							  osdepTickType xTimerPeriodInTicks, 
							  uint32_t uxAutoReload, 
							  void * pvTimerID, 
							  TIMER_FUN pxCallbackFunction );
	uint32_t (*rtw_timerDelete)( _timerHandle xTimer, 
							   osdepTickType xBlockTime );
	uint32_t (*rtw_timerIsTimerActive)( _timerHandle xTimer );
	uint32_t (*rtw_timerStop)( _timerHandle xTimer, 
							   osdepTickType xBlockTime );
	uint32_t (*rtw_timerChangePeriod)( _timerHandle xTimer, 
							   osdepTickType xNewPeriod, 
							   osdepTickType xBlockTime );
	void* (*rtw_timerGetID)( _timerHandle xTimer );	
	uint32_t (*rtw_timerStart)( _timerHandle xTimer, 
								osdepTickType xBlockTime );
	uint32_t (*rtw_timerStartFromISR)( _timerHandle xTimer, 
									osdepBASE_TYPE *pxHigherPriorityTaskWoken );
	
	uint32_t (*rtw_timerStopFromISR)( _timerHandle xTimer, 
								   osdepBASE_TYPE *pxHigherPriorityTaskWoken );
	
	uint32_t  (*rtw_timerResetFromISR)( _timerHandle xTimer, 
								   osdepBASE_TYPE *pxHigherPriorityTaskWoken );
	
	uint32_t  (*rtw_timerChangePeriodFromISR)( _timerHandle xTimer, 
								   osdepTickType xNewPeriod, 
								   osdepBASE_TYPE *pxHigherPriorityTaskWoken );
	
	uint32_t  (*rtw_timerReset)( _timerHandle xTimer, 
							osdepTickType xBlockTime );

	void (*rtw_acquire_wakelock)(void);
	void (*rtw_release_wakelock)(void);
	void (*rtw_wakelock_timeout)(uint32_t timeoutMs);
	uint8_t (*rtw_get_scheduler_state)(void);
};

 



#line 8 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_service.c"
#line 1 "F:\\IAR\\arm\\inc\\c\\stdio.h"
 
 
#line 241 "F:\\IAR\\arm\\inc\\c\\stdio.h"

#line 292 "F:\\IAR\\arm\\inc\\c\\stdio.h"




 
#line 9 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_service.c"
#line 1 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_pmu.h"











#line 28 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_pmu.h"


typedef enum {
	PMU_OS					=0,
	PMU_WLAN_DEVICE		=1,
	PMU_LOGUART_DEVICE	=2,
	PMU_SDIO_DEVICE		=3,

	PMU_UART0_DEVICE		=4,
	PMU_UART1_DEVICE		=5,
	PMU_I2C0_DEVICE		=6,
	PMU_I2C1_DEVICE		=7,
	PMU_USOC_DEVICE		=8,
	PMU_DONGLE_DEVICE	=9,
	PMU_RTC_DEVICE		=10,
	PMU_CONSOL_DEVICE	=11,
	PMU_ADC_DEVICE	=12,
	PMU_WAKWLOCK_TIMEOUT=13,
	PMU_DEV_USER_BASE	=16,

	PMU_MAX				=31
} PMU_DEVICE;

enum SLEEP_TYPE {
	SLEEP_PG	= 0,
	SLEEP_CG	= 1,
};





typedef uint32_t (*PSM_HOOK_FUN)( unsigned int, void* param_ptr );










 
void pmu_acquire_wakelock(uint32_t nDeviceId);






 
void pmu_release_wakelock(uint32_t nDeviceId);




 
uint32_t pmu_get_wakelock_status(void);

#line 112 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_pmu.h"








 
uint32_t pmu_set_sysactive_time(uint32_t timeout_ms);

void pmu_add_wakeup_event(uint32_t event);
void pmu_del_wakeup_event(uint32_t event);

void pmu_register_sleep_callback(uint32_t nDeviceId, PSM_HOOK_FUN sleep_hook_fun, void* sleep_param_ptr, PSM_HOOK_FUN wakeup_hook_fun, void* wakeup_param_ptr);
void pmu_unregister_sleep_callback(uint32_t nDeviceId);

#line 136 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\project\\realtek_amebaz_va0_example\\EWARM-RELEASE\\..\\..\\..\\component\\os\\freertos\\freertos_pmu.h"

#line 10 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_service.c"

 









void save_and_cli()
{
	vPortEnterCritical();
}

void restore_flags()
{
	vPortExitCritical();
}

void cli()
{
	ulPortSetInterruptMask();
}

 
static unsigned int __div64_32(uint64_t *n, unsigned int base)
{
	uint64_t rem = *n;
	uint64_t b = base;
	uint64_t res, d = 1;
	unsigned int high = rem >> 32;

	 
	res = 0;
	if (high >= base) {
		high /= base;
		res = (uint64_t) high << 32;
		rem -= (uint64_t) (high * base) << 32;
	}

	while ((uint64_t)b > 0 && b < rem) {
		b = b+b;
		d = d+d;
	}

	do {
		if (rem >= b) {
			rem -= b;
			res += d;
		}
		b >>= 1;
		d >>= 1;
	} while (d);

	*n = res;
	return rem;
}

 

uint8_t* _freertos_malloc(uint32_t sz)
{
	return pvPortMalloc(sz);
}

uint8_t* _freertos_zmalloc(uint32_t sz)
{
	uint8_t *pbuf = _freertos_malloc(sz);

	if (pbuf != 0)
		_memset(pbuf, 0, sz);

	return pbuf;	
}

void _freertos_mfree(uint8_t *pbuf, uint32_t sz)
{
	vPortFree(pbuf);
}

static void _freertos_memcpy(void* dst, void* src, uint32_t sz)
{
	_memcpy(dst, src, sz);
}

static int _freertos_memcmp(void *dst, void *src, uint32_t sz)
{

	if (!(_memcmp(dst, src, sz)))
		return 1;

	return 0;
}

static void _freertos_memset(void *pbuf, int c, uint32_t sz)
{
	_memset(pbuf, c, sz);
}

static void _freertos_init_sema(_sema *sema, int init_val)
{
	*sema = xQueueCreateCountingSemaphore( ( 0xffffffff ), ( init_val ) );	
}

static void _freertos_free_sema(_sema *sema)
{
	if(*sema != 0)
		vQueueDelete( ( QueueHandle_t ) ( *sema ) );

	*sema = 0;
}

static void _freertos_up_sema(_sema *sema)
{
	xQueueGenericSend( ( QueueHandle_t ) ( *sema ), 0, ( ( TickType_t ) 0U ), ( ( BaseType_t ) 0 ) );
}

static void _freertos_up_sema_from_isr(_sema *sema)
{
	long taskWoken = ( ( BaseType_t ) 0 );
	xQueueGenericSendFromISR( ( QueueHandle_t ) ( *sema ), 0, ( &taskWoken ), ( ( BaseType_t ) 0 ) );
	if( taskWoken ) ( * ( ( volatile uint32_t * ) 0xe000ed04 ) ) = ( 1UL << 28UL );
}

static uint32_t _freertos_down_sema(_sema *sema, uint32_t timeout)
{
	if(timeout == 0xFFFFFFFF) {
		timeout = ( TickType_t ) 0xffffffffUL;
	} else {
		timeout = rtw_ms_to_systime(timeout);
	}

	if(xQueueGenericReceive( ( QueueHandle_t ) ( *sema ), 0, ( timeout ), ( ( BaseType_t ) 0 ) ) != ( ( BaseType_t ) 1 )) {
		return ( ( BaseType_t ) 0 );
	}

	return ( ( BaseType_t ) 1 );
}

static void _freertos_mutex_init(_mutex *pmutex)
{
	*pmutex = xQueueCreateMutex( ( ( uint8_t ) 1U ) );
}

static void _freertos_mutex_free(_mutex *pmutex)
{
	if(*pmutex != 0)
		vQueueDelete( ( QueueHandle_t ) ( *pmutex ) );

	*pmutex = 0;
}

static void _freertos_mutex_get(_lock *plock)
{
	while(xQueueGenericReceive( ( QueueHandle_t ) ( *plock ), 0, ( 60 * 1000 / ( ( TickType_t ) 1000 / ( ( uint32_t ) 1000 ) ) ), ( ( BaseType_t ) 0 ) ) != ( ( BaseType_t ) 1 ))
		rtl_printf("\n\r[%s] " "[%s] %s(%p) failed, retry\n", __FUNCTION__,pcTaskGetTaskName(0), __FUNCTION__, plock);
}

static int _freertos_mutex_get_timeout(_lock *plock, uint32_t timeout_ms)
{
	if(xQueueGenericReceive( ( QueueHandle_t ) ( *plock ), 0, ( timeout_ms / ( ( TickType_t ) 1000 / ( ( uint32_t ) 1000 ) ) ), ( ( BaseType_t ) 0 ) ) != ( ( BaseType_t ) 1 )){
		rtl_printf("\n\r[%s] " "[%s] %s(%p) failed, retry\n", __FUNCTION__,pcTaskGetTaskName(0), __FUNCTION__, plock);
		return -1;
	}
	return 0;
}

static void _freertos_mutex_put(_lock *plock)
{
	xQueueGenericSend( ( QueueHandle_t ) ( *plock ), 0, ( ( TickType_t ) 0U ), ( ( BaseType_t ) 0 ) );
}

static void _freertos_enter_critical(_lock *plock, _irqL *pirqL)
{
	vPortEnterCritical();
}

static void _freertos_exit_critical(_lock *plock, _irqL *pirqL)
{
	vPortExitCritical();
}

static uint32_t uxSavedInterruptStatus = 0;
static void _freertos_enter_critical_from_isr(_lock *plock, _irqL *pirqL)
{
    ;

    uxSavedInterruptStatus = ulPortSetInterruptMask();
}

static void _freertos_exit_critical_from_isr(_lock *plock, _irqL *pirqL)
{
	vPortClearInterruptMask( uxSavedInterruptStatus );
}

static int _freertos_enter_critical_mutex(_mutex *pmutex, _irqL *pirqL)
{
	int ret = 0;

	while(xQueueGenericReceive( ( QueueHandle_t ) ( *pmutex ), 0, ( 60 * 1000 / ( ( TickType_t ) 1000 / ( ( uint32_t ) 1000 ) ) ), ( ( BaseType_t ) 0 ) ) != ( ( BaseType_t ) 1 ))
		rtl_printf("\n\r[%s] %s(%p) failed, retry\n", pcTaskGetTaskName(0), __FUNCTION__, pmutex);

	return ret;
}

static void _freertos_exit_critical_mutex(_mutex *pmutex, _irqL *pirqL)
{
	xQueueGenericSend( ( QueueHandle_t ) ( *pmutex ), 0, ( ( TickType_t ) 0U ), ( ( BaseType_t ) 0 ) );
}

static void _freertos_spinlock_init(_lock *plock)
{

	*plock = xQueueCreateMutex( ( ( uint8_t ) 1U ) );

}

static void _freertos_spinlock_free(_lock *plock)
{

	if(*plock != 0)
		vQueueDelete( ( QueueHandle_t ) ( *plock ) );

	*plock = 0;

}

static void _freertos_spinlock(_lock *plock)
{

	while(xQueueGenericReceive( ( QueueHandle_t ) ( *plock ), 0, ( 60 * 1000 / ( ( TickType_t ) 1000 / ( ( uint32_t ) 1000 ) ) ), ( ( BaseType_t ) 0 ) ) != ( ( BaseType_t ) 1 ))
		rtl_printf("\n\r[%s] " "[%s] %s(%p) failed, retry\n", __FUNCTION__,pcTaskGetTaskName(0), __FUNCTION__, plock);

}

static void _freertos_spinunlock(_lock *plock)
{

	xQueueGenericSend( ( QueueHandle_t ) ( *plock ), 0, ( ( TickType_t ) 0U ), ( ( BaseType_t ) 0 ) );

}

static void _freertos_spinlock_irqsave(_lock *plock, _irqL *irqL)
{
	vPortEnterCritical();

	while(xQueueGenericReceive( ( QueueHandle_t ) ( *plock ), 0, ( 60 * 1000 / ( ( TickType_t ) 1000 / ( ( uint32_t ) 1000 ) ) ), ( ( BaseType_t ) 0 ) ) != ( ( BaseType_t ) 1 ))
		rtl_printf("\n\r[%s] " "[%s] %s(%p) failed, retry\n", __FUNCTION__,pcTaskGetTaskName(0), __FUNCTION__, plock);

}

static void _freertos_spinunlock_irqsave(_lock *plock, _irqL *irqL)
{

	xQueueGenericSend( ( QueueHandle_t ) ( *plock ), 0, ( ( TickType_t ) 0U ), ( ( BaseType_t ) 0 ) );

	vPortExitCritical();
}

static int _freertos_init_xqueue( _xqueue* queue, const char* name, uint32_t message_size, uint32_t number_of_messages )
{
    if ( ( *queue = xQueueGenericCreate( number_of_messages, message_size, ( ( uint8_t ) 0U ) ) ) == 0 )
    {
        return -1;
    }

    return 0;
}

static int _freertos_push_to_xqueue( _xqueue* queue, void* message, uint32_t timeout_ms )
{
	if(timeout_ms == 0xFFFFFFFF) {
	      timeout_ms = ( TickType_t ) 0xffffffffUL;
	} else {
	      timeout_ms = rtw_ms_to_systime(timeout_ms);
	}

    if ( xQueueGenericSend( ( *queue ), ( message ), ( timeout_ms ), ( ( BaseType_t ) 0 ) ) != ( ( ( BaseType_t ) 1 ) ) )
    {
        return -1;
    }

    return 0;
}

static int _freertos_pop_from_xqueue( _xqueue* queue, void* message, uint32_t timeout_ms )
{
	if(timeout_ms == 0xFFFFFFFF) {
		timeout_ms = ( TickType_t ) 0xffffffffUL;
	} else {
		timeout_ms = rtw_ms_to_systime(timeout_ms);
	}

    if ( xQueueGenericReceive( ( *queue ), ( message ), ( timeout_ms ), ( ( BaseType_t ) 0 ) ) != ( ( ( BaseType_t ) 1 ) ) )
    {
        return -1;
    }

    return 0;
}

static int _freertos_deinit_xqueue( _xqueue* queue )
{
    int result = 0;

	  if( uxQueueMessagesWaiting( queue ) )
	  {
	  	  result = -1;
	  }
    vQueueDelete( *queue );
    return result;
}

static uint32_t _freertos_get_current_time(void)
{
	return xTaskGetTickCount();	
}

static uint32_t _freertos_systime_to_ms(uint32_t systime)
{
	return systime * ( ( TickType_t ) 1000 / ( ( uint32_t ) 1000 ) );
}

static uint32_t _freertos_systime_to_sec(uint32_t systime)
{
	return systime / ( ( uint32_t ) 1000 );
}

static uint32_t _freertos_ms_to_systime(uint32_t ms)
{
	return ms / ( ( TickType_t ) 1000 / ( ( uint32_t ) 1000 ) );
}

static uint32_t _freertos_sec_to_systime(uint32_t sec)
{
	return sec * ( ( uint32_t ) 1000 );
}

static void _freertos_msleep_os(int ms)
{



	if (pmu_yield_os_check()) {
		vTaskDelay(ms / ( ( TickType_t ) 1000 / ( ( uint32_t ) 1000 ) ));
	} else {
		DelayMs(ms);
	}

}

static void _freertos_usleep_os(int us)
{
#line 371 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_service.c"
	DelayUs(us);



}

static void _freertos_mdelay_os(int ms)
{
	vTaskDelay(ms / ( ( TickType_t ) 1000 / ( ( uint32_t ) 1000 ) ));
}

static void _freertos_udelay_os(int us)
{
#line 390 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_service.c"
	DelayUs(us);



}

static void _freertos_yield_os(void)
{



	if (pmu_yield_os_check()) {
		vPortYield();
	} else {
		DelayMs(1);
	}

}

static void _freertos_ATOMIC_SET(atomic_t *v, int i)
{
	((v)->counter = (i));
}

static int _freertos_ATOMIC_READ(atomic_t *v)
{
	return ((v)->counter);
}

static void _freertos_ATOMIC_ADD(atomic_t *v, int i)
{
	save_and_cli();
	v->counter += i;
	restore_flags();
}

static void _freertos_ATOMIC_SUB(atomic_t *v, int i)
{
	save_and_cli();
	v->counter -= i;
	restore_flags();
}

static void _freertos_ATOMIC_INC(atomic_t *v)
{
	_freertos_ATOMIC_ADD(v, 1);
}

static void _freertos_ATOMIC_DEC(atomic_t *v)
{
	_freertos_ATOMIC_SUB(v, 1);
}

static int _freertos_ATOMIC_ADD_RETURN(atomic_t *v, int i)
{
	int temp;

	save_and_cli();
	temp = v->counter;
	temp += i;
	v->counter = temp;
	restore_flags();

	return temp;
}

static int _freertos_ATOMIC_SUB_RETURN(atomic_t *v, int i)
{
	int temp;

	save_and_cli();
	temp = v->counter;
	temp -= i;
	v->counter = temp;
	restore_flags();

	return temp;
}

static int _freertos_ATOMIC_INC_RETURN(atomic_t *v)
{
	return _freertos_ATOMIC_ADD_RETURN(v, 1);
}

static int _freertos_ATOMIC_DEC_RETURN(atomic_t *v)
{
	return _freertos_ATOMIC_SUB_RETURN(v, 1);
}

static uint64_t _freertos_modular64(uint64_t n, uint64_t base)
{
	unsigned int __base = (base);
	unsigned int __rem;

	if (((n) >> 32) == 0) {
		__rem = (unsigned int)(n) % __base;
		(n) = (unsigned int)(n) / __base;
	}
	else
		__rem = __div64_32(&(n), __base);
	
	return __rem;
}

 
static int _freertos_arc4random(void)
{
	uint32_t res = xTaskGetTickCount();
	static unsigned long seed = 0xDEADB00B;


	if(random_seed){
		seed = random_seed;
		random_seed = 0;
	}

	
	seed = ((seed & 0x007F00FF) << 7) ^
	    ((seed & 0x0F80FF00) >> 8) ^ 
	    (res << 13) ^ (res >> 9);    
	return (int)seed;
}

static int _freertos_get_random_bytes(void *buf, size_t len)
{

	unsigned int ranbuf;
	unsigned int *lp;
	int i, count;
	count = len / sizeof(unsigned int);
	lp = (unsigned int *) buf;

	for(i = 0; i < count; i ++) {
		lp[i] = _freertos_arc4random();  
		len -= sizeof(unsigned int);
	}

	if(len > 0) {
		ranbuf = _freertos_arc4random();
		_freertos_memcpy(&lp[i], &ranbuf, len);
	}
	return 0;
#line 542 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_service.c"
}

static uint32_t _freertos_GetFreeHeapSize(void)
{
	return (uint32_t)xPortGetFreeHeapSize();
}
void *tcm_heap_malloc(int size);
static int _freertos_create_task(struct task_struct *ptask, const char *name,
	uint32_t  stack_size, uint32_t priority, thread_func_t func, void *thctx)
{
	thread_func_t task_func = 0;
	void *task_ctx = 0;
	int ret = 0;

	ptask->task_name = name;
	ptask->blocked = 0;
	ptask->callback_running = 0;
	
	_freertos_init_sema(&ptask->wakeup_sema, 0);
	_freertos_init_sema(&ptask->terminate_sema, 0);
	

	if(func){
		task_func = func;
		task_ctx = thctx;
	}
	
	
	
	

	priority += ( ( UBaseType_t ) 0U ) + ( 4 );

	if(rtw_if_wifi_thread(name) == 0){

#line 593 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_service.c"
		ret = xTaskGenericCreate( ( task_func ), ( (const char *)name ), ( stack_size ), ( task_ctx ), ( priority ), ( &ptask->task ), ( 0 ), ( 0 ) );
#line 601 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_service.c"
	}
	else{
		ret = xTaskGenericCreate( ( task_func ), ( (const char *)name ), ( stack_size ), ( task_ctx ), ( priority ), ( &ptask->task ), ( 0 ), ( 0 ) );
#line 610 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_service.c"

	}
	if(ret != ( ( ( BaseType_t ) 1 ) )){
		rtl_printf("\n\r[%s] " "Create Task \"%s\" Failed! ret=%d\n", __FUNCTION__,ptask->task_name, ret);
	}
	
	;
	return ret;
}
	
static void _freertos_delete_task(struct task_struct *ptask)
{
	if (!ptask->task){
		rtl_printf("\n\r[%s] " "_freertos_delete_task(): ptask is NULL!\n", __FUNCTION__);
		return;
	}

	ptask->blocked = 1;

	_freertos_up_sema(&ptask->wakeup_sema);
	_freertos_down_sema(&ptask->terminate_sema, 0xFFFFFFFF);
	
	
	_freertos_free_sema(&ptask->wakeup_sema);
	_freertos_free_sema(&ptask->terminate_sema);

	ptask->task = 0;
	
	;
}

void _freertos_wakeup_task(struct task_struct *ptask)
{
	_freertos_up_sema(&ptask->wakeup_sema);
}

static void _freertos_thread_enter(char *name)
{
	;
}

static void _freertos_thread_exit(void)
{
	; 
	vTaskDelete(0); 
}

_timerHandle _freertos_timerCreate( const signed char *pcTimerName, 
							  osdepTickType xTimerPeriodInTicks, 
							  uint32_t uxAutoReload, 
							  void * pvTimerID, 
							  TIMER_FUN pxCallbackFunction )
{
	if(xTimerPeriodInTicks == 0xFFFFFFFF) {
		xTimerPeriodInTicks = ( TickType_t ) 0xffffffffUL;
	}
	return xTimerCreate((const char *)pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction);	
}

uint32_t _freertos_timerDelete( _timerHandle xTimer, 
							   osdepTickType xBlockTime )
{
	return (uint32_t)xTimerGenericCommand( ( xTimer ), ( ( BaseType_t ) 5 ), 0U, 0, ( xBlockTime ) );	
}

uint32_t _freertos_timerIsTimerActive( _timerHandle xTimer )
{
	return (uint32_t)xTimerIsTimerActive(xTimer);	
}

uint32_t  _freertos_timerStop( _timerHandle xTimer, 
							   osdepTickType xBlockTime )
{
	return (uint32_t)xTimerGenericCommand( ( xTimer ), ( ( BaseType_t ) 3 ), 0U, 0, ( xBlockTime ) );	
}

uint32_t  _freertos_timerChangePeriod( _timerHandle xTimer, 
							   osdepTickType xNewPeriod, 
							   osdepTickType xBlockTime )
{
	if(xNewPeriod == 0)
		xNewPeriod += 1;
	return (uint32_t)xTimerGenericCommand( ( xTimer ), ( ( BaseType_t ) 4 ), ( xNewPeriod ), 0, ( xBlockTime ) );	
}
void *_freertos_timerGetID( _timerHandle xTimer ){

	return pvTimerGetTimerID(xTimer);
}

uint32_t  _freertos_timerStart( _timerHandle xTimer, 
							   osdepTickType xBlockTime )
{
	return (uint32_t)xTimerGenericCommand( ( xTimer ), ( ( BaseType_t ) 1 ), ( xTaskGetTickCount() ), 0, ( xBlockTime ) );	
}

uint32_t  _freertos_timerStartFromISR( _timerHandle xTimer, 
							   osdepBASE_TYPE *pxHigherPriorityTaskWoken )
{
	return (uint32_t)xTimerGenericCommand( ( xTimer ), ( ( BaseType_t ) 6 ), ( xTaskGetTickCountFromISR() ), ( pxHigherPriorityTaskWoken ), 0U );	
}

uint32_t  _freertos_timerStopFromISR( _timerHandle xTimer, 
							   osdepBASE_TYPE *pxHigherPriorityTaskWoken )
{
	return (uint32_t)xTimerGenericCommand( ( xTimer ), ( ( BaseType_t ) 8 ), 0, ( pxHigherPriorityTaskWoken ), 0U );	
}

uint32_t  _freertos_timerResetFromISR( _timerHandle xTimer, 
							   osdepBASE_TYPE *pxHigherPriorityTaskWoken )
{
	return (uint32_t)xTimerGenericCommand( ( xTimer ), ( ( BaseType_t ) 7 ), ( xTaskGetTickCountFromISR() ), ( pxHigherPriorityTaskWoken ), 0U );	
}

uint32_t  _freertos_timerChangePeriodFromISR( _timerHandle xTimer, 
							   osdepTickType xNewPeriod, 
							   osdepBASE_TYPE *pxHigherPriorityTaskWoken )
{
	if(xNewPeriod == 0)
		xNewPeriod += 1;
	return (uint32_t)xTimerGenericCommand( ( xTimer ), ( ( BaseType_t ) 9 ), ( xNewPeriod ), ( pxHigherPriorityTaskWoken ), 0U );
}

uint32_t  _freertos_timerReset( _timerHandle xTimer, 
							   osdepTickType xBlockTime )
{
	return (uint32_t)xTimerGenericCommand( ( xTimer ), ( ( BaseType_t ) 2 ), ( xTaskGetTickCount() ), 0, ( xBlockTime ) );	
}

void _freertos_acquire_wakelock()
{
#line 747 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_service.c"


	if (pmu_yield_os_check()) 
   		 pmu_acquire_wakelock(PMU_WLAN_DEVICE);



}

void _freertos_release_wakelock()
{

#line 766 "C:\\Users\\Administrator\\Desktop\\sdk-ameba-v4.0c\\component\\os\\freertos\\freertos_service.c"


	if (pmu_yield_os_check()) 
		pmu_release_wakelock(PMU_WLAN_DEVICE);



}

void _freertos_wakelock_timeout(uint32_t timeout)
{



	if (pmu_yield_os_check()) 
		pmu_set_sysactive_time(timeout);
	else
		;

}

uint8_t _freertos_get_scheduler_state(void)
{
	uint8_t state = xTaskGetSchedulerState();
	switch(state){
		case ( ( BaseType_t ) 1 ):	state = 0;	break;
		case ( ( BaseType_t ) 2 ):		state = 1;		break;
		case ( ( BaseType_t ) 0 ):	state = 2;		break;
	}
	return state;
}


const struct osdep_service_ops osdep_service = {
	_freertos_malloc,			
	_freertos_zmalloc,			
	_freertos_mfree,			
	_freertos_malloc,			
	_freertos_zmalloc,			
	_freertos_mfree,			
	_freertos_memcpy,			
	_freertos_memcmp,			
	_freertos_memset,			
	_freertos_init_sema,		
	_freertos_free_sema,		
	_freertos_up_sema,			
	_freertos_up_sema_from_isr,	
	_freertos_down_sema,		
	_freertos_mutex_init,		
	_freertos_mutex_free,		
	_freertos_mutex_get,		
	_freertos_mutex_get_timeout,
	_freertos_mutex_put,		
	_freertos_enter_critical,	
	_freertos_exit_critical,	
	_freertos_enter_critical_from_isr,	
	_freertos_exit_critical_from_isr,	
	0,		
	0,		
	_freertos_enter_critical_mutex,	
	_freertos_exit_critical_mutex,	
	_freertos_spinlock_init,		
	_freertos_spinlock_free,		
	_freertos_spinlock,				
	_freertos_spinunlock,			
	_freertos_spinlock_irqsave,		
	_freertos_spinunlock_irqsave,	
	_freertos_init_xqueue,			
	_freertos_push_to_xqueue,		
	_freertos_pop_from_xqueue,		
	_freertos_deinit_xqueue,		
	_freertos_get_current_time,		
	_freertos_systime_to_ms,		
	_freertos_systime_to_sec,		
	_freertos_ms_to_systime,		
	_freertos_sec_to_systime,		
	_freertos_msleep_os,	
	_freertos_usleep_os,	
	_freertos_mdelay_os,	
	_freertos_udelay_os,	
	_freertos_yield_os,		
	
	_freertos_ATOMIC_SET,	
	_freertos_ATOMIC_READ,	
	_freertos_ATOMIC_ADD,	
	_freertos_ATOMIC_SUB,	
	_freertos_ATOMIC_INC,	
	_freertos_ATOMIC_DEC,	
	_freertos_ATOMIC_ADD_RETURN,	
	_freertos_ATOMIC_SUB_RETURN,	
	_freertos_ATOMIC_INC_RETURN,	
	_freertos_ATOMIC_DEC_RETURN,	

	_freertos_modular64,			
	_freertos_get_random_bytes,		
	_freertos_GetFreeHeapSize,		

	_freertos_create_task,			
	_freertos_delete_task,			
	_freertos_wakeup_task,			

	_freertos_thread_enter,			
	_freertos_thread_exit,			

	_freertos_timerCreate,			
	_freertos_timerDelete,			
	_freertos_timerIsTimerActive,	
	_freertos_timerStop,			
	_freertos_timerChangePeriod,	
	_freertos_timerGetID,			
	_freertos_timerStart,			
	_freertos_timerStartFromISR,	
	_freertos_timerStopFromISR,		
	_freertos_timerResetFromISR,	
	_freertos_timerChangePeriodFromISR,	
	_freertos_timerReset,			

	_freertos_acquire_wakelock,		
	_freertos_release_wakelock,		
	_freertos_wakelock_timeout,		
	_freertos_get_scheduler_state	
};
